<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Building Clearer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        html, body {
            width: 100%;
            height: 100%;
            overflow-x: hidden;
        }
        body {
            background: #1a1a2e;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: monospace;
        }
        #gameContainer {
            text-align: center;
            width: 100%;
            max-width: 100%;
            padding: 10px;
        }
        canvas {
            border: 4px solid #4a4a6a;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            max-width: 100%;
            height: auto;
            display: block;
            margin: 0 auto;
        }
        #ui {
            color: #fff;
            margin-top: 10px;
            font-size: 14px;
        }
        #instructions {
            color: #888;
            margin-top: 10px;
            font-size: 11px;
            word-wrap: break-word;
        }
        .mobile-only {
            display: none;
        }
        @media (max-width: 600px), (max-aspect-ratio: 1/1) {
            .desktop-only {
                display: none;
            }
            .mobile-only {
                display: block;
                color: #888;
                margin-top: 10px;
                font-size: 11px;
            }
            #ui {
                font-size: 12px;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="game" width="640" height="480"></canvas>
        <div id="ui">
            <span id="health">Health: 100</span> |
            <span id="ammo">Ammo: 30</span> |
            <span id="score">Score: 0</span> |
            <span id="level">Building: 1</span>
        </div>
        <div id="instructions" class="desktop-only">
            WASD to move | Mouse to aim | Click to shoot | R to reload | Clear all enemies to advance!
        </div>
        <div id="instructions-mobile" class="mobile-only">
            Left side: drag to move | Right side: tap to aim & shoot
        </div>
    </div>

    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script src="js/state.js"></script>
    <script src="js/constants.js"></script>
    <script src="js/utils.js"></script>
    <script src="js/particles.js"></script>
    <script src="js/drawing/floor-decorations.js"></script>
    <script src="js/drawing/level-props.js"></script>
    <script src="js/drawing/wall-decorations.js"></script>
    <script src="js/drawing/player.js"></script>
    <script src="js/drawing/enemies.js"></script>
    <script src="js/music.js"></script>
    <script src="js/sfx.js"></script>
    <script>
        // Initialize G with DOM references
        G.canvas = document.getElementById('game');
        G.ctx = G.canvas.getContext('2d');
        G.ctx.imageSmoothingEnabled = false;
        G.isMobile = window.innerWidth < 600 || (window.innerWidth < window.innerHeight);
        if (G.isMobile) {
            G.canvas.width = 360;
            G.canvas.height = 640;
        } else {
            G.canvas.width = 640;
            G.canvas.height = 480;
        }
        G.W = G.canvas.width;
        const ISO_SCALE = 0.65;
        // Expand world height so it fills the canvas after Y-compression
        const BASE_H = G.isMobile ? 640 : 480; // original layout design height
        G.H = Math.round(G.canvas.height / ISO_SCALE);
        G.ISO_SCALE = ISO_SCALE;
        G.ENEMY_TYPES = DUNGEON_ENEMIES.dungeon;

        // Offscreen canvas for lighting overlay (matches world dimensions)
        const lightCanvas = document.createElement('canvas');
        lightCanvas.width = G.W;
        lightCanvas.height = G.H;
        const lightCtx = lightCanvas.getContext('2d');

        // Local aliases so existing code works unchanged
        const canvas = G.canvas;
        const ctx = G.ctx;
        const isMobile = G.isMobile;
        const W = G.W;
        const H = G.H;

        // Player object
        const player = {
            x: 320, y: 400, width: 16, height: 16,
            speed: 1.5, health: 100, maxHealth: 100,
            ammo: 12, maxAmmo: 12, angle: 0,
            reloading: false, reloadTime: 0, shootCooldown: 0,
            weapon: 'pistol', swinging: false, swingAngle: 0, swingProgress: 0
        };
        G.player = player;

        const keys = {};
        G.keys = keys;

        const safeZone = { x: 0, y: 0, radius: 50 };
        G.safeZone = safeZone;

        // Mutable state (bare names for existing inline code)
        let gameState = 'menu';
        let selectedDungeon = null;
        let pendingDungeon = null;
        let charSelectButtons = [];
        let score = 0;
        let currentLevel = 1;
        let coins = parseInt(localStorage.getItem('coins')) || 0;
        let selectedClass = localStorage.getItem('selectedClass') || 'default';
        let unlockedClasses = JSON.parse(localStorage.getItem('unlockedClasses')) || ['default', 'scout'];
        let bossesDefeated = parseInt(localStorage.getItem('bossesDefeated')) || 0;
        let highestLevel = parseInt(localStorage.getItem('highestLevel')) || 0;
        const COLOR_OPTIONS = [
            { color: '#4ecdc4', colorDark: '#2ea8a0', name: 'Teal' },
            { color: '#3498db', colorDark: '#2476b0', name: 'Blue' },
            { color: '#2ecc71', colorDark: '#27ae60', name: 'Green' },
            { color: '#e74c3c', colorDark: '#c0392b', name: 'Red' },
            { color: '#e67e22', colorDark: '#d35400', name: 'Orange' },
            { color: '#f1c40f', colorDark: '#d4ac0b', name: 'Gold' },
            { color: '#9b59b6', colorDark: '#8e44ad', name: 'Purple' },
            { color: '#95a5a6', colorDark: '#7f8c8d', name: 'Silver' },
            { color: '#e91e63', colorDark: '#c2185b', name: 'Pink' },
            { color: '#1abc9c', colorDark: '#16a085', name: 'Mint' },
        ];
        let selectedColorIdx = parseInt(localStorage.getItem('selectedColorIdx')) || 0;
        let scrap = 0;
        let playerArmor = 0;
        let playerArmorTier = 0;
        let playerCharms = [];
        let runShopInventory = [];
        let regenTimer = 0;
        let ENEMY_TYPES = DUNGEON_ENEMIES.dungeon;
        let mouseX = 0, mouseY = 0;
        let mouseDown = false;
        let enemyAlerted = false; // true once first enemy starts chasing this level
        let bullets = [];
        let enemies = [];
        let walls = [];
        let particles = [];
        let pickups = [];
        let bombs = [];
        let floorDecorations = [];
        let levelProps = [];
        let bossWarningZones = [];
        let levelLights = [];
        let activeBoss = null;
        let COLORS = {
            player: '#4ecdc4',
            playerDark: '#2ea8a0',
            enemy: '#e74c3c',
            enemyDark: '#c0392b',
            bullet: '#f39c12',
            wall: '#5d5d8a',
            wallDark: '#4a4a6a',
            floor: '#2d2d44',
            door: '#8b4513',
            health: '#2ecc71',
            ammo: '#f1c40f',
            shotgun: '#e67e22',
            railgun: '#9b59b6'
        };
        let currentDamageMult = 1;

        // Multiplayer state
        let peer = null;
        let conn = null;
        let isHost = false;
        let roomCode = '';
        let roomCodeInput = '';
        let multiplayerMode = null; // 'coop' or 'race'
        let remotePlayer = {
            x: 0, y: 0, angle: 0, health: 100, maxHealth: 100,
            weapon: 'pistol', swinging: false, swingProgress: 0, connected: false
        };
        let remoteBullets = [];
        let lastSyncTime = 0;
        const SYNC_INTERVAL = 50; // ms between syncs

        // Generate 4-character room code
        function generateRoomCode() {
            const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
            let code = '';
            for (let i = 0; i < 4; i++) {
                code += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return code;
        }

        // Expose arrays/objects on G so extracted files can access them.
        G.bullets = bullets;
        G.enemies = enemies;
        G.walls = walls;
        G.particles = particles;
        G.pickups = pickups;
        G.bombs = bombs;
        G.floorDecorations = floorDecorations;
        G.levelProps = levelProps;
        G.bossWarningZones = bossWarningZones;
        G.COLORS = COLORS;
        G.playerCharms = playerCharms;
        G.runShopInventory = runShopInventory;
        G.remotePlayer = remotePlayer;

        function saveProgress() {
            localStorage.setItem('coins', coins);
            localStorage.setItem('selectedClass', selectedClass);
            localStorage.setItem('unlockedClasses', JSON.stringify(unlockedClasses));
            localStorage.setItem('bossesDefeated', bossesDefeated);
            localStorage.setItem('highestLevel', highestLevel);
            localStorage.setItem('selectedColorIdx', selectedColorIdx);
        }

        function checkUnlocks() {
            let newUnlock = false;
            for (const [key, cls] of Object.entries(CLASSES)) {
                if (unlockedClasses.includes(key)) continue;
                const ut = cls.unlockType;
                if (ut === 'default') {
                    unlockedClasses.push(key);
                    newUnlock = true;
                } else if (ut && ut.startsWith('boss:')) {
                    const need = parseInt(ut.split(':')[1]);
                    if (bossesDefeated >= need) {
                        unlockedClasses.push(key);
                        newUnlock = true;
                    }
                } else if (ut && ut.startsWith('level:')) {
                    const need = parseInt(ut.split(':')[1]);
                    if (highestLevel >= need) {
                        unlockedClasses.push(key);
                        newUnlock = true;
                    }
                }
            }
            if (newUnlock) saveProgress();
        }
        checkUnlocks(); // Ensure default unlocks on startup
        // Reset selectedClass if it's no longer unlocked
        if (!unlockedClasses.includes(selectedClass)) {
            selectedClass = 'default';
            saveProgress();
        }

        // Save/load run state
        let savedRun = JSON.parse(localStorage.getItem('savedRun')) || null;

        function saveRun() {
            savedRun = {
                level: currentLevel,
                health: player.health,
                maxHealth: player.maxHealth,
                weapon: player.weapon,
                ammo: player.ammo,
                maxAmmo: player.maxAmmo,
                score: score,
                dungeon: selectedDungeon,
                speed: player.speed,
                scrap: scrap,
                playerArmor: playerArmor,
                playerArmorTier: playerArmorTier,
                playerCharms: playerCharms
            };
            localStorage.setItem('savedRun', JSON.stringify(savedRun));
        }

        function clearSavedRun() {
            savedRun = null;
            localStorage.removeItem('savedRun');
        }

        function loadRun() {
            if (!savedRun) return false;
            currentLevel = savedRun.level;
            player.health = savedRun.health;
            player.maxHealth = savedRun.maxHealth;
            player.weapon = savedRun.weapon;
            player.ammo = savedRun.ammo;
            player.maxAmmo = savedRun.maxAmmo;
            player.speed = savedRun.speed || 1.5;
            score = savedRun.score;
            scrap = savedRun.scrap || 0;
            playerArmor = savedRun.playerArmor || 0;
            playerArmorTier = savedRun.playerArmorTier || 0;
            playerCharms = savedRun.playerCharms || [];
            applyDungeonTheme(savedRun.dungeon);
            // Apply character color
            const selColor = COLOR_OPTIONS[selectedColorIdx] || COLOR_OPTIONS[0];
            COLORS.player = selColor.color;
            COLORS.playerDark = selColor.colorDark;
            generateLevel(currentLevel);
            // Restore health after generateLevel (which might reset it)
            player.health = savedRun.health;
            return true;
        }

        function applyDungeonTheme(dungeonKey) {
            const dungeon = DUNGEONS[dungeonKey];
            if (dungeon) {
                COLORS.wall = dungeon.wall;
                COLORS.wallDark = dungeon.wallDark;
                COLORS.floor = dungeon.floor;
                selectedDungeon = dungeonKey;
                G.selectedDungeon = dungeonKey;
                // Set dungeon-specific enemies
                ENEMY_TYPES = DUNGEON_ENEMIES[dungeonKey] || DUNGEON_ENEMIES.dungeon;
                G.ENEMY_TYPES = ENEMY_TYPES;
                // Set damage multiplier
                currentDamageMult = dungeon.enemyDamageMult || 1;
            }
        }

        // Reset run-only state (on death or new run)
        function resetRunState() {
            scrap = 0;
            playerArmor = 0;
            playerArmorTier = 0;
            playerCharms = [];
            runShopInventory = [];
            regenTimer = 0;
        }

        // Centralized kill handler
        function onEnemyKill(enemy) {
            score += 100;

            // Clear boss warning zones when boss dies
            if (enemy.type === 'boss') {
                bossWarningZones = [];
                G.bossWarningZones = bossWarningZones;
                activeBoss = null;
                bossesDefeated++;
                checkUnlocks();
            }

            // Scrap drop - always drops
            let scrapAmount;
            if (enemy.type === 'boss') {
                scrapAmount = 8 + Math.floor(Math.random() * 5); // 8-12
            } else if (enemy.type === 'tank') {
                scrapAmount = 2 + Math.floor(Math.random() * 3); // 2-4
            } else if (enemy.type === 'charger') {
                scrapAmount = 1;
            } else {
                scrapAmount = 1 + Math.floor(Math.random() * 2); // 1-2
            }
            // Scrap Magnet charm bonus
            if (playerCharms.includes('scrap_magnet')) {
                scrapAmount += 1;
            }
            dropScrapPickup(enemy.x, enemy.y, scrapAmount);

            // On-kill charm effects
            if (playerCharms.includes('vampiric_fang')) {
                player.health = Math.min(player.health + 5, player.maxHealth);
            }
            if (playerCharms.includes('boom_skull')) {
                SFX.explosion();
                // Small explosion on kill (radius 40, damage 20)
                for (let k = 0; k < 10; k++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 4 + 1;
                    particles.push({
                        x: enemy.x, y: enemy.y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: 20,
                        color: Math.random() > 0.3 ? '#ff4500' : '#ff0'
                    });
                }
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const other = enemies[j];
                    const dist = Math.hypot(other.x - enemy.x, other.y - enemy.y);
                    if (dist <= 40 && dist > 0) {
                        other.health -= 20;
                    }
                }
            }

            // Coin drop chance (30%)
            if (Math.random() < 0.3) {
                pickups.push({
                    x: enemy.x + (Math.random() - 0.5) * 10,
                    y: enemy.y + (Math.random() - 0.5) * 10,
                    type: 'coin', width: 10, height: 10, value: 1
                });
            }

            // Pickup drop chance (40%)
            if (Math.random() < 0.4) {
                let type;
                const roll = Math.random();
                if (roll < 0.08) {
                    const available = [];
                    if (currentLevel >= 1) available.push('smg');
                    if (currentLevel >= 2) available.push('shotgun', 'rifle');
                    if (currentLevel >= 3) available.push('railgun');
                    if (currentLevel >= 4) available.push('minigun');
                    if (currentLevel >= 2 && Math.random() < 0.25) available.push('sword');
                    if (currentLevel >= 3 && Math.random() < 0.25) available.push('katana');
                    if (currentLevel >= 3 && Math.random() < 0.15) available.push('sniper');
                    if (currentLevel >= 4 && Math.random() < 0.15) available.push('flamethrower');
                    if (currentLevel >= 5 && Math.random() < 0.15) available.push('rocketlauncher');
                    if (currentLevel >= 4 && Math.random() < 0.05) available.push('bomb');
                    if (available.length > 0) {
                        type = available[Math.floor(Math.random() * available.length)];
                    } else {
                        type = 'ammo';
                    }
                } else if (roll < 0.5) {
                    type = 'health';
                } else {
                    type = 'ammo';
                }
                pickups.push({
                    x: enemy.x, y: enemy.y,
                    type: type, width: 12, height: 12
                });
            }
        }

        // Spawn scrap pickup entity
        function dropScrapPickup(x, y, amount) {
            for (let i = 0; i < amount; i++) {
                pickups.push({
                    x: x + (Math.random() - 0.5) * 20,
                    y: y + (Math.random() - 0.5) * 20,
                    type: 'scrap', width: 8, height: 8, value: 1
                });
            }
        }

        // Apply/reapply passive charm stat mods
        function applyPassiveCharms() {
            // Get base class stats
            const cls = CLASSES[selectedClass] || CLASSES.default;
            let baseSpeed = cls.speed;
            let baseMaxHealth = cls.health;

            // Thick Skin: +25 max HP
            if (playerCharms.includes('thick_skin')) {
                baseMaxHealth += 25;
            }

            // Swift Boots: +20% speed
            if (playerCharms.includes('swift_boots')) {
                baseSpeed *= 1.2;
            }

            player.maxHealth = baseMaxHealth;
            player.speed = baseSpeed;

            // Big Magazines: +50% ammo capacity
            const weapon = WEAPONS[player.weapon];
            if (weapon && !weapon.melee) {
                let baseMaxAmmo = weapon.maxAmmo;
                if (playerCharms.includes('big_magazines')) {
                    baseMaxAmmo = Math.floor(baseMaxAmmo * 1.5);
                }
                player.maxAmmo = baseMaxAmmo;
            }
        }

        // Generate run shop inventory
        function generateRunShopInventory() {
            runShopInventory = [];

            // Next armor tier (if available)
            if (playerArmorTier < ARMOR_TIERS.length) {
                const nextArmor = ARMOR_TIERS[playerArmorTier];
                runShopInventory.push({ category: 'armor', data: nextArmor });
            }

            // 2 random weapons (level-gated, not already held)
            const availableWeapons = RUN_SHOP_WEAPONS
                .filter(w => w.minLevel <= currentLevel && w.weapon !== player.weapon);
            const shuffledWeapons = availableWeapons.sort(() => Math.random() - 0.5);
            for (let i = 0; i < Math.min(2, shuffledWeapons.length); i++) {
                runShopInventory.push({ category: 'weapon', data: shuffledWeapons[i] });
            }

            // 2 random charms (not already owned)
            const availableCharms = Object.keys(CHARMS)
                .filter(id => !playerCharms.includes(id));
            const shuffledCharms = availableCharms.sort(() => Math.random() - 0.5);
            const charmSlots = 3 - playerCharms.length;
            for (let i = 0; i < Math.min(2, shuffledCharms.length, charmSlots + 1); i++) {
                runShopInventory.push({
                    category: 'charm',
                    data: { id: shuffledCharms[i], ...CHARMS[shuffledCharms[i]] }
                });
            }
        }

        // Draw run shop UI
        function drawRunShop() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Scrap display
            ctx.fillStyle = '#95a5a6';
            ctx.font = isMobile ? '14px monospace' : '18px monospace';
            ctx.textAlign = 'right';
            ctx.fillText('Scrap: ' + scrap, canvas.width - 15, 25);

            // Title
            ctx.fillStyle = '#95a5a6';
            ctx.font = isMobile ? '22px monospace' : '32px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('RUN SHOP', canvas.width / 2, isMobile ? 50 : 55);

            ctx.fillStyle = '#666';
            ctx.font = isMobile ? '10px monospace' : '12px monospace';
            ctx.fillText('Spend scrap to upgrade this run', canvas.width / 2, isMobile ? 68 : 78);

            // Draw items in grid
            const cols = isMobile ? 2 : 3;
            const btnW = isMobile ? 155 : 185;
            const btnH = isMobile ? 75 : 85;
            const gap = isMobile ? 10 : 15;
            const startX = (canvas.width - (cols * btnW + (cols - 1) * gap)) / 2;
            const startY = isMobile ? 85 : 100;

            menuButtons = [];

            for (let i = 0; i < runShopInventory.length; i++) {
                const item = runShopInventory[i];
                const col = i % cols;
                const row = Math.floor(i / cols);
                const x = startX + col * (btnW + gap);
                const y = startY + row * (btnH + gap);

                let name, desc, price, itemColor, owned = false, cantUse = false;

                if (item.category === 'armor') {
                    name = item.data.name;
                    desc = Math.round(item.data.dr * 100) + '% damage reduction';
                    price = item.data.price;
                    itemColor = item.data.color;
                    owned = playerArmorTier >= item.data.tier;
                } else if (item.category === 'weapon') {
                    const wname = item.data.weapon;
                    name = wname.charAt(0).toUpperCase() + wname.slice(1);
                    desc = 'Weapon';
                    price = item.data.price;
                    itemColor = WEAPONS[wname].color;
                    owned = player.weapon === wname;
                } else if (item.category === 'charm') {
                    name = item.data.name;
                    desc = item.data.desc;
                    price = item.data.price;
                    itemColor = item.data.color;
                    owned = playerCharms.includes(item.data.id);
                    cantUse = !owned && playerCharms.length >= 3;
                }

                const canAfford = scrap >= price && !owned && !cantUse;

                menuButtons.push({ x, y, w: btnW, h: btnH, shopIndex: i });

                // Button background
                if (owned) {
                    ctx.fillStyle = '#2ecc71';
                } else if (canAfford) {
                    ctx.fillStyle = itemColor || '#888';
                } else {
                    ctx.fillStyle = '#444';
                }
                ctx.fillRect(x, y, btnW, btnH);
                ctx.fillStyle = '#1a1a2e';
                ctx.fillRect(x + 3, y + 3, btnW - 6, btnH - 6);

                // Category label
                ctx.fillStyle = '#666';
                ctx.font = isMobile ? '8px monospace' : '9px monospace';
                ctx.textAlign = 'center';
                const catLabel = item.category.toUpperCase();
                ctx.fillText(catLabel, x + btnW / 2, y + (isMobile ? 14 : 16));

                // Item name
                ctx.fillStyle = owned ? '#2ecc71' : (canAfford ? '#fff' : '#666');
                ctx.font = isMobile ? '11px monospace' : '13px monospace';
                ctx.fillText(name, x + btnW / 2, y + (isMobile ? 30 : 34));

                // Description
                ctx.fillStyle = '#888';
                ctx.font = isMobile ? '8px monospace' : '10px monospace';
                ctx.fillText(desc, x + btnW / 2, y + (isMobile ? 44 : 50));

                // Price or status
                if (owned) {
                    ctx.fillStyle = '#2ecc71';
                    ctx.fillText('OWNED', x + btnW / 2, y + (isMobile ? 58 : 66));
                } else if (cantUse) {
                    ctx.fillStyle = '#e74c3c';
                    ctx.fillText('MAX CHARMS (3)', x + btnW / 2, y + (isMobile ? 58 : 66));
                } else {
                    ctx.fillStyle = canAfford ? '#95a5a6' : '#e74c3c';
                    ctx.fillText(price + ' Scrap', x + btnW / 2, y + (isMobile ? 58 : 66));
                }
            }

            // Continue button
            const contBtnW = isMobile ? 140 : 160;
            const contBtnH = isMobile ? 40 : 45;
            const contBtnX = canvas.width / 2 - contBtnW / 2;
            const contBtnY = canvas.height - (isMobile ? 60 : 70);
            menuButtons.push({ x: contBtnX, y: contBtnY, w: contBtnW, h: contBtnH, action: 'runshop_continue' });

            ctx.fillStyle = '#27ae60';
            ctx.fillRect(contBtnX, contBtnY, contBtnW, contBtnH);
            ctx.fillStyle = '#2ecc71';
            ctx.fillRect(contBtnX + 3, contBtnY + 3, contBtnW - 6, contBtnH - 6);
            ctx.fillStyle = '#1a1a2e';
            ctx.font = isMobile ? '14px monospace' : '16px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('CONTINUE', contBtnX + contBtnW / 2, contBtnY + (isMobile ? 26 : 30));

            // Current charms display at bottom
            if (playerCharms.length > 0) {
                ctx.fillStyle = '#666';
                ctx.font = isMobile ? '9px monospace' : '11px monospace';
                ctx.fillText('Active Charms:', canvas.width / 2, contBtnY - (isMobile ? 28 : 30));
                const charmText = playerCharms.map(id => CHARMS[id].name).join(', ');
                ctx.fillStyle = '#aaa';
                ctx.font = isMobile ? '8px monospace' : '10px monospace';
                ctx.fillText(charmText, canvas.width / 2, contBtnY - (isMobile ? 16 : 16));
            }

            ctx.textAlign = 'left';
        }

        // Handle run shop purchases
        function handleRunShopClick(clickX, clickY) {
            for (const btn of menuButtons) {
                if (clickX >= btn.x && clickX <= btn.x + btn.w &&
                    clickY >= btn.y && clickY <= btn.y + btn.h) {
                    if (btn.action === 'runshop_continue') {
                        // Continue to next room
                        generateLevel(currentLevel);
                        gameState = 'playing';
                        return true;
                    }
                    if (btn.shopIndex !== undefined) {
                        const item = runShopInventory[btn.shopIndex];
                        if (!item) return true;

                        if (item.category === 'armor') {
                            if (playerArmorTier < item.data.tier && scrap >= item.data.price) {
                                scrap -= item.data.price;
                                playerArmorTier = item.data.tier;
                                playerArmor = item.data.dr;
                            }
                        } else if (item.category === 'weapon') {
                            if (player.weapon !== item.data.weapon && scrap >= item.data.price) {
                                scrap -= item.data.price;
                                player.weapon = item.data.weapon;
                                const newWeapon = WEAPONS[item.data.weapon];
                                if (newWeapon.melee) {
                                    player.maxAmmo = 0;
                                    player.ammo = 0;
                                } else {
                                    player.maxAmmo = newWeapon.maxAmmo;
                                    player.ammo = player.maxAmmo;
                                }
                                player.reloading = false;
                                applyPassiveCharms();
                            }
                        } else if (item.category === 'charm') {
                            if (!playerCharms.includes(item.data.id) &&
                                playerCharms.length < 3 &&
                                scrap >= item.data.price) {
                                scrap -= item.data.price;
                                playerCharms.push(item.data.id);
                                applyPassiveCharms();
                                // Heal up to new max if thick_skin just bought
                                if (item.data.id === 'thick_skin') {
                                    player.health = Math.min(player.health + 25, player.maxHealth);
                                }
                            }
                        }
                        return true;
                    }
                }
            }
            return false;
        }

        // Generate level
        function generateLevel(levelNum) {
            walls = [];
            enemies = [];
            pickups = [];
            bullets = [];
            particles = [];
            enemyAlerted = false;
            Music.setDrums(false);
            bombs = [];

            // Set player spawn based on device
            if (isMobile) {
                player.x = W / 2;
                player.y = H - 50;
            } else {
                player.x = W - 90;
                player.y = H - 50;
            }
            // Only reset health on first level, keep HP between rooms
            if (levelNum === 1) {
                player.health = player.maxHealth;
            }
            player.ammo = player.maxAmmo;

            // Set safe zone at spawn
            safeZone.x = player.x;
            safeZone.y = player.y;
            safeZone.radius = 50;

            // Outer walls - use W and H
            walls.push({ x: 0, y: 0, w: W, h: 20 });
            walls.push({ x: 0, y: H - 20, w: W, h: 20 });
            walls.push({ x: 0, y: 0, w: 20, h: H });
            walls.push({ x: W - 20, y: 0, w: 20, h: H });

            // Room dividers based on level and device
            let roomConfigs;

            if (isMobile) {
                // Mobile layouts (360x640)
                roomConfigs = [
                    // 0 - Simple horizontal splits
                    [
                        { x: 0, y: 150, w: 200, h: 20 },
                        { x: 160, y: 280, w: 200, h: 20 },
                        { x: 0, y: 410, w: 200, h: 20 },
                        { x: 160, y: 540, w: 200, h: 20 },
                    ],
                    // 1 - Cross corridors
                    [
                        { x: 120, y: 0, w: 20, h: 120 },
                        { x: 220, y: 80, w: 20, h: 120 },
                        { x: 0, y: 200, w: 150, h: 20 },
                        { x: 210, y: 200, w: 150, h: 20 },
                        { x: 120, y: 280, w: 20, h: 120 },
                        { x: 0, y: 400, w: 250, h: 20 },
                        { x: 180, y: 480, w: 20, h: 100 },
                        { x: 80, y: 560, w: 200, h: 20 },
                    ],
                    // 2 - Dense maze
                    [
                        { x: 80, y: 60, w: 20, h: 100 },
                        { x: 180, y: 0, w: 20, h: 120 },
                        { x: 260, y: 80, w: 20, h: 100 },
                        { x: 0, y: 160, w: 120, h: 20 },
                        { x: 180, y: 160, w: 180, h: 20 },
                        { x: 120, y: 220, w: 20, h: 100 },
                        { x: 60, y: 320, w: 200, h: 20 },
                        { x: 220, y: 380, w: 20, h: 100 },
                        { x: 0, y: 440, w: 180, h: 20 },
                        { x: 80, y: 500, w: 20, h: 80 },
                        { x: 160, y: 540, w: 120, h: 20 },
                    ],
                    // 3 - Arena with pillars
                    [
                        { x: 80, y: 150, w: 40, h: 40 },
                        { x: 240, y: 150, w: 40, h: 40 },
                        { x: 80, y: 350, w: 40, h: 40 },
                        { x: 240, y: 350, w: 40, h: 40 },
                        { x: 160, y: 250, w: 40, h: 40 },
                        { x: 0, y: 480, w: 140, h: 20 },
                        { x: 220, y: 480, w: 140, h: 20 },
                    ],
                    // 4 - Winding path
                    [
                        { x: 0, y: 100, w: 240, h: 20 },
                        { x: 240, y: 100, w: 20, h: 120 },
                        { x: 100, y: 220, w: 160, h: 20 },
                        { x: 100, y: 220, w: 20, h: 120 },
                        { x: 100, y: 340, w: 200, h: 20 },
                        { x: 280, y: 340, w: 20, h: 120 },
                        { x: 60, y: 460, w: 240, h: 20 },
                    ],
                    // 5 - Central chamber
                    [
                        { x: 100, y: 0, w: 20, h: 200 },
                        { x: 240, y: 0, w: 20, h: 200 },
                        { x: 100, y: 200, w: 20, h: 20 },
                        { x: 240, y: 200, w: 20, h: 20 },
                        { x: 0, y: 200, w: 100, h: 20 },
                        { x: 260, y: 200, w: 100, h: 20 },
                        { x: 100, y: 400, w: 20, h: 20 },
                        { x: 240, y: 400, w: 20, h: 20 },
                        { x: 100, y: 420, w: 20, h: 160 },
                        { x: 240, y: 420, w: 20, h: 160 },
                        { x: 0, y: 400, w: 100, h: 20 },
                        { x: 260, y: 400, w: 100, h: 20 },
                    ],
                    // 6 - L-shaped rooms
                    [
                        { x: 180, y: 0, w: 20, h: 160 },
                        { x: 0, y: 160, w: 130, h: 20 },
                        { x: 100, y: 180, w: 20, h: 80 },
                        { x: 0, y: 320, w: 120, h: 20 },
                        { x: 200, y: 260, w: 20, h: 140 },
                        { x: 200, y: 400, w: 160, h: 20 },
                        { x: 120, y: 460, w: 20, h: 120 },
                        { x: 0, y: 520, w: 120, h: 20 },
                    ],
                    // 7 - Scattered blocks
                    [
                        { x: 60, y: 80, w: 60, h: 20 },
                        { x: 200, y: 60, w: 20, h: 80 },
                        { x: 260, y: 140, w: 60, h: 20 },
                        { x: 40, y: 220, w: 20, h: 80 },
                        { x: 140, y: 200, w: 80, h: 20 },
                        { x: 280, y: 280, w: 20, h: 80 },
                        { x: 80, y: 360, w: 60, h: 20 },
                        { x: 200, y: 380, w: 20, h: 80 },
                        { x: 100, y: 480, w: 80, h: 20 },
                        { x: 240, y: 520, w: 60, h: 20 },
                    ],
                ];
            } else {
                // Desktop layouts (640x480)
                roomConfigs = [
                    // 0 - Two vertical dividers
                    [
                        { x: 200, y: 0, w: 20, h: 150 },
                        { x: 200, y: 200, w: 20, h: 280 },
                        { x: 420, y: 0, w: 20, h: 280 },
                        { x: 420, y: 330, w: 20, h: 150 },
                        { x: 200, y: 300, w: 150, h: 20 },
                    ],
                    // 1 - Grid rooms
                    [
                        { x: 150, y: 0, w: 20, h: 200 },
                        { x: 150, y: 250, w: 20, h: 180 },
                        { x: 300, y: 100, w: 20, h: 150 },
                        { x: 300, y: 300, w: 20, h: 120 },
                        { x: 470, y: 0, w: 20, h: 150 },
                        { x: 470, y: 200, w: 20, h: 200 },
                        { x: 150, y: 200, w: 100, h: 20 },
                        { x: 370, y: 250, w: 100, h: 20 },
                    ],
                    // 2 - Dense maze
                    [
                        { x: 100, y: 80, w: 200, h: 20 },
                        { x: 100, y: 80, w: 20, h: 150 },
                        { x: 340, y: 0, w: 20, h: 180 },
                        { x: 340, y: 230, w: 20, h: 100 },
                        { x: 200, y: 200, w: 160, h: 20 },
                        { x: 500, y: 100, w: 20, h: 200 },
                        { x: 400, y: 300, w: 120, h: 20 },
                        { x: 100, y: 350, w: 20, h: 130 },
                        { x: 100, y: 350, w: 200, h: 20 },
                        { x: 280, y: 350, w: 20, h: 80 },
                        { x: 450, y: 380, w: 20, h: 100 },
                    ],
                    // 3 - Arena with pillars
                    [
                        { x: 140, y: 100, w: 40, h: 40 },
                        { x: 460, y: 100, w: 40, h: 40 },
                        { x: 140, y: 340, w: 40, h: 40 },
                        { x: 460, y: 340, w: 40, h: 40 },
                        { x: 300, y: 200, w: 40, h: 40 },
                    ],
                    // 4 - Winding corridors
                    [
                        { x: 0, y: 100, w: 400, h: 20 },
                        { x: 400, y: 100, w: 20, h: 120 },
                        { x: 200, y: 220, w: 220, h: 20 },
                        { x: 200, y: 220, w: 20, h: 100 },
                        { x: 200, y: 320, w: 320, h: 20 },
                        { x: 100, y: 380, w: 20, h: 100 },
                        { x: 100, y: 380, w: 300, h: 20 },
                    ],
                    // 5 - Central chamber
                    [
                        { x: 180, y: 0, w: 20, h: 120 },
                        { x: 440, y: 0, w: 20, h: 120 },
                        { x: 180, y: 120, w: 280, h: 20 },
                        { x: 180, y: 340, w: 280, h: 20 },
                        { x: 180, y: 360, w: 20, h: 120 },
                        { x: 440, y: 360, w: 20, h: 120 },
                        { x: 280, y: 120, w: 20, h: 40 },
                        { x: 340, y: 320, w: 20, h: 40 },
                    ],
                    // 6 - L-rooms and corridors
                    [
                        { x: 200, y: 0, w: 20, h: 80 },
                        { x: 200, y: 130, w: 20, h: 70 },
                        { x: 0, y: 200, w: 220, h: 20 },
                        { x: 350, y: 100, w: 20, h: 200 },
                        { x: 350, y: 100, w: 150, h: 20 },
                        { x: 100, y: 300, w: 20, h: 180 },
                        { x: 100, y: 300, w: 200, h: 20 },
                        { x: 450, y: 250, w: 20, h: 130 },
                        { x: 350, y: 380, w: 120, h: 20 },
                        { x: 500, y: 380, w: 20, h: 100 },
                    ],
                    // 7 - Scattered blocks
                    [
                        { x: 100, y: 60, w: 80, h: 20 },
                        { x: 300, y: 40, w: 20, h: 80 },
                        { x: 450, y: 80, w: 80, h: 20 },
                        { x: 60, y: 180, w: 20, h: 80 },
                        { x: 200, y: 160, w: 100, h: 20 },
                        { x: 400, y: 200, w: 20, h: 80 },
                        { x: 530, y: 180, w: 20, h: 80 },
                        { x: 120, y: 300, w: 80, h: 20 },
                        { x: 280, y: 280, w: 20, h: 80 },
                        { x: 450, y: 340, w: 80, h: 20 },
                        { x: 160, y: 400, w: 100, h: 20 },
                        { x: 360, y: 420, w: 20, h: 60 },
                    ],
                    // 8 - Ring layout
                    [
                        { x: 160, y: 80, w: 320, h: 20 },
                        { x: 160, y: 80, w: 20, h: 130 },
                        { x: 460, y: 80, w: 20, h: 130 },
                        { x: 160, y: 280, w: 20, h: 130 },
                        { x: 460, y: 280, w: 20, h: 130 },
                        { x: 160, y: 390, w: 320, h: 20 },
                        { x: 280, y: 180, w: 80, h: 20 },
                        { x: 280, y: 290, w: 80, h: 20 },
                    ],
                    // 9 - Diagonal feel
                    [
                        { x: 80, y: 0, w: 20, h: 120 },
                        { x: 80, y: 100, w: 120, h: 20 },
                        { x: 200, y: 100, w: 20, h: 100 },
                        { x: 200, y: 200, w: 140, h: 20 },
                        { x: 320, y: 200, w: 20, h: 100 },
                        { x: 320, y: 300, w: 160, h: 20 },
                        { x: 460, y: 300, w: 20, h: 100 },
                        { x: 200, y: 360, w: 260, h: 20 },
                        { x: 100, y: 400, w: 20, h: 80 },
                    ],
                ];
            }

            // Get dungeon difficulty settings
            const dungeonSettings = DUNGEONS[selectedDungeon] || DUNGEONS.dungeon;

            // Check if this is a boss level
            const bossInterval = Math.max(5, Math.floor(10 / (dungeonSettings.difficulty || 1)));
            const isBossLevel = levelNum % bossInterval === 0;

            // Clear boss state
            bossWarningZones = [];
            G.bossWarningZones = bossWarningZones;
            activeBoss = null;

            // Scale factor to stretch layouts from original design height to expanded world
            const yScale = H / BASE_H;

            // Pick layout: boss levels use special arena, otherwise rotate through configs
            if (isBossLevel) {
                // Boss arena - open space with corner pillars for cover
                if (isMobile) {
                    walls.push(
                        { x: 60, y: Math.round(100 * yScale), w: 40, h: 40 },
                        { x: 260, y: Math.round(100 * yScale), w: 40, h: 40 },
                        { x: 60, y: Math.round(450 * yScale), w: 40, h: 40 },
                        { x: 260, y: Math.round(450 * yScale), w: 40, h: 40 },
                        { x: 150, y: Math.round(270 * yScale), w: 60, h: 60 }
                    );
                } else {
                    walls.push(
                        { x: 80, y: Math.round(80 * yScale), w: 50, h: 50 },
                        { x: 510, y: Math.round(80 * yScale), w: 50, h: 50 },
                        { x: 80, y: Math.round(350 * yScale), w: 50, h: 50 },
                        { x: 510, y: Math.round(350 * yScale), w: 50, h: 50 },
                        { x: 295, y: Math.round(200 * yScale), w: 50, h: 80 }
                    );
                }
            } else {
                let configIndex;
                if (levelNum <= 1) {
                    configIndex = 0;
                } else {
                    // Deterministic but varied selection based on level
                    configIndex = ((levelNum - 1) * 3 + levelNum) % roomConfigs.length;
                }
                // Scale Y positions of room layouts to fill expanded world
                for (const wall of roomConfigs[configIndex]) {
                    walls.push({ x: wall.x, y: Math.round(wall.y * yScale), w: wall.w, h: wall.h });
                }
            }

            // Sync walls to G so pointInWalls sees current level's walls
            G.walls = walls;

            const countMult = dungeonSettings.enemyCountMult || 1;
            const healthMult = dungeonSettings.enemyHealthMult || 1;
            const speedMult = dungeonSettings.enemySpeedMult || 1;

            // Build reachability map using flood-fill from player spawn
            const gridSize = 10; // Smaller grid for better accuracy
            const gridW = Math.ceil(W / gridSize);
            const gridH = Math.ceil(H / gridSize);
            const reachable = new Array(gridW * gridH).fill(false);

            // Mark cells reachable from player spawn using BFS
            const startGX = Math.floor(player.x / gridSize);
            const startGY = Math.floor(player.y / gridSize);
            const queue = [[startGX, startGY]];
            const visited = new Set();
            visited.add(startGX + ',' + startGY);

            while (queue.length > 0) {
                const [gx, gy] = queue.shift();
                const idx = gy * gridW + gx;
                const worldX = gx * gridSize + gridSize / 2;
                const worldY = gy * gridSize + gridSize / 2;

                // Check if this cell is walkable
                if (!pointInWalls(worldX, worldY, gridSize, gridSize)) {
                    reachable[idx] = true;

                    // Add cardinal neighbors only (no diagonals - prevents leaking through wall corners)
                    const neighbors = [
                        [gx-1, gy], [gx+1, gy], [gx, gy-1], [gx, gy+1]
                    ];
                    for (const [nx, ny] of neighbors) {
                        if (nx >= 0 && nx < gridW && ny >= 0 && ny < gridH) {
                            const key = nx + ',' + ny;
                            if (!visited.has(key)) {
                                visited.add(key);
                                queue.push([nx, ny]);
                            }
                        }
                    }
                }
            }

            // Helper to check if a world position is reachable
            function isReachable(x, y) {
                const gx = Math.floor(x / gridSize);
                const gy = Math.floor(y / gridSize);
                if (gx < 0 || gx >= gridW || gy < 0 || gy >= gridH) return false;
                return reachable[gy * gridW + gx];
            }

            // Spawn enemies - find valid positions not in walls
            const baseCount = 3 + levelNum * 2;
            const enemyCount = Math.floor(baseCount * countMult);
            let spawned = 0;
            let attempts = 0;

            while (spawned < enemyCount && attempts < 500) {
                attempts++;
                // Try random position in playable area
                const x = 40 + Math.random() * (W - 80);
                const y = 40 + Math.random() * (H - 120);

                // Pick enemy type based on level
                let type = 'grunt';
                const roll = Math.random();
                if (levelNum >= 4 && roll < 0.15) {
                    type = 'sniper';
                } else if (levelNum >= 3 && roll < 0.25) {
                    type = 'tank';
                } else if (levelNum >= 2 && roll < 0.4) {
                    type = 'charger';
                }
                const enemyType = ENEMY_TYPES[type];

                // Check not in wall, not too close to player spawn, and reachable via pathfinding
                const distToPlayer = Math.hypot(x - player.x, y - player.y);
                const enemyCheckSize = enemyType.size + 24; // Large padding to avoid spawning in/near walls
                if (!pointInWalls(x, y, enemyCheckSize, enemyCheckSize) && distToPlayer > 100 && isReachable(x, y)) {
                    const baseHealth = enemyType.health + levelNum * 5;
                    enemies.push({
                        x: x,
                        y: y,
                        type: type,
                        width: enemyType.size,
                        height: enemyType.size,
                        speed: (enemyType.speed + levelNum * 0.1) * speedMult,
                        health: Math.floor(baseHealth * healthMult),
                        maxHealth: Math.floor(baseHealth * healthMult),
                        shootCooldown: 0,
                        alertDistance: 180 + levelNum * 15,
                        shootDistance: enemyType.shootDist,
                        canShoot: enemyType.canShoot
                    });
                    spawned++;
                }
            }

            // Spawn boss on boss levels
            if (isBossLevel) {
                const bossType = ENEMY_TYPES.boss;
                const bossHealth = Math.floor((bossType.health + levelNum * 20) * healthMult);
                // Spawn boss in center-ish area on boss levels
                const bx = isMobile ? W / 2 : W / 2;
                const by = isMobile ? 180 : 150;
                const boss = {
                    x: bx,
                    y: by,
                    type: 'boss',
                    width: bossType.size,
                    height: bossType.size,
                    speed: bossType.speed * speedMult,
                    health: bossHealth,
                    maxHealth: bossHealth,
                    shootCooldown: 0,
                    alertDistance: 600,
                    shootDistance: bossType.shootDist,
                    canShoot: bossType.canShoot,
                    // Boss special attack properties
                    specialAttackCooldown: 120,
                    specialAttackTimer: 0,
                    attackPhase: 'idle', // 'idle', 'warning', 'attacking'
                    attackType: null
                };
                enemies.push(boss);
                activeBoss = boss;
            }

            // Spawn pickups at valid positions (more on easier difficulties)
            const pickupChance = dungeonSettings.pickupChance || 0.4;
            const numHealthPacks = Math.random() < pickupChance ? 2 : 1;
            for (let h = 0; h < numHealthPacks; h++) {
                for (let i = 0; i < 50; i++) {
                    const hx = 40 + Math.random() * (W - 80);
                    const hy = 40 + Math.random() * (H - 80);
                    if (!pointInWalls(hx, hy, 12, 12)) {
                        pickups.push({ x: hx, y: hy, type: 'health', width: 12, height: 12 });
                        break;
                    }
                }
            }
            const numAmmoPacks = Math.random() < pickupChance ? 2 : 1;
            for (let a = 0; a < numAmmoPacks; a++) {
                for (let i = 0; i < 50; i++) {
                    const ax = 40 + Math.random() * (W - 80);
                    const ay = 40 + Math.random() * (H - 80);
                    if (!pointInWalls(ax, ay, 12, 12)) {
                        pickups.push({ x: ax, y: ay, type: 'ammo', width: 12, height: 12 });
                        break;
                    }
                }
            }

            // Chance to spawn 1 random weapon on the ground (higher on easier difficulties)
            if (Math.random() < pickupChance) {
                const available = [];
                if (levelNum >= 1) available.push('smg');
                if (levelNum >= 2) available.push('shotgun', 'rifle');
                if (levelNum >= 3) available.push('railgun');
                if (levelNum >= 4) available.push('minigun');
                // Melee weapons have lower spawn rate (25% chance)
                if (levelNum >= 2 && Math.random() < 0.25) available.push('sword');
                if (levelNum >= 3 && Math.random() < 0.25) available.push('katana');
                // Rare weapons have 15% spawn rate
                if (levelNum >= 3 && Math.random() < 0.15) available.push('sniper');
                if (levelNum >= 4 && Math.random() < 0.15) available.push('flamethrower');
                if (levelNum >= 5 && Math.random() < 0.15) available.push('rocketlauncher');
                // Super rare bomb (5% spawn rate)
                if (levelNum >= 4 && Math.random() < 0.05) available.push('bomb');
                if (available.length > 0) {
                    const weaponType = available[Math.floor(Math.random() * available.length)];
                    for (let i = 0; i < 100; i++) {
                        const wx = 50 + Math.random() * (W - 100);
                        const wy = 50 + Math.random() * (H - 100);
                        const distToSpawn = Math.hypot(wx - player.x, wy - player.y);
                        if (!pointInWalls(wx, wy, 16, 16) && distToSpawn > 80) {
                            pickups.push({ x: wx, y: wy, type: weaponType, width: 16, height: 16 });
                            break;
                        }
                    }
                }
            }

            // Spawn coins (2-4 per level, more on higher levels)
            const numCoins = 2 + Math.floor(Math.random() * 2) + Math.floor(levelNum / 3);
            for (let c = 0; c < numCoins; c++) {
                for (let i = 0; i < 50; i++) {
                    const cx = 40 + Math.random() * (W - 80);
                    const cy = 40 + Math.random() * (H - 80);
                    const distToSpawn = Math.hypot(cx - player.x, cy - player.y);
                    if (!pointInWalls(cx, cy, 10, 10) && distToSpawn > 60) {
                        pickups.push({ x: cx, y: cy, type: 'coin', width: 10, height: 10, value: 1 });
                        break;
                    }
                }
            }

            // Generate floor decorations (pre-computed for performance)
            floorDecorations = [];
            const numDecos = isMobile ? 40 : 70;
            for (let d = 0; d < numDecos; d++) {
                const dx = 30 + Math.random() * (W - 60);
                const dy = 30 + Math.random() * (H - 60);
                if (!pointInWalls(dx, dy, 4, 4) && isReachable(dx, dy)) {
                    const variant = Math.floor(Math.random() * 6);
                    const size = 2 + Math.floor(Math.random() * 5);
                    floorDecorations.push({ x: dx, y: dy, variant: variant, size: size });
                }
            }

            // Generate large props (trees, pillars, stalagmites, etc.)
            levelProps = [];
            const numProps = isMobile ? 5 : 8;
            for (let p = 0; p < numProps; p++) {
                for (let attempt = 0; attempt < 30; attempt++) {
                    const px = 50 + Math.random() * (W - 100);
                    const py = 50 + Math.random() * (H - 100);
                    const propSize = 8 + Math.floor(Math.random() * 10);
                    // Must not be in walls (with padding), not near player spawn, reachable, not overlapping other props
                    const distToSpawn = Math.hypot(px - player.x, py - player.y);
                    const checkSize = propSize * 2 + 10; // Extra padding to avoid wall overlap
                    if (!pointInWalls(px, py, checkSize, checkSize) && distToSpawn > 70 && isReachable(px, py)) {
                        let overlap = false;
                        for (const existing of levelProps) {
                            if (Math.hypot(px - existing.x, py - existing.y) < 40) {
                                overlap = true;
                                break;
                            }
                        }
                        if (!overlap) {
                            const propVariant = Math.floor(Math.random() * 4);
                            levelProps.push({ x: px, y: py, variant: propVariant, size: propSize });
                            break;
                        }
                    }
                }
            }

            // Jungle: also generate grass patches (lots of them)
            if (selectedDungeon === 'jungle') {
                const numGrass = isMobile ? 30 : 50;
                for (let g = 0; g < numGrass; g++) {
                    const gx = 25 + Math.random() * (W - 50);
                    const gy = 25 + Math.random() * (H - 50);
                    if (!pointInWalls(gx, gy, 6, 6)) {
                        floorDecorations.push({ x: gx, y: gy, variant: 10, size: 3 + Math.floor(Math.random() * 4) }); // variant 10 = grass
                    }
                }
            }

            // Boss arena: add special decorations (skull pattern in center, torches near pillars)
            if (isBossLevel) {
                // Central skull decoration (variant 20 = boss arena skull)
                floorDecorations.push({ x: W / 2, y: H / 2 - 20, variant: 20, size: isMobile ? 40 : 60 });
                // Corner torch decorations (variant 21 = boss arena torch)
                if (isMobile) {
                    floorDecorations.push({ x: 80, y: 120, variant: 21, size: 12 });
                    floorDecorations.push({ x: 280, y: 120, variant: 21, size: 12 });
                    floorDecorations.push({ x: 80, y: 470, variant: 21, size: 12 });
                    floorDecorations.push({ x: 280, y: 470, variant: 21, size: 12 });
                } else {
                    floorDecorations.push({ x: 105, y: 100, variant: 21, size: 14 });
                    floorDecorations.push({ x: 535, y: 100, variant: 21, size: 14 });
                    floorDecorations.push({ x: 105, y: 370, variant: 21, size: 14 });
                    floorDecorations.push({ x: 535, y: 370, variant: 21, size: 14 });
                }
            }

            // Collect environmental light sources for the lighting overlay
            levelLights = [];

            // Wall torches (dungeon theme only  same logic as wall-decorations.js)
            if (selectedDungeon === 'dungeon') {
                for (const wall of walls) {
                    const wx = Math.floor(wall.x);
                    const wy = Math.floor(wall.y);
                    const ww = wall.w;
                    const wh = wall.h;
                    const isHoriz = wh <= 20;
                    const isVert = ww <= 20;
                    if (isHoriz && ww > 50) {
                        for (let tx = wx + 25; tx < wx + ww - 20; tx += 50 + ((tx + wy) % 18)) {
                            levelLights.push({ x: tx, y: wy - 6, radius: 22, intensity: 0.8 });
                        }
                    } else if (isVert && wh > 40) {
                        for (let ty = wy + 18; ty < wy + wh - 18; ty += 45 + ((wx + ty) % 16)) {
                            levelLights.push({ x: wx + ww + 3, y: ty, radius: 22, intensity: 0.8 });
                        }
                    }
                }
            }

            // Boss arena torches (variant 21 floor decorations)
            if (isBossLevel) {
                for (const d of floorDecorations) {
                    if (d.variant === 21) {
                        levelLights.push({ x: d.x, y: d.y - 4, radius: 18, intensity: 0.7 });
                    }
                }
            }

            // Volcano: lava pools, embers, and lava cracks in floor decorations
            if (selectedDungeon === 'volcano') {
                for (const d of floorDecorations) {
                    if (d.variant === 0) {
                        // Lava crack  faint glow
                        levelLights.push({ x: d.x, y: d.y, radius: 12, intensity: 0.5 });
                    } else if (d.variant === 2) {
                        // Small lava pool
                        levelLights.push({ x: d.x, y: d.y, radius: 25, intensity: 0.7 });
                    } else if (d.variant >= 5) {
                        // Glowing ember
                        levelLights.push({ x: d.x, y: d.y, radius: 10, intensity: 0.5 });
                    }
                }
                // Large lava pools and obsidian spikes from level props
                for (const p of levelProps) {
                    if (p.variant === 0) {
                        // Obsidian spike with red glow at base
                        levelLights.push({ x: p.x, y: p.y + 2, radius: 15, intensity: 0.5 });
                    } else if (p.variant === 1) {
                        // Large lava pool
                        levelLights.push({ x: p.x, y: p.y, radius: 35, intensity: 0.8 });
                    }
                }
                // Glowing wall cracks
                for (const wall of walls) {
                    const wx = Math.floor(wall.x);
                    const wy = Math.floor(wall.y);
                    const ww = wall.w;
                    const wh = wall.h;
                    const isHoriz = wh <= 20;
                    if (isHoriz && ww > 20) {
                        for (let cx = wx + 6; cx < wx + ww - 8; cx += 12 + ((cx + wy) % 8)) {
                            levelLights.push({ x: cx + 4, y: wy + 4, radius: 14, intensity: 0.5 });
                        }
                    }
                }
            }
        }

        // Update player
        function updatePlayer() {
            if (gameState !== 'playing' && gameState !== 'multiplayer-playing') return;

            // Regen Aura charm: heal 1 HP every 3 seconds (180 ticks at 60fps)
            if (playerCharms.includes('regen_aura')) {
                regenTimer++;
                if (regenTimer >= 180) {
                    regenTimer = 0;
                    player.health = Math.min(player.health + 1, player.maxHealth);
                }
            }

            let newX = player.x;
            let newY = player.y;

            // Keyboard controls
            if (keys['w'] || keys['W']) newY -= player.speed;
            if (keys['s'] || keys['S']) newY += player.speed;
            if (keys['a'] || keys['A']) newX -= player.speed;
            if (keys['d'] || keys['D']) newX += player.speed;

            // Touch controls (mobile)
            if (isMobile) {
                newX += touchMove.x * player.speed * 2;
                newY += touchMove.y * player.speed * 2;
            }

            // Check wall collisions
            if (!pointInWalls(newX, player.y, player.width, player.height)) {
                player.x = newX;
            }
            if (!pointInWalls(player.x, newY, player.width, player.height)) {
                player.y = newY;
            }

            // Disable safe zone once player leaves it
            if (safeZone.radius > 0 && Math.hypot(player.x - safeZone.x, player.y - safeZone.y) >= safeZone.radius) {
                safeZone.radius = 0;
            }

            // Aim angle (reverse-map screen mouseY to world space for isometric)
            const aimY = mouseY / ISO_SCALE;
            player.angle = Math.atan2(aimY - player.y, mouseX - player.x);

            // Shooting / Melee
            if (player.shootCooldown > 0) player.shootCooldown--;

            // Update swing animation
            if (player.swinging) {
                player.swingProgress += 1 / WEAPONS[player.weapon].fireRate;
                if (player.swingProgress >= 1) {
                    player.swinging = false;
                    player.swingProgress = 0;
                }
            }

            const weapon = WEAPONS[player.weapon];
            if (weapon.melee) {
                // Melee weapon attack
                if (mouseDown && player.shootCooldown === 0 && !player.swinging) {
                    meleeAttack();
                    SFX.weapon(player.weapon);
                    player.swinging = true;
                    player.swingProgress = 0;
                    player.shootCooldown = weapon.fireRate;
                }
            } else if (mouseDown && player.ammo >= weapon.ammoUse && player.shootCooldown === 0 && !player.reloading) {
                // Check if in safe zone (can't shoot from there)
                const inSafeZone = Math.hypot(player.x - safeZone.x, player.y - safeZone.y) < safeZone.radius;
                if (!inSafeZone) {
                    SFX.weapon(player.weapon);
                    if (player.weapon === 'shotgun') {
                        for (let i = 0; i < weapon.pellets; i++) {
                            const spread = (Math.random() - 0.5) * 0.4;
                            shoot(player.x, player.y, player.angle + spread, true);
                        }
                    } else if (player.weapon === 'flamethrower') {
                        shootFlame(player.x, player.y, player.angle);
                    } else if (player.weapon === 'rocketlauncher') {
                        shootRocket(player.x, player.y, player.angle);
                    } else if (player.weapon === 'bomb') {
                        placeBomb(player.x, player.y);
                    } else if (player.weapon === 'sniper') {
                        shoot(player.x, player.y, player.angle, true, false);
                    } else {
                        shoot(player.x, player.y, player.angle, true, player.weapon === 'railgun');
                    }
                    player.ammo -= weapon.ammoUse;
                    player.shootCooldown = weapon.fireRate;
                }
            }

            // Reloading
            if (player.reloading) {
                player.reloadTime--;
                if (player.reloadTime <= 0) {
                    player.ammo = player.maxAmmo;
                    player.reloading = false;
                }
            }

            // Auto-reload when empty, or manual reload with R (not for melee or placeable weapons)
            if (!weapon.melee && !weapon.placeable && !player.reloading && (player.ammo === 0 || keys['r'] || keys['R'])) {
                if (player.ammo < player.maxAmmo) {
                    player.reloading = true;
                    player.reloadTime = 60;
                }
            }

            // Check pickup collisions
            for (let i = pickups.length - 1; i >= 0; i--) {
                const p = pickups[i];
                const dist = Math.hypot(player.x - p.x, player.y - p.y);
                // Check distance and line of sight (can't pick up through walls)
                if (dist < 20 && !lineOfSightBlocked(player.x, player.y, p.x, p.y)) {
                    if (p.type === 'health') {
                        player.health = Math.min(player.health + 50, player.maxHealth);
                        SFX.pickup('health');
                        pickups.splice(i, 1);
                    } else if (p.type === 'ammo') {
                        // Ammo only works for ranged weapons
                        const currentWeapon = WEAPONS[player.weapon];
                        if (!currentWeapon.melee) {
                            player.ammo = Math.min(player.ammo + 15, player.maxAmmo);
                            SFX.pickup('ammo');
                            pickups.splice(i, 1);
                        }
                    } else if (p.type === 'scrap') {
                        // Collect scrap (run currency)
                        scrap += p.value || 1;
                        // Scrap particles
                        for (let j = 0; j < 3; j++) {
                            particles.push({
                                x: p.x, y: p.y,
                                vx: (Math.random() - 0.5) * 2,
                                vy: (Math.random() - 0.5) * 2,
                                life: 15,
                                color: '#95a5a6'
                            });
                        }
                        SFX.pickup('scrap');
                        pickups.splice(i, 1);
                    } else if (p.type === 'coin') {
                        // Collect coin
                        coins += p.value || 1;
                        saveProgress();
                        // Coin particles
                        for (let j = 0; j < 5; j++) {
                            particles.push({
                                x: p.x,
                                y: p.y,
                                vx: (Math.random() - 0.5) * 3,
                                vy: (Math.random() - 0.5) * 3,
                                life: 20,
                                color: '#ffd700'
                            });
                        }
                        SFX.pickup('coin');
                        pickups.splice(i, 1);
                    } else if (WEAPONS[p.type] && p.type !== player.weapon) {
                        // Drop current weapon if not pistol
                        const oldWeapon = player.weapon;
                        player.weapon = p.type;
                        const newWeapon = WEAPONS[p.type];
                        if (newWeapon.melee) {
                            // Melee weapons don't use ammo
                            player.maxAmmo = 0;
                            player.ammo = 0;
                        } else {
                            let baseMax = newWeapon.maxAmmo;
                            if (playerCharms.includes('big_magazines')) {
                                baseMax = Math.floor(baseMax * 1.5);
                            }
                            player.maxAmmo = baseMax;
                            player.ammo = player.maxAmmo;
                        }
                        // Stop any ongoing reload
                        player.reloading = false;
                        if (oldWeapon !== 'pistol') {
                            pickups.push({
                                x: p.x,
                                y: p.y,
                                type: oldWeapon,
                                width: 16,
                                height: 16
                            });
                        }
                        SFX.pickup('weapon');
                        pickups.splice(i, 1);
                    }
                }
            }

            // Update UI
            document.getElementById('health').textContent = `Health: ${player.health}`;
            const weaponName = player.weapon.charAt(0).toUpperCase() + player.weapon.slice(1);
            const currentWeapon = WEAPONS[player.weapon];
            if (currentWeapon.melee) {
                document.getElementById('ammo').textContent = `${weaponName}: Ready`;
            } else {
                document.getElementById('ammo').textContent = player.reloading ? 'Reloading...' : `${weaponName}: ${player.ammo}`;
            }
            document.getElementById('score').textContent = `Score: ${score} | $${coins} | S:${scrap}`;
            document.getElementById('level').textContent = `Building: ${currentLevel}`;
        }

        // Shoot bullet
        function shoot(x, y, angle, isPlayer, pierce = false) {
            // Can't shoot from safe zone
            if (isPlayer && Math.hypot(player.x - safeZone.x, player.y - safeZone.y) < safeZone.radius) {
                return;
            }
            const speed = isPlayer ? (pierce ? 12 : 5) : 2.5;
            const weapon = isPlayer ? WEAPONS[player.weapon] : null;
            const damage = weapon ? (weapon.damage || 20) : 10;
            bullets.push({
                x: x,
                y: y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                isPlayer: isPlayer,
                life: 200,
                pierce: pierce,
                damage: pierce ? damage * 2 : damage,
                color: weapon ? weapon.color : COLORS.bullet
            });

            // Muzzle flash particles
            for (let i = 0; i < 3; i++) {
                particles.push({
                    x: x + Math.cos(angle) * 10,
                    y: y + Math.sin(angle) * 10,
                    vx: Math.cos(angle + (Math.random() - 0.5)) * 2,
                    vy: Math.sin(angle + (Math.random() - 0.5)) * 2,
                    life: 10,
                    color: '#ff0'
                });
            }
        }

        // Shoot flame (flamethrower)
        function shootFlame(x, y, angle) {
            // Can't shoot from safe zone
            if (Math.hypot(player.x - safeZone.x, player.y - safeZone.y) < safeZone.radius) {
                return;
            }
            const weapon = WEAPONS.flamethrower;
            const spread = (Math.random() - 0.5) * 0.5;
            const speed = 4 + Math.random() * 2;
            bullets.push({
                x: x + Math.cos(angle) * 15,
                y: y + Math.sin(angle) * 15,
                vx: Math.cos(angle + spread) * speed,
                vy: Math.sin(angle + spread) * speed,
                isPlayer: true,
                life: 25,
                damage: weapon.damage,
                color: '#ff4500',
                flame: true
            });

            // Flame particles
            for (let i = 0; i < 2; i++) {
                particles.push({
                    x: x + Math.cos(angle) * 20,
                    y: y + Math.sin(angle) * 20,
                    vx: Math.cos(angle + (Math.random() - 0.5) * 0.8) * 3,
                    vy: Math.sin(angle + (Math.random() - 0.5) * 0.8) * 3,
                    life: 15,
                    color: Math.random() > 0.5 ? '#ff0' : '#ff6600'
                });
            }
        }

        // Shoot rocket (rocket launcher)
        function shootRocket(x, y, angle) {
            // Can't shoot from safe zone
            if (Math.hypot(player.x - safeZone.x, player.y - safeZone.y) < safeZone.radius) {
                return;
            }
            const weapon = WEAPONS.rocketlauncher;
            bullets.push({
                x: x + Math.cos(angle) * 15,
                y: y + Math.sin(angle) * 15,
                vx: Math.cos(angle) * 4,
                vy: Math.sin(angle) * 4,
                isPlayer: true,
                life: 300,
                damage: weapon.damage,
                color: '#8b0000',
                explosive: true,
                explosionRadius: weapon.explosionRadius
            });

            // Smoke trail at launch
            for (let i = 0; i < 5; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: -Math.cos(angle) * 2 + (Math.random() - 0.5) * 2,
                    vy: -Math.sin(angle) * 2 + (Math.random() - 0.5) * 2,
                    life: 20,
                    color: '#888'
                });
            }
        }

        // Explode rocket
        function explodeRocket(x, y, radius, damage) {
            SFX.explosion();
            // Explosion particles
            for (let i = 0; i < 20; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 5 + 2;
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 25,
                    color: Math.random() > 0.3 ? '#ff4500' : '#ff0'
                });
            }
            // Smoke
            for (let i = 0; i < 10; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 3 + 1;
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 35,
                    color: '#555'
                });
            }

            // Damage all enemies in radius
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                const dist = Math.hypot(enemy.x - x, enemy.y - y);
                if (dist <= radius) {
                    // Damage falls off with distance
                    const damageMultiplier = 1 - (dist / radius) * 0.5;
                    enemy.health -= Math.floor(damage * damageMultiplier);

                    // Knockback
                    const knockAngle = Math.atan2(enemy.y - y, enemy.x - x);
                    const knockbackDist = 20 * (1 - dist / radius);
                    const newX = enemy.x + Math.cos(knockAngle) * knockbackDist;
                    const newY = enemy.y + Math.sin(knockAngle) * knockbackDist;
                    if (!pointInWalls(newX, enemy.y, enemy.width, enemy.height)) {
                        enemy.x = newX;
                    }
                    if (!pointInWalls(enemy.x, newY, enemy.width, enemy.height)) {
                        enemy.y = newY;
                    }

                    // Hit particles
                    for (let k = 0; k < 5; k++) {
                        particles.push({
                            x: enemy.x,
                            y: enemy.y,
                            vx: (Math.random() - 0.5) * 4,
                            vy: (Math.random() - 0.5) * 4,
                            life: 20,
                            color: COLORS.enemy
                        });
                    }

                    if (enemy.health <= 0) {
                        onEnemyKill(enemy);
                        // Death particles
                        for (let k = 0; k < 15; k++) {
                            particles.push({
                                x: enemy.x,
                                y: enemy.y,
                                vx: (Math.random() - 0.5) * 6,
                                vy: (Math.random() - 0.5) * 6,
                                life: 30,
                                color: COLORS.enemy
                            });
                        }
                        enemies.splice(i, 1);
                    }
                }
            }

        }

        // Place bomb
        function placeBomb(x, y) {
            // Can't place in safe zone
            if (Math.hypot(x - safeZone.x, y - safeZone.y) < safeZone.radius) {
                return;
            }
            const weapon = WEAPONS.bomb;
            bombs.push({
                x: x,
                y: y,
                fuseTime: weapon.fuseTime,
                damage: weapon.damage,
                radius: weapon.explosionRadius
            });

            // Place sound effect (particles)
            for (let i = 0; i < 5; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 3,
                    vy: (Math.random() - 0.5) * 3,
                    life: 15,
                    color: '#888'
                });
            }
        }

        // Update bombs
        function updateBombs() {
            for (let i = bombs.length - 1; i >= 0; i--) {
                const bomb = bombs[i];
                bomb.fuseTime--;

                // Sparking particles while fuse burns
                if (bomb.fuseTime % 10 === 0) {
                    particles.push({
                        x: bomb.x,
                        y: bomb.y - 10,
                        vx: (Math.random() - 0.5) * 2,
                        vy: -Math.random() * 2,
                        life: 10,
                        color: Math.random() > 0.5 ? '#ff4500' : '#ff0'
                    });
                }

                // Explode when fuse runs out
                if (bomb.fuseTime <= 0) {
                    explodeBomb(bomb.x, bomb.y, bomb.radius, bomb.damage);
                    bombs.splice(i, 1);
                }
            }
        }

        // Explode bomb
        function explodeBomb(x, y, radius, damage) {
            SFX.explosion();
            // Big explosion particles
            for (let i = 0; i < 30; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 7 + 3;
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 35,
                    color: Math.random() > 0.3 ? '#ff4500' : '#ff0'
                });
            }
            // Lots of smoke
            for (let i = 0; i < 20; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 4 + 1;
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 50,
                    color: '#333'
                });
            }

            // Damage all enemies in radius
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                const dist = Math.hypot(enemy.x - x, enemy.y - y);
                if (dist <= radius) {
                    // Damage falls off with distance
                    const damageMultiplier = 1 - (dist / radius) * 0.5;
                    enemy.health -= Math.floor(damage * damageMultiplier);

                    // Knockback
                    const knockAngle = Math.atan2(enemy.y - y, enemy.x - x);
                    const knockbackDist = 30 * (1 - dist / radius);
                    const newX = enemy.x + Math.cos(knockAngle) * knockbackDist;
                    const newY = enemy.y + Math.sin(knockAngle) * knockbackDist;
                    if (!pointInWalls(newX, enemy.y, enemy.width, enemy.height)) {
                        enemy.x = newX;
                    }
                    if (!pointInWalls(enemy.x, newY, enemy.width, enemy.height)) {
                        enemy.y = newY;
                    }

                    // Hit particles
                    for (let k = 0; k < 8; k++) {
                        particles.push({
                            x: enemy.x,
                            y: enemy.y,
                            vx: (Math.random() - 0.5) * 5,
                            vy: (Math.random() - 0.5) * 5,
                            life: 25,
                            color: COLORS.enemy
                        });
                    }

                    if (enemy.health <= 0) {
                        onEnemyKill(enemy);
                        // Death particles
                        for (let k = 0; k < 15; k++) {
                            particles.push({
                                x: enemy.x,
                                y: enemy.y,
                                vx: (Math.random() - 0.5) * 6,
                                vy: (Math.random() - 0.5) * 6,
                                life: 30,
                                color: COLORS.enemy
                            });
                        }
                        enemies.splice(i, 1);
                    }
                }
            }

        }

        // Melee attack
        function meleeAttack() {
            // Can't attack from safe zone
            if (Math.hypot(player.x - safeZone.x, player.y - safeZone.y) < safeZone.radius) {
                return;
            }

            const weapon = WEAPONS[player.weapon];
            const range = weapon.range;
            const arc = weapon.arc;
            const damage = weapon.damage;

            // Create swing particles
            for (let i = 0; i < 8; i++) {
                const particleAngle = player.angle - arc/2 + (arc * i / 7);
                const dist = range * 0.8;
                particles.push({
                    x: player.x + Math.cos(particleAngle) * dist,
                    y: player.y + Math.sin(particleAngle) * dist,
                    vx: Math.cos(particleAngle) * 2,
                    vy: Math.sin(particleAngle) * 2,
                    life: 15,
                    color: weapon.color
                });
            }

            // Check all enemies within arc range
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                const dist = Math.hypot(enemy.x - player.x, enemy.y - player.y);

                // Check if enemy is within range
                if (dist <= range + enemy.width / 2) {
                    // Check if enemy is within arc
                    const angleToEnemy = Math.atan2(enemy.y - player.y, enemy.x - player.x);
                    let angleDiff = angleToEnemy - player.angle;
                    // Normalize angle difference to -PI to PI
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;

                    if (Math.abs(angleDiff) <= arc / 2) {
                        // Check if wall blocks the attack
                        if (lineOfSightBlocked(player.x, player.y, enemy.x, enemy.y)) {
                            continue;
                        }

                        // Hit enemy
                        enemy.health -= damage;

                        // Knockback for sword
                        if (player.weapon === 'sword') {
                            const knockbackDist = 15;
                            const newX = enemy.x + Math.cos(player.angle) * knockbackDist;
                            const newY = enemy.y + Math.sin(player.angle) * knockbackDist;
                            if (!pointInWalls(newX, enemy.y, enemy.width, enemy.height)) {
                                enemy.x = newX;
                            }
                            if (!pointInWalls(enemy.x, newY, enemy.width, enemy.height)) {
                                enemy.y = newY;
                            }
                        }

                        // Hit particles
                        for (let k = 0; k < 8; k++) {
                            particles.push({
                                x: enemy.x,
                                y: enemy.y,
                                vx: (Math.random() - 0.5) * 4,
                                vy: (Math.random() - 0.5) * 4,
                                life: 20,
                                color: COLORS.enemy
                            });
                        }

                        if (enemy.health <= 0) {
                            onEnemyKill(enemy);

                            // Death particles
                            for (let k = 0; k < 15; k++) {
                                particles.push({
                                    x: enemy.x,
                                    y: enemy.y,
                                    vx: (Math.random() - 0.5) * 6,
                                    vy: (Math.random() - 0.5) * 6,
                                    life: 30,
                                    color: COLORS.enemy
                                });
                            }

                            enemies.splice(i, 1);
                        }
                    }
                }
            }
        }

        // Update enemies
        function updateEnemies() {
            if (gameState !== 'playing' && gameState !== 'multiplayer-playing') return;
            // In multiplayer, only host updates enemies
            if (gameState === 'multiplayer-playing' && !isHost) return;

            // Check if player is in safe zone
            const playerInSafeZone = Math.hypot(player.x - safeZone.x, player.y - safeZone.y) < safeZone.radius;

            for (let i = 0; i < enemies.length; i++) {
                const enemy = enemies[i];
                const dist = Math.hypot(player.x - enemy.x, player.y - enemy.y);

                if (dist < enemy.alertDistance) {
                    if (!enemyAlerted) {
                        enemyAlerted = true;
                        Music.setDrums(true);
                    }
                    // Move towards player
                    const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                    const stopDist = enemy.canShoot ? 50 : 20;

                    if (dist > stopDist) {
                        let newX = enemy.x + Math.cos(angle) * enemy.speed;
                        let newY = enemy.y + Math.sin(angle) * enemy.speed;
                        const newDistToSafe = Math.hypot(newX - safeZone.x, newY - safeZone.y);

                        // Don't enter safe zone
                        if (newDistToSafe >= safeZone.radius) {
                            // Check collision with other enemies
                            for (let j = 0; j < enemies.length; j++) {
                                if (i === j) continue;
                                const other = enemies[j];
                                const dx = newX - other.x;
                                const dy = newY - other.y;
                                const minDist = (enemy.width + other.width) / 2;
                                const eDist = Math.hypot(dx, dy);
                                if (eDist < minDist && eDist > 0) {
                                    // Push apart
                                    const push = (minDist - eDist) / 2;
                                    newX += (dx / eDist) * push;
                                    newY += (dy / eDist) * push;
                                }
                            }

                            if (!pointInWalls(newX, enemy.y, enemy.width, enemy.height)) {
                                enemy.x = newX;
                            }
                            if (!pointInWalls(enemy.x, newY, enemy.width, enemy.height)) {
                                enemy.y = newY;
                            }
                        }
                    }

                    // Melee damage for chargers
                    if (!enemy.canShoot && dist < 20 && !playerInSafeZone && enemy.shootCooldown <= 0) {
                        if (!godMode) player.health -= Math.floor(8 * currentDamageMult * (1 - playerArmor));
                        enemy.shootCooldown = 30;
                        if (player.health <= 0) { cleanupMultiplayer(); gameState = 'gameover'; }
                    }

                    // Shoot at player (but not if player is in safe zone)
                    if (enemy.canShoot && dist < enemy.shootDistance && enemy.shootCooldown <= 0 && !playerInSafeZone) {
                        shoot(enemy.x, enemy.y, angle, false);
                        SFX.enemyShoot();
                        enemy.shootCooldown = enemy.type === 'sniper' ? 90 : 60 + Math.random() * 30;
                    }
                }

                if (enemy.shootCooldown > 0) enemy.shootCooldown--;

                // Boss special attacks
                if (enemy.type === 'boss' && enemy.specialAttackCooldown !== undefined) {
                    updateBossAttack(enemy, playerInSafeZone);
                }
            }

            // Update warning zones
            for (let i = bossWarningZones.length - 1; i >= 0; i--) {
                const zone = bossWarningZones[i];
                zone.timer--;

                if (zone.timer <= 0) {
                    // Attack lands - deal damage if player is in zone
                    if (!playerInSafeZone) {
                        let playerHit = false;
                        if (zone.type === 'circle') {
                            const dist = Math.hypot(player.x - zone.x, player.y - zone.y);
                            playerHit = dist < zone.radius;
                        } else if (zone.type === 'line') {
                            // Check if player is in line attack
                            const lineLen = Math.hypot(zone.endX - zone.x, zone.endY - zone.y);
                            const dx = (zone.endX - zone.x) / lineLen;
                            const dy = (zone.endY - zone.y) / lineLen;
                            const px = player.x - zone.x;
                            const py = player.y - zone.y;
                            const proj = px * dx + py * dy;
                            if (proj >= 0 && proj <= lineLen) {
                                const perpDist = Math.abs(px * dy - py * dx);
                                playerHit = perpDist < zone.width / 2 + player.width / 2;
                            }
                        }

                        if (playerHit && !godMode) {
                            player.health -= Math.floor(zone.damage * (1 - playerArmor));
                            if (player.health <= 0) { cleanupMultiplayer(); gameState = 'gameover'; }
                        }
                    }

                    // Create explosion particles
                    for (let k = 0; k < 15; k++) {
                        const angle = Math.random() * Math.PI * 2;
                        const speed = Math.random() * 5 + 2;
                        particles.push({
                            x: zone.type === 'circle' ? zone.x : (zone.x + zone.endX) / 2,
                            y: zone.type === 'circle' ? zone.y : (zone.y + zone.endY) / 2,
                            vx: Math.cos(angle) * speed,
                            vy: Math.sin(angle) * speed,
                            life: 25,
                            color: zone.color || '#ff4500'
                        });
                    }

                    bossWarningZones.splice(i, 1);
                }
            }
            G.bossWarningZones = bossWarningZones;
        }

        // Update boss special attacks
        function updateBossAttack(boss, playerInSafeZone) {
            boss.specialAttackTimer++;

            if (boss.attackPhase === 'idle') {
                if (boss.specialAttackTimer >= boss.specialAttackCooldown) {
                    // Start a new special attack
                    boss.attackPhase = 'warning';
                    boss.specialAttackTimer = 0;

                    // Choose attack type based on dungeon and randomness
                    const attacks = ['slam', 'sweep', 'barrage'];
                    boss.attackType = attacks[Math.floor(Math.random() * attacks.length)];

                    // Create warning zones based on attack type
                    if (boss.attackType === 'slam') {
                        // Ground slam - circle around player's position
                        bossWarningZones.push({
                            type: 'circle',
                            x: player.x,
                            y: player.y,
                            radius: 60,
                            timer: 60, // 1 second warning
                            damage: 25 * currentDamageMult,
                            color: '#ff4500'
                        });
                    } else if (boss.attackType === 'sweep') {
                        // Line sweep from boss towards player
                        const angle = Math.atan2(player.y - boss.y, player.x - boss.x);
                        const len = 200;
                        bossWarningZones.push({
                            type: 'line',
                            x: boss.x,
                            y: boss.y,
                            endX: boss.x + Math.cos(angle) * len,
                            endY: boss.y + Math.sin(angle) * len,
                            width: 40,
                            timer: 45,
                            damage: 30 * currentDamageMult,
                            color: '#ff6b35'
                        });
                    } else if (boss.attackType === 'barrage') {
                        // Multiple circles around the arena
                        const numCircles = 3;
                        for (let i = 0; i < numCircles; i++) {
                            const randX = 60 + Math.random() * (W - 120);
                            const randY = 60 + Math.random() * (H - 120);
                            bossWarningZones.push({
                                type: 'circle',
                                x: randX,
                                y: randY,
                                radius: 45,
                                timer: 50 + i * 15, // Staggered timing
                                damage: 20 * currentDamageMult,
                                color: '#ff0000'
                            });
                        }
                    }

                    G.bossWarningZones = bossWarningZones;
                }
            } else if (boss.attackPhase === 'warning') {
                // Wait for warning zones to clear
                if (bossWarningZones.length === 0) {
                    boss.attackPhase = 'idle';
                    boss.specialAttackTimer = 0;
                    // Randomize next cooldown
                    boss.specialAttackCooldown = 90 + Math.random() * 60;
                }
            }
        }

        // Update bullets
        function updateBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i];
                b.x += b.vx;
                b.y += b.vy;
                b.life--;

                // Rocket smoke trail
                if (b.explosive) {
                    particles.push({
                        x: b.x,
                        y: b.y,
                        vx: (Math.random() - 0.5) * 1,
                        vy: (Math.random() - 0.5) * 1,
                        life: 15,
                        color: '#666'
                    });
                }

                // Wall collision
                if (pointInWalls(b.x, b.y, 4, 4) || b.life <= 0) {
                    // Explosive bullets explode on wall hit
                    if (b.explosive) {
                        explodeRocket(b.x, b.y, b.explosionRadius, b.damage);
                        bullets.splice(i, 1);
                        continue;
                    }
                    // Flame bullets just disappear
                    if (b.flame) {
                        bullets.splice(i, 1);
                        continue;
                    }
                    // Impact particles for normal bullets
                    for (let j = 0; j < 5; j++) {
                        particles.push({
                            x: b.x,
                            y: b.y,
                            vx: (Math.random() - 0.5) * 3,
                            vy: (Math.random() - 0.5) * 3,
                            life: 15,
                            color: '#888'
                        });
                    }
                    bullets.splice(i, 1);
                    continue;
                }

                // Hit detection
                if (b.isPlayer) {
                    let hitSomething = false;
                    for (let j = enemies.length - 1; j >= 0; j--) {
                        const e = enemies[j];
                        if (e.justHit) continue; // Skip if just hit by piercing/flame bullet
                        const dist = Math.hypot(b.x - e.x, b.y - e.y);
                        const hitRadius = b.flame ? 18 : 12; // Flame has larger hit area
                        if (dist < hitRadius) {
                            // Explosive bullets explode on enemy hit
                            if (b.explosive) {
                                explodeRocket(b.x, b.y, b.explosionRadius, b.damage);
                                bullets.splice(i, 1);
                                break;
                            }
                            e.health -= b.damage || 20;
                            if (b.pierce || b.flame) {
                                e.justHit = true;
                                hitSomething = true;
                            } else {
                                bullets.splice(i, 1);
                            }

                            // Hit particles
                            for (let k = 0; k < 8; k++) {
                                particles.push({
                                    x: e.x,
                                    y: e.y,
                                    vx: (Math.random() - 0.5) * 4,
                                    vy: (Math.random() - 0.5) * 4,
                                    life: 20,
                                    color: COLORS.enemy
                                });
                            }

                            if (e.health <= 0) {
                                onEnemyKill(e);
                                enemies.splice(j, 1);

                                // Death particles
                                for (let k = 0; k < 15; k++) {
                                    particles.push({
                                        x: e.x,
                                        y: e.y,
                                        vx: (Math.random() - 0.5) * 6,
                                        vy: (Math.random() - 0.5) * 6,
                                        life: 30,
                                        color: COLORS.enemy
                                    });
                                }
                            }
                            if (!b.pierce) break;
                        }
                    }
                    // Clear justHit flags
                    for (const e of enemies) e.justHit = false;
                } else {
                    const dist = Math.hypot(b.x - player.x, b.y - player.y);
                    const playerInSafeZone = Math.hypot(player.x - safeZone.x, player.y - safeZone.y) < safeZone.radius;
                    if (dist < 12 && !playerInSafeZone) {
                        if (!godMode) player.health -= Math.floor(10 * currentDamageMult * (1 - playerArmor));
                        bullets.splice(i, 1);

                        if (player.health <= 0) {
                            cleanupMultiplayer();
                            gameState = 'gameover';
                        }
                    }
                }
            }
        }

        // Update particles
        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vx *= 0.95;
                p.vy *= 0.95;
                p.life--;

                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }

        // Check level complete
        function checkLevelComplete() {
            if (gameState === 'playing' && enemies.length === 0) {
                gameState = 'levelcomplete';
                Music.playVictoryJingle();
                setTimeout(() => {
                    currentLevel++;
                    highestLevel = Math.max(highestLevel, currentLevel);
                    checkUnlocks();
                    // Run shop every 5 levels
                    if (currentLevel > 1 && currentLevel % 5 === 0) {
                        generateRunShopInventory();
                        gameState = 'runshop';
                    } else {
                        generateLevel(currentLevel);
                        gameState = 'playing';
                    }
                }, 2000);
            }
            // Multiplayer level complete - only host advances levels
            if (gameState === 'multiplayer-playing' && enemies.length === 0 && isHost) {
                gameState = 'levelcomplete';
                Music.playVictoryJingle();
                setTimeout(() => {
                    currentLevel++;
                    generateLevel(currentLevel);
                    gameState = 'multiplayer-playing';
                    // Notify client of level change
                    if (conn && conn.open) {
                        conn.send({ type: 'level_complete', level: currentLevel });
                    }
                }, 2000);
            }
        }

        // Draw everything
        // Menu button positions for click detection
        let menuButtons = [];

        function draw() {
            // Draw menu screen
            if (gameState === 'menu') {
                ctx.fillStyle = '#1a1a2e';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Coins display (top right)
                ctx.fillStyle = '#ffd700';
                ctx.font = isMobile ? '14px monospace' : '18px monospace';
                ctx.textAlign = 'right';
                ctx.fillText('$' + coins, canvas.width - 15, 25);

                // Current class display (top left)
                ctx.fillStyle = '#4ecdc4';
                ctx.font = isMobile ? '10px monospace' : '12px monospace';
                ctx.textAlign = 'left';
                const currentClass = CLASSES[selectedClass] || CLASSES.default;
                ctx.fillText('Class: ' + currentClass.name, 15, 25);

                // Title
                ctx.fillStyle = '#4ecdc4';
                ctx.font = isMobile ? '28px monospace' : '42px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('BUILDING CLEARER', canvas.width/2, isMobile ? 60 : 70);

                ctx.fillStyle = '#888';
                ctx.font = isMobile ? '12px monospace' : '16px monospace';
                ctx.fillText('Choose Your Dungeon', canvas.width/2, isMobile ? 90 : 110);

                // Draw dungeon options
                const dungeonKeys = Object.keys(DUNGEONS);
                const cols = isMobile ? 2 : 3;
                const rows = Math.ceil(dungeonKeys.length / cols);
                const btnW = isMobile ? 140 : 180;
                const btnH = isMobile ? 75 : 85;
                const gap = isMobile ? 12 : 15;
                const startX = (canvas.width - (cols * btnW + (cols - 1) * gap)) / 2;
                const startY = isMobile ? 110 : 130;

                menuButtons = [];

                for (let i = 0; i < dungeonKeys.length; i++) {
                    const key = dungeonKeys[i];
                    const dungeon = DUNGEONS[key];
                    const col = i % cols;
                    const row = Math.floor(i / cols);
                    const x = startX + col * (btnW + gap);
                    const y = startY + row * (btnH + gap);

                    menuButtons.push({ x, y, w: btnW, h: btnH, dungeon: key });

                    // Button background
                    ctx.fillStyle = dungeon.wallDark;
                    ctx.fillRect(x, y, btnW, btnH);
                    ctx.fillStyle = dungeon.wall;
                    ctx.fillRect(x + 3, y + 3, btnW - 6, btnH - 6);

                    // Accent bar
                    ctx.fillStyle = dungeon.accent;
                    ctx.fillRect(x + 3, y + btnH - 12, btnW - 6, 9);

                    // Icon
                    ctx.font = isMobile ? '22px monospace' : '28px monospace';
                    ctx.fillText(dungeon.icon, x + btnW/2, y + (isMobile ? 26 : 30));

                    // Name
                    ctx.fillStyle = '#fff';
                    ctx.font = isMobile ? '9px monospace' : '10px monospace';
                    ctx.fillText(dungeon.name, x + btnW/2, y + (isMobile ? 42 : 46));

                    // Difficulty stars
                    const diff = dungeon.difficulty || 1;
                    const starColors = ['#2ecc71', '#f1c40f', '#e67e22', '#e74c3c'];
                    ctx.fillStyle = starColors[diff - 1] || '#fff';
                    ctx.font = isMobile ? '10px monospace' : '11px monospace';
                    const stars = ''.repeat(diff) + ''.repeat(4 - diff);
                    ctx.fillText(stars, x + btnW/2, y + (isMobile ? 54 : 58));

                    // Difficulty label
                    ctx.fillStyle = starColors[diff - 1] || '#fff';
                    ctx.font = isMobile ? '8px monospace' : '9px monospace';
                    const diffLabels = ['Easy', 'Medium', 'Hard', 'Extreme'];
                    ctx.fillText(diffLabels[diff - 1] || 'Normal', x + btnW/2, y + (isMobile ? 64 : 70));
                }

                // Multiplayer button - hidden for now
                // const mpBtnW = isMobile ? 140 : 160;
                // const mpBtnH = isMobile ? 30 : 35;
                // const mpBtnX = canvas.width/2 - mpBtnW/2;
                // const mpBtnY = canvas.height - (isMobile ? 105 : 115);
                // menuButtons.push({ x: mpBtnX, y: mpBtnY, w: mpBtnW, h: mpBtnH, action: 'multiplayer' });
                // ctx.fillStyle = '#8e44ad';
                // ctx.fillRect(mpBtnX, mpBtnY, mpBtnW, mpBtnH);
                // ctx.fillStyle = '#9b59b6';
                // ctx.fillRect(mpBtnX + 3, mpBtnY + 3, mpBtnW - 6, mpBtnH - 6);
                // ctx.fillStyle = '#fff';
                // ctx.font = isMobile ? '12px monospace' : '14px monospace';
                // ctx.textAlign = 'center';
                // ctx.fillText('MULTIPLAYER', mpBtnX + mpBtnW/2, mpBtnY + (isMobile ? 20 : 23));

                // Shop button
                const shopBtnW = isMobile ? 100 : 120;
                const shopBtnH = isMobile ? 35 : 40;
                const shopBtnX = canvas.width/2 - shopBtnW/2 - (savedRun ? (isMobile ? 60 : 70) : 0);
                const shopBtnY = canvas.height - (isMobile ? 70 : 80);
                menuButtons.push({ x: shopBtnX, y: shopBtnY, w: shopBtnW, h: shopBtnH, action: 'shop' });

                ctx.fillStyle = '#b8860b';
                ctx.fillRect(shopBtnX, shopBtnY, shopBtnW, shopBtnH);
                ctx.fillStyle = '#ffd700';
                ctx.fillRect(shopBtnX + 3, shopBtnY + 3, shopBtnW - 6, shopBtnH - 6);
                ctx.fillStyle = '#1a1a2e';
                ctx.font = isMobile ? '12px monospace' : '16px monospace';
                ctx.fillText('SHOP', shopBtnX + shopBtnW/2, shopBtnY + (isMobile ? 23 : 27));

                // Continue button (only if there's a saved run)
                if (savedRun) {
                    const contBtnW = isMobile ? 100 : 120;
                    const contBtnH = isMobile ? 35 : 40;
                    const contBtnX = canvas.width/2 - contBtnW/2 + (isMobile ? 60 : 70);
                    const contBtnY = canvas.height - (isMobile ? 70 : 80);
                    menuButtons.push({ x: contBtnX, y: contBtnY, w: contBtnW, h: contBtnH, action: 'continue' });

                    ctx.fillStyle = '#27ae60';
                    ctx.fillRect(contBtnX, contBtnY, contBtnW, contBtnH);
                    ctx.fillStyle = '#2ecc71';
                    ctx.fillRect(contBtnX + 3, contBtnY + 3, contBtnW - 6, contBtnH - 6);
                    ctx.fillStyle = '#1a1a2e';
                    ctx.font = isMobile ? '10px monospace' : '12px monospace';
                    ctx.fillText('CONTINUE', contBtnX + contBtnW/2, contBtnY + (isMobile ? 16 : 18));
                    ctx.fillStyle = '#1a1a2e';
                    ctx.font = isMobile ? '8px monospace' : '10px monospace';
                    ctx.fillText('Lvl ' + savedRun.level, contBtnX + contBtnW/2, contBtnY + (isMobile ? 28 : 32));
                }

                // Donate button (top right, below coins)
                const donateBtnW = isMobile ? 70 : 80;
                const donateBtnH = isMobile ? 25 : 28;
                const donateBtnX = canvas.width - donateBtnW - 10;
                const donateBtnY = 35;
                menuButtons.push({ x: donateBtnX, y: donateBtnY, w: donateBtnW, h: donateBtnH, action: 'donate' });

                ctx.fillStyle = '#e74c3c';
                ctx.fillRect(donateBtnX, donateBtnY, donateBtnW, donateBtnH);
                ctx.fillStyle = '#c0392b';
                ctx.fillRect(donateBtnX + 2, donateBtnY + 2, donateBtnW - 4, donateBtnH - 4);
                ctx.fillStyle = '#fff';
                ctx.font = isMobile ? '9px monospace' : '11px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(' STD', donateBtnX + donateBtnW/2, donateBtnY + (isMobile ? 17 : 19));

                ctx.fillStyle = '#666';
                ctx.font = isMobile ? '10px monospace' : '14px monospace';
                ctx.fillText(isMobile ? 'Tap dungeon for NEW run' : 'Click dungeon for NEW run (clears save)', canvas.width/2, canvas.height - 15);
                ctx.textAlign = 'left';
                return;
            }

            // Draw character select screen
            if (gameState === 'charselect') {
                ctx.fillStyle = '#1a1a2e';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                charSelectButtons = [];

                // Title
                ctx.fillStyle = '#4ecdc4';
                ctx.font = isMobile ? '22px monospace' : '32px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('CHOOSE CHARACTER', canvas.width / 2, isMobile ? 35 : 45);

                // Color picker on the right side
                const swatchSize = isMobile ? 22 : 28;
                const swatchGap = isMobile ? 5 : 6;
                const colorColW = swatchSize + (isMobile ? 12 : 16);
                const colorPanelX = canvas.width - colorColW - (isMobile ? 6 : 10);

                // Character grid (all classes, locked shown grayed)
                const csClassKeys = Object.keys(CLASSES);
                const csCols = isMobile ? 2 : 3;
                const csCardW = isMobile ? 130 : 170;
                const csCardH = isMobile ? 90 : 105;
                const csGap = isMobile ? 10 : 14;
                const gridTotalW = csCols * csCardW + (csCols - 1) * csGap;
                const csStartX = (colorPanelX - gridTotalW) / 2;
                const csStartY = isMobile ? 50 : 60;

                for (let i = 0; i < csClassKeys.length; i++) {
                    const key = csClassKeys[i];
                    const cls = CLASSES[key];
                    const col = i % csCols;
                    const row = Math.floor(i / csCols);
                    const cx = csStartX + col * (csCardW + csGap);
                    const cy = csStartY + row * (csCardH + csGap);
                    const isUnlocked = unlockedClasses.includes(key);
                    const isSelected = isUnlocked && (key === selectedClass);

                    // Only push clickable buttons for unlocked classes
                    if (isUnlocked) {
                        charSelectButtons.push({ x: cx, y: cy, w: csCardW, h: csCardH, classKey: key });
                    }

                    // Card background
                    if (!isUnlocked) {
                        ctx.fillStyle = '#222';
                        ctx.fillRect(cx, cy, csCardW, csCardH);
                        ctx.fillStyle = '#111';
                        ctx.fillRect(cx + 3, cy + 3, csCardW - 6, csCardH - 6);
                    } else {
                        ctx.fillStyle = isSelected ? '#4ecdc4' : '#333';
                        ctx.fillRect(cx, cy, csCardW, csCardH);
                        ctx.fillStyle = '#1a1a2e';
                        ctx.fillRect(cx + 3, cy + 3, csCardW - 6, csCardH - 6);
                    }

                    // Character color preview square
                    const previewSize = isMobile ? 22 : 28;
                    const previewX = cx + (isMobile ? 12 : 15);
                    const previewY = cy + (csCardH - previewSize) / 2;
                    if (isUnlocked) {
                        const prevColor = isSelected ? COLOR_OPTIONS[selectedColorIdx] : { color: cls.color || '#4ecdc4', colorDark: cls.colorDark || '#2ea8a0' };
                        ctx.fillStyle = prevColor.colorDark;
                        ctx.fillRect(previewX, previewY, previewSize, previewSize);
                        ctx.fillStyle = prevColor.color;
                        ctx.fillRect(previewX + 2, previewY + 2, previewSize - 4, previewSize - 4);
                    } else {
                        // Locked: dark silhouette with lock
                        ctx.fillStyle = '#333';
                        ctx.fillRect(previewX, previewY, previewSize, previewSize);
                        ctx.fillStyle = '#555';
                        ctx.font = isMobile ? '14px monospace' : '18px monospace';
                        ctx.textAlign = 'center';
                        ctx.fillText('?', previewX + previewSize / 2, previewY + previewSize / 2 + (isMobile ? 5 : 6));
                        ctx.textAlign = 'left';
                    }

                    // Class name
                    const textX = previewX + previewSize + (isMobile ? 8 : 12);
                    ctx.fillStyle = !isUnlocked ? '#555' : (isSelected ? '#4ecdc4' : '#fff');
                    ctx.font = isMobile ? '11px monospace' : '13px monospace';
                    ctx.textAlign = 'left';
                    ctx.fillText(cls.name, textX, cy + (isMobile ? 22 : 26));

                    if (isUnlocked) {
                        // Weapon
                        ctx.fillStyle = '#aaa';
                        ctx.font = isMobile ? '9px monospace' : '10px monospace';
                        ctx.fillText(cls.weapon.toUpperCase(), textX, cy + (isMobile ? 36 : 42));

                        // Stats: HP / Speed
                        ctx.fillStyle = '#2ecc71';
                        ctx.font = isMobile ? '9px monospace' : '10px monospace';
                        ctx.fillText('HP:' + cls.health, textX, cy + (isMobile ? 50 : 58));
                        ctx.fillStyle = '#3498db';
                        ctx.fillText('SPD:' + cls.speed, textX + (isMobile ? 55 : 65), cy + (isMobile ? 50 : 58));

                        // Description
                        ctx.fillStyle = '#888';
                        ctx.font = isMobile ? '8px monospace' : '9px monospace';
                        ctx.fillText(cls.description, textX, cy + (isMobile ? 64 : 74));
                    } else {
                        // Locked: show unlock condition
                        ctx.fillStyle = '#e74c3c';
                        ctx.font = isMobile ? '9px monospace' : '10px monospace';
                        ctx.fillText('LOCKED', textX, cy + (isMobile ? 40 : 46));
                        ctx.fillStyle = '#777';
                        ctx.font = isMobile ? '8px monospace' : '9px monospace';
                        ctx.fillText(cls.unlockDesc || '???', textX, cy + (isMobile ? 55 : 62));
                    }
                }

                // Draw color swatches vertically on the right
                const colorStartY = csStartY;
                const swatchCenterX = colorPanelX + colorColW / 2;

                ctx.fillStyle = '#aaa';
                ctx.font = isMobile ? '8px monospace' : '9px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('COLOR', swatchCenterX, colorStartY - (isMobile ? 4 : 5));

                for (let ci = 0; ci < COLOR_OPTIONS.length; ci++) {
                    const co = COLOR_OPTIONS[ci];
                    const sx = swatchCenterX - swatchSize / 2;
                    const sy = colorStartY + ci * (swatchSize + swatchGap);
                    const isSel = (ci === selectedColorIdx);

                    charSelectButtons.push({ x: sx, y: sy, w: swatchSize, h: swatchSize, colorIdx: ci });

                    if (isSel) {
                        ctx.fillStyle = '#fff';
                        ctx.fillRect(sx - 2, sy - 2, swatchSize + 4, swatchSize + 4);
                    }
                    ctx.fillStyle = co.colorDark;
                    ctx.fillRect(sx, sy, swatchSize, swatchSize);
                    ctx.fillStyle = co.color;
                    ctx.fillRect(sx + 2, sy + 2, swatchSize - 4, swatchSize - 4);
                }

                // PLAY button
                const csRows = Math.ceil(csClassKeys.length / csCols);
                const playBtnW = isMobile ? 120 : 150;
                const playBtnH = isMobile ? 38 : 45;
                const playBtnY = csStartY + csRows * (csCardH + csGap) + (isMobile ? 5 : 10);
                const playBtnX = canvas.width / 2 - playBtnW / 2 + (isMobile ? 40 : 50);
                charSelectButtons.push({ x: playBtnX, y: playBtnY, w: playBtnW, h: playBtnH, action: 'play' });

                ctx.fillStyle = '#27ae60';
                ctx.fillRect(playBtnX, playBtnY, playBtnW, playBtnH);
                ctx.fillStyle = '#2ecc71';
                ctx.fillRect(playBtnX + 3, playBtnY + 3, playBtnW - 6, playBtnH - 6);
                ctx.fillStyle = '#fff';
                ctx.font = isMobile ? '14px monospace' : '18px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('PLAY', playBtnX + playBtnW / 2, playBtnY + (isMobile ? 25 : 30));

                // BACK button
                const backBtnW = isMobile ? 90 : 110;
                const backBtnH = isMobile ? 38 : 45;
                const backBtnX = canvas.width / 2 - backBtnW / 2 - (isMobile ? 40 : 50);
                const backBtnY = playBtnY;
                charSelectButtons.push({ x: backBtnX, y: backBtnY, w: backBtnW, h: backBtnH, action: 'back' });

                ctx.fillStyle = '#555';
                ctx.fillRect(backBtnX, backBtnY, backBtnW, backBtnH);
                ctx.fillStyle = '#777';
                ctx.fillRect(backBtnX + 3, backBtnY + 3, backBtnW - 6, backBtnH - 6);
                ctx.fillStyle = '#fff';
                ctx.font = isMobile ? '12px monospace' : '14px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('BACK', backBtnX + backBtnW / 2, backBtnY + (isMobile ? 25 : 30));

                ctx.textAlign = 'left';
                return;
            }

            // Draw shop screen
            if (gameState === 'shop') {
                ctx.fillStyle = '#1a1a2e';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Coins display
                ctx.fillStyle = '#ffd700';
                ctx.font = isMobile ? '14px monospace' : '18px monospace';
                ctx.textAlign = 'right';
                ctx.fillText('$' + coins, canvas.width - 15, 25);

                // Title
                ctx.fillStyle = '#ffd700';
                ctx.font = isMobile ? '24px monospace' : '36px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('CLASS SHOP', canvas.width/2, isMobile ? 50 : 60);

                // Draw class options (only shop-purchasable classes)
                const classKeys = Object.keys(CLASSES).filter(k => CLASSES[k].unlockType === 'shop');
                const cols = isMobile ? 2 : 3;
                const btnW = isMobile ? 160 : 190;
                const btnH = isMobile ? 70 : 80;
                const gap = isMobile ? 10 : 15;
                const startX = (canvas.width - (cols * btnW + (cols - 1) * gap)) / 2;
                const startY = isMobile ? 70 : 90;

                menuButtons = [];

                for (let i = 0; i < classKeys.length; i++) {
                    const key = classKeys[i];
                    const cls = CLASSES[key];
                    const col = i % cols;
                    const row = Math.floor(i / cols);
                    const x = startX + col * (btnW + gap);
                    const y = startY + row * (btnH + gap);

                    const owned = unlockedClasses.includes(key);
                    const selected = selectedClass === key;
                    const canAfford = coins >= cls.price;

                    menuButtons.push({ x, y, w: btnW, h: btnH, classKey: key });

                    // Button background
                    if (selected) {
                        ctx.fillStyle = '#4ecdc4';
                    } else if (owned) {
                        ctx.fillStyle = '#2ecc71';
                    } else if (canAfford) {
                        ctx.fillStyle = '#f1c40f';
                    } else {
                        ctx.fillStyle = '#555';
                    }
                    ctx.fillRect(x, y, btnW, btnH);
                    ctx.fillStyle = '#1a1a2e';
                    ctx.fillRect(x + 3, y + 3, btnW - 6, btnH - 6);

                    // Class name
                    ctx.fillStyle = selected ? '#4ecdc4' : (owned ? '#2ecc71' : '#fff');
                    ctx.font = isMobile ? '11px monospace' : '14px monospace';
                    ctx.fillText(cls.name, x + btnW/2, y + (isMobile ? 18 : 22));

                    // Description
                    ctx.fillStyle = '#888';
                    ctx.font = isMobile ? '8px monospace' : '10px monospace';
                    ctx.fillText(cls.description, x + btnW/2, y + (isMobile ? 32 : 38));

                    // Price or status
                    if (selected) {
                        ctx.fillStyle = '#4ecdc4';
                        ctx.fillText('SELECTED', x + btnW/2, y + (isMobile ? 48 : 56));
                    } else if (owned) {
                        ctx.fillStyle = '#2ecc71';
                        ctx.fillText('OWNED - Click to select', x + btnW/2, y + (isMobile ? 48 : 56));
                    } else {
                        ctx.fillStyle = canAfford ? '#ffd700' : '#e74c3c';
                        ctx.fillText('$' + cls.price, x + btnW/2, y + (isMobile ? 48 : 56));
                    }

                    // Starting weapon icon
                    if (cls.weapon !== 'pistol') {
                        ctx.fillStyle = '#666';
                        ctx.font = isMobile ? '8px monospace' : '9px monospace';
                        ctx.fillText('Starts: ' + cls.weapon, x + btnW/2, y + (isMobile ? 62 : 70));
                    }
                }

                // Back button
                const backBtnW = isMobile ? 80 : 100;
                const backBtnH = isMobile ? 30 : 35;
                const backBtnX = canvas.width/2 - backBtnW/2;
                const backBtnY = canvas.height - (isMobile ? 45 : 50);
                menuButtons.push({ x: backBtnX, y: backBtnY, w: backBtnW, h: backBtnH, action: 'back' });

                ctx.fillStyle = '#e74c3c';
                ctx.fillRect(backBtnX, backBtnY, backBtnW, backBtnH);
                ctx.fillStyle = '#c0392b';
                ctx.fillRect(backBtnX + 3, backBtnY + 3, backBtnW - 6, backBtnH - 6);
                ctx.fillStyle = '#fff';
                ctx.font = isMobile ? '12px monospace' : '14px monospace';
                ctx.fillText('BACK', canvas.width/2, backBtnY + (isMobile ? 20 : 24));

                ctx.textAlign = 'left';
                return;
            }

            // Draw run shop screen
            if (gameState === 'runshop') {
                drawRunShop();
                return;
            }

            // Draw multiplayer menu screen
            if (gameState === 'multiplayer-menu') {
                ctx.fillStyle = '#1a1a2e';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Title
                ctx.fillStyle = '#9b59b6';
                ctx.font = isMobile ? '24px monospace' : '36px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('MULTIPLAYER', canvas.width/2, isMobile ? 80 : 100);

                ctx.fillStyle = '#888';
                ctx.font = isMobile ? '11px monospace' : '14px monospace';
                ctx.fillText('Play with a friend!', canvas.width/2, isMobile ? 110 : 135);

                menuButtons = [];

                // Host button
                const hostBtnW = isMobile ? 200 : 250;
                const hostBtnH = isMobile ? 60 : 70;
                const hostBtnX = canvas.width/2 - hostBtnW/2;
                const hostBtnY = isMobile ? 160 : 180;
                menuButtons.push({ x: hostBtnX, y: hostBtnY, w: hostBtnW, h: hostBtnH, action: 'mp_host' });

                ctx.fillStyle = '#27ae60';
                ctx.fillRect(hostBtnX, hostBtnY, hostBtnW, hostBtnH);
                ctx.fillStyle = '#2ecc71';
                ctx.fillRect(hostBtnX + 3, hostBtnY + 3, hostBtnW - 6, hostBtnH - 6);
                ctx.fillStyle = '#1a1a2e';
                ctx.font = isMobile ? '16px monospace' : '20px monospace';
                ctx.fillText('HOST GAME', hostBtnX + hostBtnW/2, hostBtnY + (isMobile ? 28 : 32));
                ctx.font = isMobile ? '10px monospace' : '12px monospace';
                ctx.fillText('Create a room for others to join', hostBtnX + hostBtnW/2, hostBtnY + (isMobile ? 46 : 52));

                // Join button
                const joinBtnY = hostBtnY + hostBtnH + 20;
                menuButtons.push({ x: hostBtnX, y: joinBtnY, w: hostBtnW, h: hostBtnH, action: 'mp_join' });

                ctx.fillStyle = '#2980b9';
                ctx.fillRect(hostBtnX, joinBtnY, hostBtnW, hostBtnH);
                ctx.fillStyle = '#3498db';
                ctx.fillRect(hostBtnX + 3, joinBtnY + 3, hostBtnW - 6, hostBtnH - 6);
                ctx.fillStyle = '#1a1a2e';
                ctx.font = isMobile ? '16px monospace' : '20px monospace';
                ctx.fillText('JOIN GAME', hostBtnX + hostBtnW/2, joinBtnY + (isMobile ? 28 : 32));
                ctx.font = isMobile ? '10px monospace' : '12px monospace';
                ctx.fillText('Enter a room code to join', hostBtnX + hostBtnW/2, joinBtnY + (isMobile ? 46 : 52));

                // Back button
                const backBtnW = isMobile ? 80 : 100;
                const backBtnH = isMobile ? 30 : 35;
                const backBtnX = canvas.width/2 - backBtnW/2;
                const backBtnY = canvas.height - (isMobile ? 50 : 60);
                menuButtons.push({ x: backBtnX, y: backBtnY, w: backBtnW, h: backBtnH, action: 'back' });

                ctx.fillStyle = '#e74c3c';
                ctx.fillRect(backBtnX, backBtnY, backBtnW, backBtnH);
                ctx.fillStyle = '#c0392b';
                ctx.fillRect(backBtnX + 3, backBtnY + 3, backBtnW - 6, backBtnH - 6);
                ctx.fillStyle = '#fff';
                ctx.font = isMobile ? '12px monospace' : '14px monospace';
                ctx.fillText('BACK', backBtnX + backBtnW/2, backBtnY + (isMobile ? 20 : 24));

                ctx.textAlign = 'left';
                return;
            }

            // Draw hosting screen (waiting for player)
            if (gameState === 'hosting') {
                ctx.fillStyle = '#1a1a2e';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.fillStyle = '#2ecc71';
                ctx.font = isMobile ? '20px monospace' : '28px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('HOSTING GAME', canvas.width/2, isMobile ? 80 : 100);

                ctx.fillStyle = '#888';
                ctx.font = isMobile ? '12px monospace' : '16px monospace';
                ctx.fillText('Share this code with your friend:', canvas.width/2, isMobile ? 130 : 160);

                // Room code display
                ctx.fillStyle = '#9b59b6';
                ctx.font = isMobile ? '48px monospace' : '64px monospace';
                ctx.fillText(roomCode, canvas.width/2, isMobile ? 200 : 240);

                // Connection status
                ctx.fillStyle = remotePlayer.connected ? '#2ecc71' : '#f39c12';
                ctx.font = isMobile ? '14px monospace' : '18px monospace';
                const statusText = remotePlayer.connected ? 'Player connected!' : 'Waiting for player...';
                ctx.fillText(statusText, canvas.width/2, isMobile ? 260 : 310);

                menuButtons = [];

                // Cancel button
                const cancelBtnW = isMobile ? 100 : 120;
                const cancelBtnH = isMobile ? 35 : 40;
                const cancelBtnX = canvas.width/2 - cancelBtnW/2;
                const cancelBtnY = canvas.height - (isMobile ? 60 : 80);
                menuButtons.push({ x: cancelBtnX, y: cancelBtnY, w: cancelBtnW, h: cancelBtnH, action: 'mp_cancel' });

                ctx.fillStyle = '#e74c3c';
                ctx.fillRect(cancelBtnX, cancelBtnY, cancelBtnW, cancelBtnH);
                ctx.fillStyle = '#c0392b';
                ctx.fillRect(cancelBtnX + 3, cancelBtnY + 3, cancelBtnW - 6, cancelBtnH - 6);
                ctx.fillStyle = '#fff';
                ctx.font = isMobile ? '12px monospace' : '16px monospace';
                ctx.fillText('CANCEL', cancelBtnX + cancelBtnW/2, cancelBtnY + (isMobile ? 23 : 27));

                // Start button (only if connected)
                if (remotePlayer.connected) {
                    const startBtnW = isMobile ? 140 : 160;
                    const startBtnH = isMobile ? 45 : 50;
                    const startBtnX = canvas.width/2 - startBtnW/2;
                    const startBtnY = isMobile ? 300 : 360;
                    menuButtons.push({ x: startBtnX, y: startBtnY, w: startBtnW, h: startBtnH, action: 'mp_mode_select' });

                    ctx.fillStyle = '#27ae60';
                    ctx.fillRect(startBtnX, startBtnY, startBtnW, startBtnH);
                    ctx.fillStyle = '#2ecc71';
                    ctx.fillRect(startBtnX + 3, startBtnY + 3, startBtnW - 6, startBtnH - 6);
                    ctx.fillStyle = '#1a1a2e';
                    ctx.font = isMobile ? '14px monospace' : '18px monospace';
                    ctx.fillText('SELECT MODE', startBtnX + startBtnW/2, startBtnY + (isMobile ? 30 : 33));
                }

                ctx.textAlign = 'left';
                return;
            }

            // Draw joining screen (enter code)
            if (gameState === 'joining') {
                ctx.fillStyle = '#1a1a2e';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.fillStyle = '#3498db';
                ctx.font = isMobile ? '20px monospace' : '28px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('JOIN GAME', canvas.width/2, isMobile ? 80 : 100);

                ctx.fillStyle = '#888';
                ctx.font = isMobile ? '12px monospace' : '16px monospace';
                ctx.fillText('Enter the room code:', canvas.width/2, isMobile ? 130 : 160);

                // Code input box
                const inputW = isMobile ? 180 : 220;
                const inputH = isMobile ? 50 : 60;
                const inputX = canvas.width/2 - inputW/2;
                const inputY = isMobile ? 160 : 190;

                ctx.fillStyle = '#333';
                ctx.fillRect(inputX, inputY, inputW, inputH);
                ctx.fillStyle = '#444';
                ctx.fillRect(inputX + 3, inputY + 3, inputW - 6, inputH - 6);

                ctx.fillStyle = '#fff';
                ctx.font = isMobile ? '32px monospace' : '42px monospace';
                ctx.fillText(roomCodeInput || '____', canvas.width/2, inputY + (isMobile ? 38 : 45));

                // Instructions
                ctx.fillStyle = '#666';
                ctx.font = isMobile ? '10px monospace' : '12px monospace';
                ctx.fillText('Type the 4-letter code', canvas.width/2, inputY + inputH + 20);

                // Connection status
                if (conn) {
                    ctx.fillStyle = remotePlayer.connected ? '#2ecc71' : '#f39c12';
                    ctx.font = isMobile ? '12px monospace' : '14px monospace';
                    const statusText = remotePlayer.connected ? 'Connected! Waiting for host...' : 'Connecting...';
                    ctx.fillText(statusText, canvas.width/2, inputY + inputH + 50);
                }

                menuButtons = [];

                // Cancel button
                const cancelBtnW = isMobile ? 100 : 120;
                const cancelBtnH = isMobile ? 35 : 40;
                const cancelBtnX = canvas.width/2 - cancelBtnW/2;
                const cancelBtnY = canvas.height - (isMobile ? 60 : 80);
                menuButtons.push({ x: cancelBtnX, y: cancelBtnY, w: cancelBtnW, h: cancelBtnH, action: 'mp_cancel' });

                ctx.fillStyle = '#e74c3c';
                ctx.fillRect(cancelBtnX, cancelBtnY, cancelBtnW, cancelBtnH);
                ctx.fillStyle = '#c0392b';
                ctx.fillRect(cancelBtnX + 3, cancelBtnY + 3, cancelBtnW - 6, cancelBtnH - 6);
                ctx.fillStyle = '#fff';
                ctx.font = isMobile ? '12px monospace' : '16px monospace';
                ctx.fillText('CANCEL', cancelBtnX + cancelBtnW/2, cancelBtnY + (isMobile ? 23 : 27));

                ctx.textAlign = 'left';
                return;
            }

            // Draw mode select screen (host only)
            if (gameState === 'mode-select') {
                ctx.fillStyle = '#1a1a2e';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.fillStyle = '#9b59b6';
                ctx.font = isMobile ? '20px monospace' : '28px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('SELECT MODE', canvas.width/2, isMobile ? 80 : 100);

                ctx.fillStyle = '#888';
                ctx.font = isMobile ? '11px monospace' : '14px monospace';
                ctx.fillText('Choose how you want to play', canvas.width/2, isMobile ? 110 : 135);

                menuButtons = [];

                // Co-op button
                const modeBtnW = isMobile ? 200 : 250;
                const modeBtnH = isMobile ? 70 : 80;
                const modeBtnX = canvas.width/2 - modeBtnW/2;
                const coopBtnY = isMobile ? 140 : 170;
                menuButtons.push({ x: modeBtnX, y: coopBtnY, w: modeBtnW, h: modeBtnH, action: 'mp_coop' });

                ctx.fillStyle = '#27ae60';
                ctx.fillRect(modeBtnX, coopBtnY, modeBtnW, modeBtnH);
                ctx.fillStyle = '#2ecc71';
                ctx.fillRect(modeBtnX + 3, coopBtnY + 3, modeBtnW - 6, modeBtnH - 6);
                ctx.fillStyle = '#1a1a2e';
                ctx.font = isMobile ? '18px monospace' : '22px monospace';
                ctx.fillText('CO-OP', modeBtnX + modeBtnW/2, coopBtnY + (isMobile ? 30 : 35));
                ctx.font = isMobile ? '9px monospace' : '11px monospace';
                ctx.fillText('Team up to clear rooms', modeBtnX + modeBtnW/2, coopBtnY + (isMobile ? 48 : 55));
                ctx.fillText('Shared enemies & progress', modeBtnX + modeBtnW/2, coopBtnY + (isMobile ? 62 : 70));

                // Race button
                const raceBtnY = coopBtnY + modeBtnH + 20;
                menuButtons.push({ x: modeBtnX, y: raceBtnY, w: modeBtnW, h: modeBtnH, action: 'mp_race' });

                ctx.fillStyle = '#e67e22';
                ctx.fillRect(modeBtnX, raceBtnY, modeBtnW, modeBtnH);
                ctx.fillStyle = '#f39c12';
                ctx.fillRect(modeBtnX + 3, raceBtnY + 3, modeBtnW - 6, modeBtnH - 6);
                ctx.fillStyle = '#1a1a2e';
                ctx.font = isMobile ? '18px monospace' : '22px monospace';
                ctx.fillText('RACE', modeBtnX + modeBtnW/2, raceBtnY + (isMobile ? 30 : 35));
                ctx.font = isMobile ? '9px monospace' : '11px monospace';
                ctx.fillText('Compete to clear rooms fastest', modeBtnX + modeBtnW/2, raceBtnY + (isMobile ? 48 : 55));
                ctx.fillText('First to clear wins each room', modeBtnX + modeBtnW/2, raceBtnY + (isMobile ? 62 : 70));

                // Back button
                const backBtnW = isMobile ? 80 : 100;
                const backBtnH = isMobile ? 30 : 35;
                const backBtnX = canvas.width/2 - backBtnW/2;
                const backBtnY = canvas.height - (isMobile ? 50 : 60);
                menuButtons.push({ x: backBtnX, y: backBtnY, w: backBtnW, h: backBtnH, action: 'mp_cancel' });

                ctx.fillStyle = '#e74c3c';
                ctx.fillRect(backBtnX, backBtnY, backBtnW, backBtnH);
                ctx.fillStyle = '#c0392b';
                ctx.fillRect(backBtnX + 3, backBtnY + 3, backBtnW - 6, backBtnH - 6);
                ctx.fillStyle = '#fff';
                ctx.font = isMobile ? '12px monospace' : '14px monospace';
                ctx.fillText('BACK', backBtnX + backBtnW/2, backBtnY + (isMobile ? 20 : 24));

                ctx.textAlign = 'left';
                return;
            }

            // Draw waiting for host screen (client waiting for mode select)
            if (gameState === 'waiting-for-host') {
                ctx.fillStyle = '#1a1a2e';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.fillStyle = '#3498db';
                ctx.font = isMobile ? '20px monospace' : '28px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('CONNECTED!', canvas.width/2, isMobile ? 100 : 120);

                ctx.fillStyle = '#888';
                ctx.font = isMobile ? '14px monospace' : '18px monospace';
                ctx.fillText('Waiting for host to select mode...', canvas.width/2, isMobile ? 200 : 240);

                // Animated dots
                const dots = '.'.repeat((Math.floor(Date.now() / 500) % 4));
                ctx.fillText(dots, canvas.width/2, isMobile ? 230 : 280);

                menuButtons = [];

                // Cancel button
                const cancelBtnW = isMobile ? 100 : 120;
                const cancelBtnH = isMobile ? 35 : 40;
                const cancelBtnX = canvas.width/2 - cancelBtnW/2;
                const cancelBtnY = canvas.height - (isMobile ? 60 : 80);
                menuButtons.push({ x: cancelBtnX, y: cancelBtnY, w: cancelBtnW, h: cancelBtnH, action: 'mp_cancel' });

                ctx.fillStyle = '#e74c3c';
                ctx.fillRect(cancelBtnX, cancelBtnY, cancelBtnW, cancelBtnH);
                ctx.fillStyle = '#c0392b';
                ctx.fillRect(cancelBtnX + 3, cancelBtnY + 3, cancelBtnW - 6, cancelBtnH - 6);
                ctx.fillStyle = '#fff';
                ctx.font = isMobile ? '12px monospace' : '16px monospace';
                ctx.fillText('LEAVE', cancelBtnX + cancelBtnW/2, cancelBtnY + (isMobile ? 23 : 27));

                ctx.textAlign = 'left';
                return;
            }

            // Clear full canvas with floor color before isometric transform
            ctx.fillStyle = COLORS.floor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Begin isometric projection
            ctx.save();
            ctx.scale(1, ISO_SCALE);

            // Draw floor decorations (under everything)
            drawFloorDecorations();

            // Draw safe zone
            ctx.beginPath();
            ctx.arc(safeZone.x, safeZone.y, safeZone.radius, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(78, 205, 196, 0.15)';
            ctx.fill();
            ctx.strokeStyle = 'rgba(78, 205, 196, 0.4)';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Draw walls with 2.5D extrusion
            const WALL_HEIGHT = 15;
            // First pass: south faces (visible side depth)
            for (const wall of walls) {
                ctx.fillStyle = COLORS.wallDark;
                ctx.fillRect(Math.floor(wall.x), Math.floor(wall.y + wall.h), wall.w, WALL_HEIGHT);
                ctx.fillStyle = 'rgba(0,0,0,0.35)';
                ctx.fillRect(Math.floor(wall.x), Math.floor(wall.y + wall.h), wall.w, WALL_HEIGHT);
            }
            // Second pass: top faces and decorations
            for (const wall of walls) {
                drawPixelRect(wall.x, wall.y, wall.w, wall.h, COLORS.wall, COLORS.wallDark);
                drawWallDecorations(wall);
            }

            // Draw large level props (trees, pillars, etc.)
            drawLevelProps();

            // Draw placed bombs
            for (const bomb of bombs) {
                // Bomb body
                ctx.fillStyle = '#1a1a1a';
                ctx.beginPath();
                ctx.arc(bomb.x, bomb.y, 10, 0, Math.PI * 2);
                ctx.fill();
                // Highlight
                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.arc(bomb.x - 3, bomb.y - 3, 4, 0, Math.PI * 2);
                ctx.fill();
                // Fuse
                ctx.strokeStyle = '#8b4513';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(bomb.x + 6, bomb.y - 6);
                ctx.quadraticCurveTo(bomb.x + 12, bomb.y - 12, bomb.x + 8, bomb.y - 16);
                ctx.stroke();
                // Fuse spark (blinking)
                if (bomb.fuseTime % 20 < 10) {
                    ctx.fillStyle = '#ff4500';
                    ctx.beginPath();
                    ctx.arc(bomb.x + 8, bomb.y - 16, 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#ff0';
                    ctx.beginPath();
                    ctx.arc(bomb.x + 8, bomb.y - 16, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                // Timer text
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 10px monospace';
                ctx.textAlign = 'center';
                const secondsLeft = Math.ceil(bomb.fuseTime / 60);
                ctx.fillText(secondsLeft, bomb.x, bomb.y + 4);
                ctx.textAlign = 'left';
            }

            // Fog of war: compute opacity based on distance from player
            function fogAlpha(x, y) {
                if (!selectedDungeon) return 1;
                const lighting = (DUNGEONS[selectedDungeon] || DUNGEONS.dungeon).lighting;
                const r = lighting.playerLightRadius * (isMobile ? 1.15 : 1);
                const dist = Math.hypot(x - player.x, y - player.y);
                if (dist <= r * 0.5) return 1;
                if (dist >= r) return 0.55;
                return 1 - 0.45 * ((dist - r * 0.5) / (r * 0.5));
            }

            // Draw pickups
            for (const p of pickups) {
                ctx.globalAlpha = fogAlpha(p.x, p.y) * 0.25;
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.ellipse(p.x, p.y + 8, 6, 2.5, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = fogAlpha(p.x, p.y);
                if (p.type === 'health') {
                    // Health pickup - cross shape
                    ctx.fillStyle = COLORS.health;
                    ctx.fillRect(p.x - 2, p.y - 6, 4, 12);
                    ctx.fillRect(p.x - 6, p.y - 2, 12, 4);
                } else if (p.type === 'ammo') {
                    // Ammo pickup - bullet shape
                    ctx.fillStyle = COLORS.ammo;
                    ctx.fillRect(p.x - 3, p.y - 5, 6, 10);
                    ctx.fillStyle = '#d4a017';
                    ctx.fillRect(p.x - 3, p.y + 2, 6, 3);
                } else if (p.type === 'coin') {
                    // Coin pickup - shiny gold coin
                    ctx.fillStyle = '#ffd700';
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 7, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#ffec8b';
                    ctx.beginPath();
                    ctx.arc(p.x - 2, p.y - 2, 3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#b8860b';
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 7, 0, Math.PI * 2);
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = '#b8860b';
                    ctx.stroke();
                    // $ symbol
                    ctx.fillStyle = '#b8860b';
                    ctx.font = 'bold 8px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('$', p.x, p.y + 3);
                    ctx.textAlign = 'left';
                } else if (p.type === 'scrap') {
                    // Scrap pickup - metallic circle
                    ctx.fillStyle = '#7f8c8d';
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#bdc3c7';
                    ctx.beginPath();
                    ctx.arc(p.x - 1, p.y - 1, 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#566573';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 5, 0, Math.PI * 2);
                    ctx.stroke();
                } else if (WEAPONS[p.type]) {
                    // Weapon pickup
                    const weapon = WEAPONS[p.type];

                    // Glow effect
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 12, 0, Math.PI * 2);
                    ctx.fillStyle = weapon.color + '40';
                    ctx.fill();

                    if (p.type === 'sword') {
                        // Sword pickup - blade shape
                        ctx.fillStyle = '#5d4e37'; // Handle
                        ctx.fillRect(p.x - 10, p.y - 2, 6, 4);
                        ctx.fillStyle = '#8b7355'; // Crossguard
                        ctx.fillRect(p.x - 5, p.y - 4, 3, 8);
                        ctx.fillStyle = weapon.color; // Blade
                        ctx.fillRect(p.x - 2, p.y - 2, 14, 4);
                        ctx.fillStyle = '#fff'; // Highlight
                        ctx.fillRect(p.x, p.y - 1, 10, 1);
                    } else if (p.type === 'katana') {
                        // Katana pickup - curved blade
                        ctx.fillStyle = '#2c2c2c'; // Handle
                        ctx.fillRect(p.x - 12, p.y - 1, 8, 3);
                        ctx.fillStyle = '#8b0000'; // Red wrap
                        ctx.fillRect(p.x - 11, p.y - 1, 2, 3);
                        ctx.fillStyle = '#4a4a4a'; // Guard
                        ctx.beginPath();
                        ctx.arc(p.x - 4, p.y, 3, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = weapon.color; // Blade
                        ctx.beginPath();
                        ctx.moveTo(p.x - 1, p.y - 2);
                        ctx.quadraticCurveTo(p.x + 8, p.y - 3, p.x + 14, p.y - 1);
                        ctx.lineTo(p.x + 14, p.y + 1);
                        ctx.quadraticCurveTo(p.x + 8, p.y + 2, p.x - 1, p.y + 2);
                        ctx.closePath();
                        ctx.fill();
                    } else if (p.type === 'sniper') {
                        // Sniper pickup - long rifle
                        ctx.fillStyle = weapon.color;
                        ctx.fillRect(p.x - 12, p.y - 2, 24, 4);
                        ctx.fillStyle = '#4a3728';
                        ctx.fillRect(p.x - 10, p.y + 1, 6, 3);
                        ctx.fillStyle = '#333';
                        ctx.fillRect(p.x + 4, p.y - 4, 6, 2); // Scope
                        ctx.fillStyle = '#5af';
                        ctx.fillRect(p.x + 5, p.y - 3, 2, 1);
                    } else if (p.type === 'flamethrower') {
                        // Flamethrower pickup
                        ctx.fillStyle = '#666';
                        ctx.fillRect(p.x - 10, p.y - 3, 6, 6); // Tank
                        ctx.fillStyle = '#ff6600';
                        ctx.fillRect(p.x - 9, p.y - 2, 4, 4);
                        ctx.fillStyle = '#444';
                        ctx.fillRect(p.x - 4, p.y - 2, 10, 4); // Body
                        ctx.fillStyle = weapon.color;
                        ctx.fillRect(p.x + 6, p.y - 2, 6, 4); // Nozzle
                        // Flame
                        ctx.fillStyle = '#ff0';
                        ctx.fillRect(p.x + 10, p.y - 1, 4, 2);
                    } else if (p.type === 'rocketlauncher') {
                        // Rocket launcher pickup - tube
                        ctx.fillStyle = weapon.color;
                        ctx.fillRect(p.x - 10, p.y - 4, 20, 8); // Tube
                        ctx.fillStyle = '#222';
                        ctx.fillRect(p.x - 10, p.y - 5, 3, 10); // Back rim
                        ctx.fillRect(p.x + 7, p.y - 5, 3, 10); // Front rim
                        ctx.fillStyle = '#8b0000';
                        ctx.fillRect(p.x - 2, p.y - 2, 4, 4); // Rocket
                    } else if (p.type === 'bomb') {
                        // Bomb pickup
                        ctx.fillStyle = weapon.color;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, 8, 0, Math.PI * 2);
                        ctx.fill();
                        // Fuse
                        ctx.strokeStyle = '#8b4513';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(p.x + 5, p.y - 5);
                        ctx.lineTo(p.x + 8, p.y - 10);
                        ctx.stroke();
                        // Spark
                        ctx.fillStyle = '#ff4500';
                        ctx.beginPath();
                        ctx.arc(p.x + 8, p.y - 10, 3, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        // Gun shape for ranged weapons
                        // Gun body (horizontal rectangle)
                        ctx.fillStyle = weapon.color;
                        ctx.fillRect(p.x - 8, p.y - 3, 16, 6);

                        // Gun handle
                        ctx.fillRect(p.x - 2, p.y + 3, 5, 5);

                        // Gun barrel highlight
                        ctx.fillStyle = '#fff';
                        ctx.fillRect(p.x + 4, p.y - 1, 4, 2);

                        // Label
                        ctx.fillStyle = '#fff';
                        ctx.font = 'bold 8px monospace';
                        ctx.fillText(weapon.label, p.x - 3, p.y + 1);
                    }
                }
                ctx.globalAlpha = 1;
            }

            // Draw boss warning zones (before enemies so they appear under them)
            for (const zone of bossWarningZones) {
                ctx.save();
                // Flashing effect as timer decreases
                const flash = Math.sin(zone.timer * 0.3) * 0.15 + 0.35;
                ctx.globalAlpha = flash;

                if (zone.type === 'circle') {
                    ctx.fillStyle = zone.color || '#ff0000';
                    ctx.beginPath();
                    ctx.arc(zone.x, zone.y, zone.radius, 0, Math.PI * 2);
                    ctx.fill();
                    // Border
                    ctx.globalAlpha = flash + 0.3;
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                } else if (zone.type === 'line') {
                    ctx.fillStyle = zone.color || '#ff0000';
                    const angle = Math.atan2(zone.endY - zone.y, zone.endX - zone.x);
                    const len = Math.hypot(zone.endX - zone.x, zone.endY - zone.y);
                    ctx.save();
                    ctx.translate(zone.x, zone.y);
                    ctx.rotate(angle);
                    ctx.fillRect(0, -zone.width / 2, len, zone.width);
                    // Border
                    ctx.globalAlpha = flash + 0.3;
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(0, -zone.width / 2, len, zone.width);
                    ctx.restore();
                }
                ctx.restore();
            }

            // Draw enemies with ground shadows
            for (const enemy of enemies) {
                ctx.globalAlpha = fogAlpha(enemy.x, enemy.y) * 0.3;
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.ellipse(enemy.x, enemy.y + enemy.height / 2 + 2, enemy.width * 0.6, Math.max(3, enemy.width * 0.15), 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = fogAlpha(enemy.x, enemy.y);
                drawEnemy(enemy);
                ctx.globalAlpha = 1;
            }

            // Draw player with ground shadow
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            ctx.ellipse(player.x, player.y + player.height / 2 + 3, player.width * 0.8, 4, 0, 0, Math.PI * 2);
            ctx.fill();
            drawPlayer();

            // Draw remote player in multiplayer
            if (gameState === 'multiplayer-playing' && remotePlayer.connected) {
                drawRemotePlayer();
            }

            // Draw bullets
            for (const b of bullets) {
                const bFog = fogAlpha(b.x, b.y);
                if (b.flame) {
                    // Draw flame as flickering fire
                    ctx.globalAlpha = (b.life / 25) * bFog;
                    ctx.fillStyle = Math.random() > 0.5 ? '#ff4500' : '#ff0';
                    ctx.beginPath();
                    ctx.arc(b.x, b.y, 6 + Math.random() * 3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                } else if (b.explosive) {
                    // Draw rocket
                    ctx.globalAlpha = bFog;
                    ctx.fillStyle = '#8b0000';
                    const angle = Math.atan2(b.vy, b.vx);
                    ctx.save();
                    ctx.translate(b.x, b.y);
                    ctx.rotate(angle);
                    ctx.fillRect(-6, -3, 12, 6);
                    ctx.fillStyle = '#556b2f';
                    ctx.fillRect(-8, -2, 4, 4);
                    ctx.fillStyle = '#ff4500';
                    ctx.fillRect(-10, -2, 3, 4);
                    ctx.restore();
                } else {
                    ctx.globalAlpha = bFog;
                    ctx.fillStyle = b.color || COLORS.bullet;
                    const size = b.pierce ? 10 : 6;
                    ctx.fillRect(b.x - size/2, b.y - size/2, size, size);
                }
                ctx.globalAlpha = 1;
            }

            // Draw particles
            for (const p of particles) {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life / 30;
                ctx.fillRect(p.x - 2, p.y - 2, 4, 4);
            }
            ctx.globalAlpha = 1;

            // Draw lighting overlay
            if (selectedDungeon) {
                const lighting = (DUNGEONS[selectedDungeon] || DUNGEONS.dungeon).lighting;
                const [lr, lg, lb] = lighting.ambientColor;

                // Clear previous frame and fill with ambient darkness
                lightCtx.clearRect(0, 0, lightCanvas.width, lightCanvas.height);
                lightCtx.globalCompositeOperation = 'source-over';
                lightCtx.fillStyle = `rgba(${lr},${lg},${lb},${lighting.darknessLevel})`;
                lightCtx.fillRect(0, 0, lightCanvas.width, lightCanvas.height);

                // Base visibility: punch a faint hole everywhere so distant areas aren't fully dark
                lightCtx.globalCompositeOperation = 'destination-out';
                lightCtx.fillStyle = 'rgba(0,0,0,0.18)';
                lightCtx.fillRect(0, 0, lightCanvas.width, lightCanvas.height);

                // Punch player light hole (additional clarity near player)
                const r = lighting.playerLightRadius * (isMobile ? 1.15 : 1);
                const grad = lightCtx.createRadialGradient(player.x, player.y, 0, player.x, player.y, r);
                grad.addColorStop(0, 'rgba(0,0,0,0.82)');
                grad.addColorStop(0.3, 'rgba(0,0,0,0.6)');
                grad.addColorStop(0.6, 'rgba(0,0,0,0.25)');
                grad.addColorStop(1, 'rgba(0,0,0,0)');
                lightCtx.fillStyle = grad;
                lightCtx.fillRect(player.x - r, player.y - r, r * 2, r * 2);

                // Punch environmental light holes (populated by ZS-ux5)
                if (typeof levelLights !== 'undefined') {
                    const now = Date.now();
                    for (const light of levelLights) {
                        const flicker = Math.sin(now / 200 + light.x + light.y) * 2;
                        const lr2 = light.radius + flicker;
                        const g2 = lightCtx.createRadialGradient(light.x, light.y, 0, light.x, light.y, lr2);
                        g2.addColorStop(0, `rgba(0,0,0,${light.intensity || 0.8})`);
                        g2.addColorStop(1, 'rgba(0,0,0,0)');
                        lightCtx.fillStyle = g2;
                        lightCtx.fillRect(light.x - lr2, light.y - lr2, lr2 * 2, lr2 * 2);
                    }
                }

                lightCtx.globalCompositeOperation = 'source-over';

                // Composite onto main canvas
                ctx.drawImage(lightCanvas, 0, 0);
            }

            // End isometric projection
            ctx.restore();

            // Draw game over / level complete
            if (gameState === 'gameover') {
                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#e74c3c';
                ctx.font = '48px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('GAME OVER', canvas.width/2, canvas.height/2);
                ctx.fillStyle = '#fff';
                ctx.font = '20px monospace';
                ctx.fillText(`Final Score: ${score}`, canvas.width/2, canvas.height/2 + 40);
                ctx.fillText('Press SPACE for menu', canvas.width/2, canvas.height/2 + 80);
                ctx.textAlign = 'left';
            }

            if (gameState === 'paused') {
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#fff';
                ctx.font = '48px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('PAUSED', canvas.width/2, canvas.height/2 - 40);
                ctx.font = '16px monospace';
                ctx.fillText('Press ESC or P to resume', canvas.width/2, canvas.height/2);

                // Exit to Menu button
                const exitBtnW = 150;
                const exitBtnH = 40;
                const exitBtnX = canvas.width/2 - exitBtnW/2;
                const exitBtnY = canvas.height/2 + 30;

                ctx.fillStyle = '#e74c3c';
                ctx.fillRect(exitBtnX, exitBtnY, exitBtnW, exitBtnH);
                ctx.fillStyle = '#c0392b';
                ctx.fillRect(exitBtnX + 3, exitBtnY + 3, exitBtnW - 6, exitBtnH - 6);
                ctx.fillStyle = '#fff';
                ctx.font = '14px monospace';
                ctx.fillText('EXIT & SAVE', canvas.width/2, exitBtnY + 26);

                // Store button for click detection
                menuButtons = [{ x: exitBtnX, y: exitBtnY, w: exitBtnW, h: exitBtnH, action: 'exitToMenu' }];
                ctx.textAlign = 'left';
            }

            if (gameState === 'levelcomplete') {
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#2ecc71';
                ctx.font = (isMobile ? '28' : '48') + 'px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('BUILDING CLEARED!', canvas.width/2, canvas.height/2);
                ctx.fillStyle = '#fff';
                ctx.font = (isMobile ? '14' : '20') + 'px monospace';
                ctx.fillText(`Entering Building ${currentLevel + 1}...`, canvas.width/2, canvas.height/2 + (isMobile ? 28 : 40));
                ctx.textAlign = 'left';
            }

            // Player health bar on screen
            ctx.fillStyle = '#333';
            ctx.fillRect(20, 20, 104, 14);
            ctx.fillStyle = player.health > 30 ? COLORS.health : '#e74c3c';
            ctx.fillRect(22, 22, (player.health / player.maxHealth) * 100, 10);

            // Scrap counter on screen (below health bar)
            if (gameState === 'playing' || gameState === 'multiplayer-playing') {
                ctx.fillStyle = '#95a5a6';
                ctx.font = '10px monospace';
                ctx.textAlign = 'left';
                ctx.fillText('S:' + scrap, 20, 48);

                // Multiplayer mode indicator
                if (gameState === 'multiplayer-playing') {
                    ctx.fillStyle = '#9b59b6';
                    ctx.font = '10px monospace';
                    ctx.textAlign = 'right';
                    const modeLabel = multiplayerMode === 'coop' ? 'CO-OP' : 'RACE';
                    ctx.fillText(modeLabel + (isHost ? ' (Host)' : ''), canvas.width - 20, 48);
                    // Connection status
                    ctx.fillStyle = remotePlayer.connected ? '#2ecc71' : '#e74c3c';
                    ctx.fillText(remotePlayer.connected ? 'P2 Connected' : 'P2 Disconnected', canvas.width - 20, 60);
                    ctx.textAlign = 'left';
                }

                // Charm icons
                for (let ci = 0; ci < playerCharms.length; ci++) {
                    const charm = CHARMS[playerCharms[ci]];
                    ctx.fillStyle = charm.color;
                    ctx.font = 'bold 9px monospace';
                    ctx.fillText(charm.icon, 60 + ci * 22, 48);
                }

                // Armor indicator
                if (playerArmorTier > 0) {
                    const at = ARMOR_TIERS[playerArmorTier - 1];
                    ctx.fillStyle = at.color;
                    ctx.font = '9px monospace';
                    ctx.fillText('A' + playerArmorTier, 128, 32);
                }

                // Music mute indicator
                ctx.fillStyle = Music.isMuted() ? '#e74c3c' : '#4ecdc4';
                ctx.font = '9px monospace';
                ctx.textAlign = 'right';
                ctx.fillText(Music.isMuted() ? '[M]ute' : '[M]usic', canvas.width - 20, isMobile ? 74 : 32);
                ctx.textAlign = 'left';

                // God mode indicator
                if (godMode) {
                    ctx.fillStyle = '#ff0';
                    ctx.font = 'bold 12px monospace';
                    ctx.fillText('GOD MODE', 20, 62);
                }

                // Boss health bar (at top of screen, centered)
                const boss = enemies.find(e => e.type === 'boss');
                if (boss) {
                    const barWidth = isMobile ? 280 : 400;
                    const barHeight = isMobile ? 16 : 20;
                    const barX = (canvas.width - barWidth) / 2;
                    const barY = isMobile ? 60 : 15;

                    // Boss name
                    const bossData = ENEMY_TYPES.boss;
                    ctx.fillStyle = '#fff';
                    ctx.font = isMobile ? 'bold 12px monospace' : 'bold 16px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText(bossData.name.toUpperCase(), canvas.width / 2, barY - 4);

                    // Background
                    ctx.fillStyle = '#222';
                    ctx.fillRect(barX - 2, barY, barWidth + 4, barHeight + 4);

                    // Health bar border
                    ctx.fillStyle = '#8b0000';
                    ctx.fillRect(barX, barY + 2, barWidth, barHeight);

                    // Health bar fill
                    const healthPercent = boss.health / boss.maxHealth;
                    const healthColor = healthPercent > 0.5 ? '#e74c3c' : (healthPercent > 0.25 ? '#ff6b35' : '#ff0000');
                    ctx.fillStyle = healthColor;
                    ctx.fillRect(barX, barY + 2, barWidth * healthPercent, barHeight);

                    // Health bar shine
                    ctx.fillStyle = 'rgba(255,255,255,0.2)';
                    ctx.fillRect(barX, barY + 2, barWidth * healthPercent, barHeight / 3);

                    // Health text
                    ctx.fillStyle = '#fff';
                    ctx.font = isMobile ? '10px monospace' : '12px monospace';
                    ctx.fillText(`${boss.health} / ${boss.maxHealth}`, canvas.width / 2, barY + barHeight - 2);

                    ctx.textAlign = 'left';
                }
            }
        }

        // Multiplayer connection functions
        function initializePeer() {
            if (peer) {
                peer.destroy();
            }
            peer = new Peer();
            peer.on('error', (err) => {
                console.error('Peer error:', err);
                if (err.type === 'peer-unavailable') {
                    alert('Room not found. Check the code and try again.');
                }
            });
            return peer;
        }

        function hostGame() {
            roomCode = generateRoomCode();
            // Create peer with room code as the ID so others can connect to it
            if (peer) {
                peer.destroy();
            }
            peer = new Peer(roomCode.toLowerCase());
            peer.on('error', (err) => {
                console.error('Peer error:', err);
                if (err.type === 'unavailable-id') {
                    // Room code already taken, generate a new one
                    roomCode = generateRoomCode();
                    hostGame();
                }
            });
            peer.on('open', (id) => {
                console.log('Hosting as:', roomCode, 'Peer ID:', id);
                isHost = true;
                gameState = 'hosting';
            });
            peer.on('connection', (connection) => {
                conn = connection;
                setupConnection(conn);
            });
        }

        function joinGame(code) {
            initializePeer();
            peer.on('open', (id) => {
                console.log('Joining room:', code);
                isHost = false;
                conn = peer.connect(code.toLowerCase());
                setupConnection(conn);
            });
        }

        function setupConnection(connection) {
            connection.on('open', () => {
                console.log('Connection established!');
                remotePlayer.connected = true;
                if (!isHost) {
                    gameState = 'waiting-for-host';
                }
            });
            connection.on('data', (data) => {
                handleNetworkData(data);
            });
            connection.on('close', () => {
                console.log('Connection closed');
                remotePlayer.connected = false;
                if (gameState === 'multiplayer-playing') {
                    alert('Other player disconnected!');
                    cleanupMultiplayer();
                    gameState = 'menu';
                }
            });
        }

        function handleNetworkData(data) {
            if (data.type === 'player_state') {
                remotePlayer.x = data.x;
                remotePlayer.y = data.y;
                remotePlayer.angle = data.angle;
                remotePlayer.health = data.health;
                remotePlayer.maxHealth = data.maxHealth;
                remotePlayer.weapon = data.weapon;
                remotePlayer.swinging = data.swinging;
                remotePlayer.swingProgress = data.swingProgress;
            } else if (data.type === 'bullets') {
                remoteBullets = data.bullets;
            } else if (data.type === 'mode_selected') {
                multiplayerMode = data.mode;
                startMultiplayerGame(data.dungeon);
            } else if (data.type === 'game_state') {
                // Sync game state from host
                if (!isHost) {
                    enemies = data.enemies || enemies;
                    G.enemies = enemies;
                }
            } else if (data.type === 'level_complete') {
                // Handle level completion sync
                if (!isHost) {
                    currentLevel = data.level;
                    generateLevel(currentLevel);
                }
            }
        }

        function sendPlayerState() {
            if (conn && conn.open) {
                conn.send({
                    type: 'player_state',
                    x: player.x,
                    y: player.y,
                    angle: player.angle,
                    health: player.health,
                    maxHealth: player.maxHealth,
                    weapon: player.weapon,
                    swinging: player.swinging,
                    swingProgress: player.swingProgress
                });
            }
        }

        function sendBullets() {
            if (conn && conn.open && isHost) {
                conn.send({
                    type: 'bullets',
                    bullets: bullets.map(b => ({
                        x: b.x, y: b.y, vx: b.vx, vy: b.vy,
                        isPlayer: b.isPlayer, color: b.color
                    }))
                });
            }
        }

        function sendGameState() {
            if (conn && conn.open && isHost) {
                conn.send({
                    type: 'game_state',
                    enemies: enemies.map(e => ({
                        x: e.x, y: e.y, health: e.health, maxHealth: e.maxHealth,
                        type: e.type, width: e.width, height: e.height
                    }))
                });
            }
        }

        function startMultiplayerGame(dungeonKey) {
            clearSavedRun();
            resetRunState();
            applyDungeonTheme(dungeonKey);
            score = 0;
            currentLevel = 1;
            // Apply class bonuses
            const cls = CLASSES[selectedClass] || CLASSES.default;
            player.weapon = cls.weapon;
            player.maxHealth = cls.health;
            player.health = cls.health;
            player.speed = cls.speed;
            const mpColor = COLOR_OPTIONS[selectedColorIdx] || COLOR_OPTIONS[0];
            COLORS.player = mpColor.color;
            COLORS.playerDark = mpColor.colorDark;
            const weaponData = WEAPONS[cls.weapon];
            if (weaponData.melee || weaponData.placeable) {
                player.maxAmmo = weaponData.maxAmmo || 0;
                player.ammo = player.maxAmmo;
            } else {
                player.maxAmmo = weaponData.maxAmmo;
                player.ammo = player.maxAmmo;
            }
            generateLevel(1);
            gameState = 'multiplayer-playing';
        }

        function cleanupMultiplayer() {
            if (conn) {
                conn.close();
                conn = null;
            }
            if (peer) {
                peer.destroy();
                peer = null;
            }
            isHost = false;
            roomCode = '';
            roomCodeInput = '';
            multiplayerMode = null;
            remotePlayer.connected = false;
        }

        function handleMultiplayerMenuClick(clickX, clickY) {
            for (const btn of menuButtons) {
                if (clickX >= btn.x && clickX <= btn.x + btn.w &&
                    clickY >= btn.y && clickY <= btn.y + btn.h) {
                    if (btn.action === 'back') {
                        gameState = 'menu';
                        return;
                    } else if (btn.action === 'mp_host') {
                        hostGame();
                        return;
                    } else if (btn.action === 'mp_join') {
                        gameState = 'joining';
                        roomCodeInput = '';
                        return;
                    } else if (btn.action === 'mp_cancel') {
                        cleanupMultiplayer();
                        gameState = 'menu';
                        return;
                    } else if (btn.action === 'mp_mode_select') {
                        gameState = 'mode-select';
                        return;
                    } else if (btn.action === 'mp_coop') {
                        multiplayerMode = 'coop';
                        // Send mode selection to client with default dungeon
                        if (conn && conn.open) {
                            conn.send({ type: 'mode_selected', mode: 'coop', dungeon: 'jungle' });
                        }
                        startMultiplayerGame('jungle');
                        return;
                    } else if (btn.action === 'mp_race') {
                        multiplayerMode = 'race';
                        // Send mode selection to client with default dungeon
                        if (conn && conn.open) {
                            conn.send({ type: 'mode_selected', mode: 'race', dungeon: 'jungle' });
                        }
                        startMultiplayerGame('jungle');
                        return;
                    }
                }
            }
        }

        // Game loop
        let lastFrameTime = 0;
        const TICK_INTERVAL = 1000 / 100;
        let accumulator = 0;
        function gameLoop(timestamp) {
            requestAnimationFrame(gameLoop);
            if (!lastFrameTime) { lastFrameTime = timestamp; return; }
            const elapsed = Math.min(timestamp - lastFrameTime, 200);
            lastFrameTime = timestamp;
            accumulator += elapsed;

            // Music: play during gameplay, stop otherwise
            const musicStates = ['playing', 'multiplayer-playing', 'runshop', 'paused'];
            if (musicStates.includes(gameState)) {
                if (!Music.isPlaying()) Music.play();
            } else {
                if (Music.isPlaying()) Music.stop();
            }

            // Sync state to G for extracted modules
            G.gameState = gameState;
            G.selectedDungeon = selectedDungeon;
            G.currentLevel = currentLevel;
            G.score = score;
            G.mouseX = mouseX;
            G.mouseY = mouseY;
            G.mouseDown = mouseDown;
            G.playerArmor = playerArmor;
            G.playerArmorTier = playerArmorTier;
            G.currentDamageMult = currentDamageMult;
            G.ENEMY_TYPES = ENEMY_TYPES;
            // Re-sync arrays (generateLevel reassigns them to new arrays)
            G.walls = walls;
            G.enemies = enemies;
            G.bullets = bullets;
            G.particles = particles;
            G.pickups = pickups;
            G.bombs = bombs;
            G.floorDecorations = floorDecorations;
            G.levelProps = levelProps;
            G.remotePlayer = remotePlayer;

            // Handle multiplayer sync
            if (gameState === 'multiplayer-playing' && conn && conn.open) {
                const now = Date.now();
                if (now - lastSyncTime >= SYNC_INTERVAL) {
                    lastSyncTime = now;
                    sendPlayerState();
                    if (isHost) {
                        sendGameState();
                        sendBullets();
                    }
                }
            }

            while (accumulator >= TICK_INTERVAL) {
                updatePlayer();
                updateEnemies();
                updateBullets();
                updateBombs();
                updateParticles();
                spawnAmbientParticles();
                checkLevelComplete();
                accumulator -= TICK_INTERVAL;
            }
            draw();
        }

        // Cheat code buffer
        let cheatBuffer = '';
        const CHEAT_SKIP = 'gg';
        const CHEAT_GOD = 'ee';
        let godMode = false;

        // Event listeners
        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;

            // Handle room code input when joining
            if (gameState === 'joining') {
                if (e.key === 'Backspace') {
                    roomCodeInput = roomCodeInput.slice(0, -1);
                    return;
                } else if (e.key === 'Escape') {
                    cleanupMultiplayer();
                    gameState = 'menu';
                    return;
                } else if (e.key.length === 1 && /[a-zA-Z0-9]/.test(e.key)) {
                    if (roomCodeInput.length < 4) {
                        roomCodeInput += e.key.toUpperCase();
                        // Auto-connect when 4 characters entered
                        if (roomCodeInput.length === 4) {
                            joinGame(roomCodeInput);
                        }
                    }
                    return;
                }
            }

            // Cheat code detection - works in all states
            cheatBuffer += e.key.toLowerCase();
            if (cheatBuffer.length > 10) cheatBuffer = cheatBuffer.slice(-10);
            console.log('Key pressed:', e.key, 'Buffer:', cheatBuffer, 'State:', gameState);
            if (cheatBuffer.endsWith(CHEAT_SKIP) && (gameState === 'playing' || gameState === 'multiplayer-playing')) {
                cheatBuffer = '';
                enemies.length = 0;
                console.log('CHEAT: Enemies cleared!');
            }
            if (cheatBuffer.endsWith(CHEAT_GOD)) {
                cheatBuffer = '';
                godMode = true;
                player.weapon = 'flamethrower';
                player.ammo = 999;
                player.maxAmmo = 999;
                player.health = 9999;
                player.maxHealth = 9999;
                console.log('GOD MODE ACTIVATED!');
            }
            if (e.key === ' ' && gameState === 'gameover') {
                clearSavedRun();
                resetRunState();
                gameState = 'menu';
            }
            if (e.key === 'm' || e.key === 'M') {
                Music.toggleMute();
            }
            if ((e.key === 'Escape' || e.key === 'p') && (gameState === 'playing' || gameState === 'paused' || gameState === 'multiplayer-playing')) {
                if (gameState === 'multiplayer-playing') {
                    // In multiplayer, escape disconnects
                    cleanupMultiplayer();
                    gameState = 'menu';
                } else {
                    gameState = gameState === 'paused' ? 'playing' : 'paused';
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            mouseX = (e.clientX - rect.left) * scaleX;
            mouseY = (e.clientY - rect.top) * scaleY;
        });

        canvas.addEventListener('mousedown', (e) => {
            Music.ensureContext();
            mouseDown = true;
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const clickX = (e.clientX - rect.left) * scaleX;
            const clickY = (e.clientY - rect.top) * scaleY;

            if (gameState === 'menu') {
                for (const btn of menuButtons) {
                    if (clickX >= btn.x && clickX <= btn.x + btn.w &&
                        clickY >= btn.y && clickY <= btn.y + btn.h) {
                        if (btn.action === 'shop') {
                            gameState = 'shop';
                            break;
                        } else if (btn.action === 'donate') {
                            window.location.href = 'donate.html';
                            break;
                        } else if (btn.action === 'multiplayer') {
                            gameState = 'multiplayer-menu';
                            break;
                        } else if (btn.action === 'continue') {
                            // Continue saved run
                            if (loadRun()) {
                                gameState = 'playing';
                            }
                            break;
                        } else if (btn.dungeon) {
                            pendingDungeon = btn.dungeon;
                            gameState = 'charselect';
                            break;
                        }
                    }
                }
            } else if (gameState === 'charselect') {
                for (const btn of charSelectButtons) {
                    if (clickX >= btn.x && clickX <= btn.x + btn.w &&
                        clickY >= btn.y && clickY <= btn.y + btn.h) {
                        if (btn.action === 'back') {
                            gameState = 'menu';
                            break;
                        } else if (btn.action === 'play') {
                            // Start the run with selected character
                            clearSavedRun();
                            resetRunState();
                            applyDungeonTheme(pendingDungeon);
                            score = 0;
                            currentLevel = 1;
                            const cls = CLASSES[selectedClass] || CLASSES.default;
                            player.weapon = cls.weapon;
                            player.maxHealth = cls.health;
                            player.health = cls.health;
                            player.speed = cls.speed;
                            const playColor = COLOR_OPTIONS[selectedColorIdx] || COLOR_OPTIONS[0];
                            COLORS.player = playColor.color;
                            COLORS.playerDark = playColor.colorDark;
                            const weaponData = WEAPONS[cls.weapon];
                            if (weaponData.melee || weaponData.placeable) {
                                player.maxAmmo = weaponData.maxAmmo || 0;
                                player.ammo = player.maxAmmo;
                            } else {
                                player.maxAmmo = weaponData.maxAmmo;
                                player.ammo = player.maxAmmo;
                            }
                            generateLevel(1);
                            gameState = 'playing';
                            break;
                        } else if (btn.classKey) {
                            selectedClass = btn.classKey;
                            saveProgress();
                            break;
                        } else if (btn.colorIdx !== undefined) {
                            selectedColorIdx = btn.colorIdx;
                            saveProgress();
                            break;
                        }
                    }
                }
            } else if (gameState === 'multiplayer-menu' || gameState === 'hosting' || gameState === 'joining' || gameState === 'mode-select' || gameState === 'waiting-for-host') {
                handleMultiplayerMenuClick(clickX, clickY);
            } else if (gameState === 'paused') {
                for (const btn of menuButtons) {
                    if (clickX >= btn.x && clickX <= btn.x + btn.w &&
                        clickY >= btn.y && clickY <= btn.y + btn.h) {
                        if (btn.action === 'exitToMenu') {
                            saveRun();
                            gameState = 'menu';
                            break;
                        }
                    }
                }
            } else if (gameState === 'shop') {
                for (const btn of menuButtons) {
                    if (clickX >= btn.x && clickX <= btn.x + btn.w &&
                        clickY >= btn.y && clickY <= btn.y + btn.h) {
                        if (btn.action === 'back') {
                            gameState = 'menu';
                            break;
                        } else if (btn.classKey) {
                            const cls = CLASSES[btn.classKey];
                            if (unlockedClasses.includes(btn.classKey)) {
                                // Select this class
                                selectedClass = btn.classKey;
                                saveProgress();
                            } else if (coins >= cls.price) {
                                // Buy this class
                                coins -= cls.price;
                                unlockedClasses.push(btn.classKey);
                                selectedClass = btn.classKey;
                                saveProgress();
                            }
                            break;
                        }
                    }
                }
            } else if (gameState === 'runshop') {
                handleRunShopClick(clickX, clickY);
            }
        });
        canvas.addEventListener('mouseup', () => mouseDown = false);
        canvas.addEventListener('contextmenu', (e) => e.preventDefault());

        // Touch controls for mobile
        let touchMove = { x: 0, y: 0 };
        let touchAim = { x: 0, y: 0 };
        let leftTouchId = null;
        let rightTouchId = null;

        if (isMobile) {
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                Music.ensureContext();
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;

                for (const touch of e.changedTouches) {
                    const tx = (touch.clientX - rect.left) * scaleX;
                    const ty = (touch.clientY - rect.top) * scaleY;

                    // Handle menu selection
                    if (gameState === 'menu') {
                        for (const btn of menuButtons) {
                            if (tx >= btn.x && tx <= btn.x + btn.w &&
                                ty >= btn.y && ty <= btn.y + btn.h) {
                                if (btn.action === 'shop') {
                                    gameState = 'shop';
                                    return;
                                } else if (btn.action === 'donate') {
                                    window.location.href = 'donate.html';
                                    return;
                                } else if (btn.action === 'multiplayer') {
                                    gameState = 'multiplayer-menu';
                                    return;
                                } else if (btn.action === 'continue') {
                                    if (loadRun()) {
                                        gameState = 'playing';
                                    }
                                    return;
                                } else if (btn.dungeon) {
                                    pendingDungeon = btn.dungeon;
                                    gameState = 'charselect';
                                    return;
                                }
                            }
                        }
                        return;
                    }

                    // Handle character select
                    if (gameState === 'charselect') {
                        for (const btn of charSelectButtons) {
                            if (tx >= btn.x && tx <= btn.x + btn.w &&
                                ty >= btn.y && ty <= btn.y + btn.h) {
                                if (btn.action === 'back') {
                                    gameState = 'menu';
                                    return;
                                } else if (btn.action === 'play') {
                                    clearSavedRun();
                                    resetRunState();
                                    applyDungeonTheme(pendingDungeon);
                                    score = 0;
                                    currentLevel = 1;
                                    const cls = CLASSES[selectedClass] || CLASSES.default;
                                    player.weapon = cls.weapon;
                                    player.maxHealth = cls.health;
                                    player.health = cls.health;
                                    player.speed = cls.speed;
                                    const touchColor = COLOR_OPTIONS[selectedColorIdx] || COLOR_OPTIONS[0];
                                    COLORS.player = touchColor.color;
                                    COLORS.playerDark = touchColor.colorDark;
                                    const weaponData = WEAPONS[cls.weapon];
                                    if (weaponData.melee || weaponData.placeable) {
                                        player.maxAmmo = weaponData.maxAmmo || 0;
                                        player.ammo = player.maxAmmo;
                                    } else {
                                        player.maxAmmo = weaponData.maxAmmo;
                                        player.ammo = player.maxAmmo;
                                    }
                                    generateLevel(1);
                                    gameState = 'playing';
                                    return;
                                } else if (btn.classKey) {
                                    selectedClass = btn.classKey;
                                    saveProgress();
                                    return;
                                } else if (btn.colorIdx !== undefined) {
                                    selectedColorIdx = btn.colorIdx;
                                    saveProgress();
                                    return;
                                }
                            }
                        }
                        return;
                    }

                    // Handle multiplayer menu selection
                    if (gameState === 'multiplayer-menu' || gameState === 'hosting' || gameState === 'joining' || gameState === 'mode-select' || gameState === 'waiting-for-host') {
                        handleMultiplayerMenuClick(tx, ty);
                        return;
                    }

                    // Handle paused exit button
                    if (gameState === 'paused') {
                        for (const btn of menuButtons) {
                            if (tx >= btn.x && tx <= btn.x + btn.w &&
                                ty >= btn.y && ty <= btn.y + btn.h) {
                                if (btn.action === 'exitToMenu') {
                                    saveRun();
                                    gameState = 'menu';
                                    return;
                                }
                            }
                        }
                        return;
                    }

                    // Handle shop selection
                    if (gameState === 'shop') {
                        for (const btn of menuButtons) {
                            if (tx >= btn.x && tx <= btn.x + btn.w &&
                                ty >= btn.y && ty <= btn.y + btn.h) {
                                if (btn.action === 'back') {
                                    gameState = 'menu';
                                    return;
                                } else if (btn.classKey) {
                                    const cls = CLASSES[btn.classKey];
                                    if (unlockedClasses.includes(btn.classKey)) {
                                        selectedClass = btn.classKey;
                                        saveProgress();
                                    } else if (coins >= cls.price) {
                                        coins -= cls.price;
                                        unlockedClasses.push(btn.classKey);
                                        selectedClass = btn.classKey;
                                        saveProgress();
                                    }
                                    return;
                                }
                            }
                        }
                        return;
                    }

                    // Handle run shop selection
                    if (gameState === 'runshop') {
                        handleRunShopClick(tx, ty);
                        return;
                    }

                    // Left half = movement, Right half = aim and shoot
                    if (tx < W / 2) {
                        leftTouchId = touch.identifier;
                        touchMove.startX = tx;
                        touchMove.startY = ty;
                        touchMove.x = 0;
                        touchMove.y = 0;
                    } else {
                        rightTouchId = touch.identifier;
                        touchAim.x = tx;
                        touchAim.y = ty;
                        mouseX = tx;
                        mouseY = ty;
                        mouseDown = true;
                    }
                }

                if (gameState === 'gameover') {
                    clearSavedRun();
                    resetRunState();
                    gameState = 'menu';
                }
            });

            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;

                for (const touch of e.changedTouches) {
                    const tx = (touch.clientX - rect.left) * scaleX;
                    const ty = (touch.clientY - rect.top) * scaleY;

                    if (touch.identifier === leftTouchId) {
                        touchMove.x = (tx - touchMove.startX) / 30;
                        touchMove.y = (ty - touchMove.startY) / 30;
                        // Clamp
                        const mag = Math.hypot(touchMove.x, touchMove.y);
                        if (mag > 1) {
                            touchMove.x /= mag;
                            touchMove.y /= mag;
                        }
                    } else if (touch.identifier === rightTouchId) {
                        mouseX = tx;
                        mouseY = ty;
                    }
                }
            });

            canvas.addEventListener('touchend', (e) => {
                e.preventDefault();
                for (const touch of e.changedTouches) {
                    if (touch.identifier === leftTouchId) {
                        leftTouchId = null;
                        touchMove.x = 0;
                        touchMove.y = 0;
                    } else if (touch.identifier === rightTouchId) {
                        rightTouchId = null;
                        mouseDown = false;
                    }
                }
            });
        }

        // Start game (menu will handle level generation)
        gameLoop();
    </script>
</body>
</html>
