<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Building Clearer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        html, body {
            width: 100%;
            height: 100%;
            overflow-x: hidden;
        }
        body {
            background: #1a1a2e;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: monospace;
        }
        #gameContainer {
            text-align: center;
            width: 100%;
            max-width: 100%;
            padding: 10px;
        }
        canvas {
            border: 4px solid #4a4a6a;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            max-width: 100%;
            height: auto;
            display: block;
            margin: 0 auto;
        }
        #ui {
            color: #fff;
            margin-top: 10px;
            font-size: 14px;
        }
        #instructions {
            color: #888;
            margin-top: 10px;
            font-size: 11px;
            word-wrap: break-word;
        }
        .mobile-only {
            display: none;
        }
        @media (max-width: 600px), (max-aspect-ratio: 1/1) {
            .desktop-only {
                display: none;
            }
            .mobile-only {
                display: block;
                color: #888;
                margin-top: 10px;
                font-size: 11px;
            }
            #ui {
                font-size: 12px;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="game" width="640" height="480"></canvas>
        <div id="ui">
            <span id="health">Health: 100</span> |
            <span id="ammo">Ammo: 30</span> |
            <span id="score">Score: 0</span> |
            <span id="level">Building: 1</span>
        </div>
        <div id="instructions" class="desktop-only">
            WASD to move | Mouse to aim | Click to shoot | R to reload | Clear all enemies to advance!
        </div>
        <div id="instructions-mobile" class="mobile-only">
            Left side: drag to move | Right side: tap to aim & shoot
        </div>
    </div>

    <script>
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false;

        // Detect mobile (portrait) vs desktop (landscape)
        const isMobile = window.innerWidth < 600 || (window.innerWidth < window.innerHeight);

        // Set canvas size based on device
        if (isMobile) {
            canvas.width = 360;
            canvas.height = 640;
        } else {
            canvas.width = 640;
            canvas.height = 480;
        }

        const W = canvas.width;
        const H = canvas.height;

        // Game state
        let gameState = 'menu'; // menu, shop, runshop, playing, gameover, levelcomplete, paused
        let selectedDungeon = null;
        let score = 0;
        let currentLevel = 1;

        // Coins and shop system
        let coins = parseInt(localStorage.getItem('coins')) || 0;
        let selectedClass = localStorage.getItem('selectedClass') || 'default';
        let unlockedClasses = JSON.parse(localStorage.getItem('unlockedClasses')) || ['default'];

        // Run-only currency and upgrades (reset on death)
        let scrap = 0;
        let playerArmor = 0;        // damage reduction fraction (0 to 0.45)
        let playerArmorTier = 0;     // 0=none, 1=leather, 2=chain, 3=plate
        let playerCharms = [];       // array of charm ids, max 3
        let runShopInventory = [];   // items available in current run shop
        let regenTimer = 0;          // tick counter for regen aura

        // Class definitions
        const CLASSES = {
            default: { name: 'Rookie', description: 'No bonuses', price: 0, weapon: 'pistol', health: 100, speed: 1.5, ammoBonus: 0 },
            soldier: { name: 'Soldier', description: 'Start with SMG', price: 100, weapon: 'smg', health: 100, speed: 1.5, ammoBonus: 0 },
            tank: { name: 'Tank', description: '+50 Health, slower', price: 150, weapon: 'pistol', health: 150, speed: 1.2, ammoBonus: 0 },
            scout: { name: 'Scout', description: 'Faster movement', price: 120, weapon: 'pistol', health: 80, speed: 2.0, ammoBonus: 0 },
            gunner: { name: 'Gunner', description: 'Start with Shotgun', price: 200, weapon: 'shotgun', health: 100, speed: 1.4, ammoBonus: 0 },
            sniper: { name: 'Marksman', description: 'Start with Sniper', price: 300, weapon: 'sniper', health: 90, speed: 1.5, ammoBonus: 0 },
            pyro: { name: 'Pyro', description: 'Start with Flamethrower', price: 350, weapon: 'flamethrower', health: 100, speed: 1.5, ammoBonus: 0 },
            demoman: { name: 'Demoman', description: 'Start with Bombs', price: 400, weapon: 'bomb', health: 110, speed: 1.3, ammoBonus: 0 },
            samurai: { name: 'Samurai', description: 'Start with Katana', price: 250, weapon: 'katana', health: 90, speed: 1.7, ammoBonus: 0 }
        };

        function saveProgress() {
            localStorage.setItem('coins', coins);
            localStorage.setItem('selectedClass', selectedClass);
            localStorage.setItem('unlockedClasses', JSON.stringify(unlockedClasses));
        }

        // Save/load run state
        let savedRun = JSON.parse(localStorage.getItem('savedRun')) || null;

        function saveRun() {
            savedRun = {
                level: currentLevel,
                health: player.health,
                maxHealth: player.maxHealth,
                weapon: player.weapon,
                ammo: player.ammo,
                maxAmmo: player.maxAmmo,
                score: score,
                dungeon: selectedDungeon,
                speed: player.speed,
                scrap: scrap,
                playerArmor: playerArmor,
                playerArmorTier: playerArmorTier,
                playerCharms: playerCharms
            };
            localStorage.setItem('savedRun', JSON.stringify(savedRun));
        }

        function clearSavedRun() {
            savedRun = null;
            localStorage.removeItem('savedRun');
        }

        function loadRun() {
            if (!savedRun) return false;
            currentLevel = savedRun.level;
            player.health = savedRun.health;
            player.maxHealth = savedRun.maxHealth;
            player.weapon = savedRun.weapon;
            player.ammo = savedRun.ammo;
            player.maxAmmo = savedRun.maxAmmo;
            player.speed = savedRun.speed || 1.5;
            score = savedRun.score;
            scrap = savedRun.scrap || 0;
            playerArmor = savedRun.playerArmor || 0;
            playerArmorTier = savedRun.playerArmorTier || 0;
            playerCharms = savedRun.playerCharms || [];
            applyDungeonTheme(savedRun.dungeon);
            generateLevel(currentLevel);
            // Restore health after generateLevel (which might reset it)
            player.health = savedRun.health;
            return true;
        }

        // Player
        const player = {
            x: 320,
            y: 400,
            width: 16,
            height: 16,
            speed: 1.5,
            health: 100,
            maxHealth: 100,
            ammo: 12,
            maxAmmo: 12,
            angle: 0,
            reloading: false,
            reloadTime: 0,
            shootCooldown: 0,
            weapon: 'pistol',
            swinging: false,
            swingAngle: 0,
            swingProgress: 0
        };

        // Weapon definitions
        const WEAPONS = {
            pistol: { fireRate: 35, ammoUse: 1, maxAmmo: 12, color: '#f39c12', label: 'P' },
            smg: { fireRate: 12, ammoUse: 1, maxAmmo: 40, damage: 10, color: '#3498db', label: 'M' },
            shotgun: { fireRate: 45, ammoUse: 3, maxAmmo: 18, spread: 5, pellets: 5, color: '#e67e22', label: 'S' },
            rifle: { fireRate: 20, ammoUse: 1, maxAmmo: 20, damage: 35, color: '#1abc9c', label: 'F' },
            railgun: { fireRate: 70, ammoUse: 4, maxAmmo: 16, pierce: true, color: '#9b59b6', label: 'R' },
            minigun: { fireRate: 6, ammoUse: 1, maxAmmo: 100, damage: 5, color: '#e74c3c', label: 'G' },
            sword: { fireRate: 30, damage: 40, range: 45, arc: Math.PI/2, melee: true, color: '#c0c0c0', label: 'W' },
            katana: { fireRate: 18, damage: 25, range: 55, arc: Math.PI/3, melee: true, color: '#e8e8e8', label: 'K' },
            sniper: { fireRate: 90, ammoUse: 1, maxAmmo: 8, damage: 150, color: '#2c3e50', label: 'N' },
            flamethrower: { fireRate: 5, ammoUse: 1, maxAmmo: 80, damage: 3, flame: true, color: '#ff4500', label: 'T' },
            rocketlauncher: { fireRate: 80, ammoUse: 1, maxAmmo: 6, damage: 80, explosive: true, explosionRadius: 60, color: '#556b2f', label: 'L' },
            bomb: { fireRate: 60, ammoUse: 1, maxAmmo: 3, damage: 150, explosionRadius: 100, placeable: true, fuseTime: 180, color: '#1a1a1a', label: 'B' }
        };
        const WEAPON_LIST = ['pistol', 'smg', 'shotgun', 'rifle', 'railgun', 'minigun', 'sword', 'katana', 'sniper', 'flamethrower', 'rocketlauncher', 'bomb'];

        // Armor tiers for run shop
        const ARMOR_TIERS = [
            { tier: 1, name: 'Leather Vest',  dr: 0.15, price: 30,  color: '#8b5e3c' },
            { tier: 2, name: 'Chain Mail',     dr: 0.30, price: 70,  color: '#a0a0a0' },
            { tier: 3, name: 'Plate Armor',    dr: 0.45, price: 120, color: '#c0c8d0' }
        ];

        // Charms (max 3 held at once)
        const CHARMS = {
            swift_boots:   { name: 'Swift Boots',   desc: '+20% speed',        price: 40, type: 'passive', icon: 'SB', color: '#3498db' },
            regen_aura:    { name: 'Regen Aura',    desc: '1 HP / 3s',         price: 50, type: 'passive', icon: 'RA', color: '#2ecc71' },
            big_magazines: { name: 'Big Magazines',  desc: '+50% ammo cap',    price: 35, type: 'passive', icon: 'BM', color: '#f1c40f' },
            thick_skin:    { name: 'Thick Skin',    desc: '+25 max HP',        price: 45, type: 'passive', icon: 'TS', color: '#e67e22' },
            vampiric_fang: { name: 'Vampiric Fang', desc: 'Heal 5 HP on kill', price: 60, type: 'onkill',  icon: 'VF', color: '#e74c3c' },
            scrap_magnet:  { name: 'Scrap Magnet',  desc: '+1 scrap / kill',   price: 45, type: 'onkill',  icon: 'SM', color: '#95a5a6' },
            boom_skull:    { name: 'Boom Skull',     desc: 'Explode on kill',  price: 75, type: 'onkill',  icon: 'BS', color: '#ff4500' }
        };

        // Run shop weapon prices (level-gated)
        const RUN_SHOP_WEAPONS = [
            { weapon: 'smg',             price: 25, minLevel: 1 },
            { weapon: 'shotgun',         price: 30, minLevel: 1 },
            { weapon: 'rifle',           price: 35, minLevel: 2 },
            { weapon: 'sword',           price: 30, minLevel: 2 },
            { weapon: 'katana',          price: 40, minLevel: 3 },
            { weapon: 'railgun',         price: 50, minLevel: 3 },
            { weapon: 'minigun',         price: 55, minLevel: 4 },
            { weapon: 'sniper',          price: 60, minLevel: 3 },
            { weapon: 'flamethrower',    price: 55, minLevel: 4 },
            { weapon: 'rocketlauncher',  price: 80, minLevel: 5 },
            { weapon: 'bomb',            price: 45, minLevel: 4 }
        ];

        // Enemy types per dungeon
        const DUNGEON_ENEMIES = {
            jungle: {
                grunt: { name: 'Tribesman', color: '#5d8a3e', colorDark: '#4a7030', speed: 1, health: 40, size: 18, shootDist: 120, canShoot: true },
                charger: { name: 'Jaguar', color: '#c9a227', colorDark: '#a68520', speed: 2.0, health: 25, size: 16, shootDist: 0, canShoot: false },
                boss: { name: 'Shaman', color: '#2d5a27', colorDark: '#1e3d1a', speed: 0.5, health: 500, size: 48, shootDist: 200, canShoot: true },
                tank: { name: 'Gorilla', color: '#4a4a4a', colorDark: '#333333', speed: 0.6, health: 130, size: 28, shootDist: 80, canShoot: true },
                sniper: { name: 'Hunter', color: '#8b4513', colorDark: '#6b3510', speed: 0.8, health: 30, size: 16, shootDist: 250, canShoot: true }
            },
            desert: {
                grunt: { name: 'Mummy', color: '#c4a35a', colorDark: '#a68b4b', speed: 0.9, health: 50, size: 18, shootDist: 110, canShoot: true },
                charger: { name: 'Scarab', color: '#1a1a2e', colorDark: '#0d0d17', speed: 2.2, health: 20, size: 14, shootDist: 0, canShoot: false },
                boss: { name: 'Pharaoh', color: '#ffd700', colorDark: '#b8860b', speed: 0.4, health: 550, size: 50, shootDist: 220, canShoot: true },
                tank: { name: 'Sand Golem', color: '#d4a574', colorDark: '#b8956a', speed: 0.5, health: 140, size: 30, shootDist: 90, canShoot: true },
                sniper: { name: 'Desert Archer', color: '#8b7355', colorDark: '#6b5a45', speed: 0.9, health: 28, size: 16, shootDist: 270, canShoot: true }
            },
            ice: {
                grunt: { name: 'Frost Knight', color: '#5a8fa8', colorDark: '#4a7a8f', speed: 0.9, health: 45, size: 20, shootDist: 120, canShoot: true },
                charger: { name: 'Ice Wolf', color: '#a8c8d8', colorDark: '#8ab0c0', speed: 1.9, health: 28, size: 18, shootDist: 0, canShoot: false },
                boss: { name: 'Frost Giant', color: '#4a90a8', colorDark: '#3a7088', speed: 0.4, health: 600, size: 54, shootDist: 180, canShoot: true },
                tank: { name: 'Yeti', color: '#e8f0f0', colorDark: '#c8d8d8', speed: 0.55, health: 150, size: 30, shootDist: 100, canShoot: true },
                sniper: { name: 'Ice Mage', color: '#87ceeb', colorDark: '#5f9ea0', speed: 0.7, health: 25, size: 16, shootDist: 280, canShoot: true }
            },
            volcano: {
                grunt: { name: 'Fire Imp', color: '#ff6b35', colorDark: '#cc5528', speed: 1.2, health: 35, size: 16, shootDist: 130, canShoot: true },
                charger: { name: 'Hellhound', color: '#8b0000', colorDark: '#5c0000', speed: 2.1, health: 30, size: 18, shootDist: 0, canShoot: false },
                boss: { name: 'Fire Dragon', color: '#ff4500', colorDark: '#cc3700', speed: 0.6, health: 650, size: 56, shootDist: 250, canShoot: true },
                tank: { name: 'Lava Golem', color: '#ff8c00', colorDark: '#cc7000', speed: 0.45, health: 160, size: 32, shootDist: 90, canShoot: true },
                sniper: { name: 'Fire Mage', color: '#ff1493', colorDark: '#cc1076', speed: 0.85, health: 28, size: 16, shootDist: 260, canShoot: true }
            },
            dungeon: {
                grunt: { name: 'Guard', color: '#e74c3c', colorDark: '#c0392b', speed: 1, health: 40, size: 18, shootDist: 120, canShoot: true },
                charger: { name: 'Goblin', color: '#2ecc71', colorDark: '#27ae60', speed: 1.8, health: 25, size: 16, shootDist: 0, canShoot: false },
                boss: { name: 'Dark Knight', color: '#4a4a6a', colorDark: '#3a3a5a', speed: 0.5, health: 500, size: 48, shootDist: 200, canShoot: true },
                tank: { name: 'Ogre', color: '#e67e22', colorDark: '#d35400', speed: 0.6, health: 120, size: 26, shootDist: 100, canShoot: true },
                sniper: { name: 'Dark Mage', color: '#9b59b6', colorDark: '#8e44ad', speed: 0.8, health: 30, size: 16, shootDist: 250, canShoot: true }
            }
        };

        // Current enemy types (set when dungeon is selected)
        let ENEMY_TYPES = DUNGEON_ENEMIES.dungeon;

        // Input
        const keys = {};
        let mouseX = 0, mouseY = 0;
        let mouseDown = false;

        // Game objects
        let bullets = [];
        let enemies = [];
        let walls = [];
        let particles = [];
        let pickups = [];
        let bombs = [];
        let floorDecorations = [];
        let levelProps = []; // large decorative objects (trees, pillars, etc.)

        // Safe zone at spawn
        const safeZone = { x: 0, y: 0, radius: 50 };

        // Colors (pixel art palette)
        // Dungeon themes with difficulty settings
        const DUNGEONS = {
            jungle: {
                name: 'Jungle Temple',
                description: 'Easy - Ancient ruins',
                wall: '#2d5a27',
                wallDark: '#1e3d1a',
                floor: '#1a3318',
                accent: '#4a7c43',
                icon: 'ðŸŒ´',
                difficulty: 1,
                enemyCountMult: 0.8,
                enemyHealthMult: 0.8,
                enemySpeedMult: 0.9,
                enemyDamageMult: 0.8,
                pickupChance: 0.5
            },
            desert: {
                name: 'Desert Tomb',
                description: 'Medium - Sandy crypts',
                wall: '#c4a35a',
                wallDark: '#a68b4b',
                floor: '#3d3426',
                accent: '#e6c86e',
                icon: 'ðŸœï¸',
                difficulty: 2,
                enemyCountMult: 1.0,
                enemyHealthMult: 1.0,
                enemySpeedMult: 1.0,
                enemyDamageMult: 1.0,
                pickupChance: 0.4
            },
            dungeon: {
                name: 'Dark Dungeon',
                description: 'Medium - Stone fortress',
                wall: '#5d5d8a',
                wallDark: '#4a4a6a',
                floor: '#2d2d44',
                accent: '#7d7daa',
                icon: 'ðŸ°',
                difficulty: 2,
                enemyCountMult: 1.0,
                enemyHealthMult: 1.0,
                enemySpeedMult: 1.0,
                enemyDamageMult: 1.0,
                pickupChance: 0.4
            },
            ice: {
                name: 'Frozen Cavern',
                description: 'Hard - Icy depths',
                wall: '#5a8fa8',
                wallDark: '#4a7a8f',
                floor: '#1a2a33',
                accent: '#8ecae6',
                icon: 'â„ï¸',
                difficulty: 3,
                enemyCountMult: 1.2,
                enemyHealthMult: 1.2,
                enemySpeedMult: 1.1,
                enemyDamageMult: 1.2,
                pickupChance: 0.35
            },
            volcano: {
                name: 'Volcanic Lair',
                description: 'Extreme - Fiery mountain',
                wall: '#4a2c2a',
                wallDark: '#3a1c1a',
                floor: '#2a1a18',
                accent: '#e74c3c',
                icon: 'ðŸŒ‹',
                difficulty: 4,
                enemyCountMult: 1.4,
                enemyHealthMult: 1.4,
                enemySpeedMult: 1.2,
                enemyDamageMult: 1.5,
                pickupChance: 0.3
            }
        };

        let COLORS = {
            player: '#4ecdc4',
            playerDark: '#2ea8a0',
            enemy: '#e74c3c',
            enemyDark: '#c0392b',
            bullet: '#f39c12',
            wall: '#5d5d8a',
            wallDark: '#4a4a6a',
            floor: '#2d2d44',
            door: '#8b4513',
            health: '#2ecc71',
            ammo: '#f1c40f',
            shotgun: '#e67e22',
            railgun: '#9b59b6'
        };

        // Current difficulty settings
        let currentDamageMult = 1;

        function applyDungeonTheme(dungeonKey) {
            const dungeon = DUNGEONS[dungeonKey];
            if (dungeon) {
                COLORS.wall = dungeon.wall;
                COLORS.wallDark = dungeon.wallDark;
                COLORS.floor = dungeon.floor;
                selectedDungeon = dungeonKey;
                // Set dungeon-specific enemies
                ENEMY_TYPES = DUNGEON_ENEMIES[dungeonKey] || DUNGEON_ENEMIES.dungeon;
                // Set damage multiplier
                currentDamageMult = dungeon.enemyDamageMult || 1;
            }
        }

        // Reset run-only state (on death or new run)
        function resetRunState() {
            scrap = 0;
            playerArmor = 0;
            playerArmorTier = 0;
            playerCharms = [];
            runShopInventory = [];
            regenTimer = 0;
        }

        // Centralized kill handler
        function onEnemyKill(enemy) {
            score += 100;

            // Scrap drop - always drops
            let scrapAmount;
            if (enemy.type === 'boss') {
                scrapAmount = 8 + Math.floor(Math.random() * 5); // 8-12
            } else if (enemy.type === 'tank') {
                scrapAmount = 2 + Math.floor(Math.random() * 3); // 2-4
            } else if (enemy.type === 'charger') {
                scrapAmount = 1;
            } else {
                scrapAmount = 1 + Math.floor(Math.random() * 2); // 1-2
            }
            // Scrap Magnet charm bonus
            if (playerCharms.includes('scrap_magnet')) {
                scrapAmount += 1;
            }
            dropScrapPickup(enemy.x, enemy.y, scrapAmount);

            // On-kill charm effects
            if (playerCharms.includes('vampiric_fang')) {
                player.health = Math.min(player.health + 5, player.maxHealth);
            }
            if (playerCharms.includes('boom_skull')) {
                // Small explosion on kill (radius 40, damage 20)
                for (let k = 0; k < 10; k++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 4 + 1;
                    particles.push({
                        x: enemy.x, y: enemy.y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: 20,
                        color: Math.random() > 0.3 ? '#ff4500' : '#ff0'
                    });
                }
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const other = enemies[j];
                    const dist = Math.hypot(other.x - enemy.x, other.y - enemy.y);
                    if (dist <= 40 && dist > 0) {
                        other.health -= 20;
                    }
                }
            }

            // Coin drop chance (30%)
            if (Math.random() < 0.3) {
                pickups.push({
                    x: enemy.x + (Math.random() - 0.5) * 10,
                    y: enemy.y + (Math.random() - 0.5) * 10,
                    type: 'coin', width: 10, height: 10, value: 1
                });
            }

            // Pickup drop chance (40%)
            if (Math.random() < 0.4) {
                let type;
                const roll = Math.random();
                if (roll < 0.08) {
                    const available = [];
                    if (currentLevel >= 1) available.push('smg');
                    if (currentLevel >= 2) available.push('shotgun', 'rifle');
                    if (currentLevel >= 3) available.push('railgun');
                    if (currentLevel >= 4) available.push('minigun');
                    if (currentLevel >= 2 && Math.random() < 0.25) available.push('sword');
                    if (currentLevel >= 3 && Math.random() < 0.25) available.push('katana');
                    if (currentLevel >= 3 && Math.random() < 0.15) available.push('sniper');
                    if (currentLevel >= 4 && Math.random() < 0.15) available.push('flamethrower');
                    if (currentLevel >= 5 && Math.random() < 0.15) available.push('rocketlauncher');
                    if (currentLevel >= 4 && Math.random() < 0.05) available.push('bomb');
                    if (available.length > 0) {
                        type = available[Math.floor(Math.random() * available.length)];
                    } else {
                        type = 'ammo';
                    }
                } else if (roll < 0.5) {
                    type = 'health';
                } else {
                    type = 'ammo';
                }
                pickups.push({
                    x: enemy.x, y: enemy.y,
                    type: type, width: 12, height: 12
                });
            }
        }

        // Spawn scrap pickup entity
        function dropScrapPickup(x, y, amount) {
            for (let i = 0; i < amount; i++) {
                pickups.push({
                    x: x + (Math.random() - 0.5) * 20,
                    y: y + (Math.random() - 0.5) * 20,
                    type: 'scrap', width: 8, height: 8, value: 1
                });
            }
        }

        // Apply/reapply passive charm stat mods
        function applyPassiveCharms() {
            // Get base class stats
            const cls = CLASSES[selectedClass] || CLASSES.default;
            let baseSpeed = cls.speed;
            let baseMaxHealth = cls.health;

            // Thick Skin: +25 max HP
            if (playerCharms.includes('thick_skin')) {
                baseMaxHealth += 25;
            }

            // Swift Boots: +20% speed
            if (playerCharms.includes('swift_boots')) {
                baseSpeed *= 1.2;
            }

            player.maxHealth = baseMaxHealth;
            player.speed = baseSpeed;

            // Big Magazines: +50% ammo capacity
            const weapon = WEAPONS[player.weapon];
            if (weapon && !weapon.melee) {
                let baseMaxAmmo = weapon.maxAmmo;
                if (playerCharms.includes('big_magazines')) {
                    baseMaxAmmo = Math.floor(baseMaxAmmo * 1.5);
                }
                player.maxAmmo = baseMaxAmmo;
            }
        }

        // Generate run shop inventory
        function generateRunShopInventory() {
            runShopInventory = [];

            // Next armor tier (if available)
            if (playerArmorTier < ARMOR_TIERS.length) {
                const nextArmor = ARMOR_TIERS[playerArmorTier];
                runShopInventory.push({ category: 'armor', data: nextArmor });
            }

            // 2 random weapons (level-gated, not already held)
            const availableWeapons = RUN_SHOP_WEAPONS
                .filter(w => w.minLevel <= currentLevel && w.weapon !== player.weapon);
            const shuffledWeapons = availableWeapons.sort(() => Math.random() - 0.5);
            for (let i = 0; i < Math.min(2, shuffledWeapons.length); i++) {
                runShopInventory.push({ category: 'weapon', data: shuffledWeapons[i] });
            }

            // 2 random charms (not already owned)
            const availableCharms = Object.keys(CHARMS)
                .filter(id => !playerCharms.includes(id));
            const shuffledCharms = availableCharms.sort(() => Math.random() - 0.5);
            const charmSlots = 3 - playerCharms.length;
            for (let i = 0; i < Math.min(2, shuffledCharms.length, charmSlots + 1); i++) {
                runShopInventory.push({
                    category: 'charm',
                    data: { id: shuffledCharms[i], ...CHARMS[shuffledCharms[i]] }
                });
            }
        }

        // Draw run shop UI
        function drawRunShop() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Scrap display
            ctx.fillStyle = '#95a5a6';
            ctx.font = isMobile ? '14px monospace' : '18px monospace';
            ctx.textAlign = 'right';
            ctx.fillText('Scrap: ' + scrap, canvas.width - 15, 25);

            // Title
            ctx.fillStyle = '#95a5a6';
            ctx.font = isMobile ? '22px monospace' : '32px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('RUN SHOP', canvas.width / 2, isMobile ? 50 : 55);

            ctx.fillStyle = '#666';
            ctx.font = isMobile ? '10px monospace' : '12px monospace';
            ctx.fillText('Spend scrap to upgrade this run', canvas.width / 2, isMobile ? 68 : 78);

            // Draw items in grid
            const cols = isMobile ? 2 : 3;
            const btnW = isMobile ? 155 : 185;
            const btnH = isMobile ? 75 : 85;
            const gap = isMobile ? 10 : 15;
            const startX = (canvas.width - (cols * btnW + (cols - 1) * gap)) / 2;
            const startY = isMobile ? 85 : 100;

            menuButtons = [];

            for (let i = 0; i < runShopInventory.length; i++) {
                const item = runShopInventory[i];
                const col = i % cols;
                const row = Math.floor(i / cols);
                const x = startX + col * (btnW + gap);
                const y = startY + row * (btnH + gap);

                let name, desc, price, itemColor, owned = false, cantUse = false;

                if (item.category === 'armor') {
                    name = item.data.name;
                    desc = Math.round(item.data.dr * 100) + '% damage reduction';
                    price = item.data.price;
                    itemColor = item.data.color;
                    owned = playerArmorTier >= item.data.tier;
                } else if (item.category === 'weapon') {
                    const wname = item.data.weapon;
                    name = wname.charAt(0).toUpperCase() + wname.slice(1);
                    desc = 'Weapon';
                    price = item.data.price;
                    itemColor = WEAPONS[wname].color;
                    owned = player.weapon === wname;
                } else if (item.category === 'charm') {
                    name = item.data.name;
                    desc = item.data.desc;
                    price = item.data.price;
                    itemColor = item.data.color;
                    owned = playerCharms.includes(item.data.id);
                    cantUse = !owned && playerCharms.length >= 3;
                }

                const canAfford = scrap >= price && !owned && !cantUse;

                menuButtons.push({ x, y, w: btnW, h: btnH, shopIndex: i });

                // Button background
                if (owned) {
                    ctx.fillStyle = '#2ecc71';
                } else if (canAfford) {
                    ctx.fillStyle = itemColor || '#888';
                } else {
                    ctx.fillStyle = '#444';
                }
                ctx.fillRect(x, y, btnW, btnH);
                ctx.fillStyle = '#1a1a2e';
                ctx.fillRect(x + 3, y + 3, btnW - 6, btnH - 6);

                // Category label
                ctx.fillStyle = '#666';
                ctx.font = isMobile ? '8px monospace' : '9px monospace';
                ctx.textAlign = 'center';
                const catLabel = item.category.toUpperCase();
                ctx.fillText(catLabel, x + btnW / 2, y + (isMobile ? 14 : 16));

                // Item name
                ctx.fillStyle = owned ? '#2ecc71' : (canAfford ? '#fff' : '#666');
                ctx.font = isMobile ? '11px monospace' : '13px monospace';
                ctx.fillText(name, x + btnW / 2, y + (isMobile ? 30 : 34));

                // Description
                ctx.fillStyle = '#888';
                ctx.font = isMobile ? '8px monospace' : '10px monospace';
                ctx.fillText(desc, x + btnW / 2, y + (isMobile ? 44 : 50));

                // Price or status
                if (owned) {
                    ctx.fillStyle = '#2ecc71';
                    ctx.fillText('OWNED', x + btnW / 2, y + (isMobile ? 58 : 66));
                } else if (cantUse) {
                    ctx.fillStyle = '#e74c3c';
                    ctx.fillText('MAX CHARMS (3)', x + btnW / 2, y + (isMobile ? 58 : 66));
                } else {
                    ctx.fillStyle = canAfford ? '#95a5a6' : '#e74c3c';
                    ctx.fillText(price + ' Scrap', x + btnW / 2, y + (isMobile ? 58 : 66));
                }
            }

            // Continue button
            const contBtnW = isMobile ? 140 : 160;
            const contBtnH = isMobile ? 40 : 45;
            const contBtnX = canvas.width / 2 - contBtnW / 2;
            const contBtnY = canvas.height - (isMobile ? 60 : 70);
            menuButtons.push({ x: contBtnX, y: contBtnY, w: contBtnW, h: contBtnH, action: 'runshop_continue' });

            ctx.fillStyle = '#27ae60';
            ctx.fillRect(contBtnX, contBtnY, contBtnW, contBtnH);
            ctx.fillStyle = '#2ecc71';
            ctx.fillRect(contBtnX + 3, contBtnY + 3, contBtnW - 6, contBtnH - 6);
            ctx.fillStyle = '#1a1a2e';
            ctx.font = isMobile ? '14px monospace' : '16px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('CONTINUE', contBtnX + contBtnW / 2, contBtnY + (isMobile ? 26 : 30));

            // Current charms display at bottom
            if (playerCharms.length > 0) {
                ctx.fillStyle = '#666';
                ctx.font = isMobile ? '9px monospace' : '11px monospace';
                ctx.fillText('Active Charms:', canvas.width / 2, contBtnY - (isMobile ? 28 : 30));
                const charmText = playerCharms.map(id => CHARMS[id].name).join(', ');
                ctx.fillStyle = '#aaa';
                ctx.font = isMobile ? '8px monospace' : '10px monospace';
                ctx.fillText(charmText, canvas.width / 2, contBtnY - (isMobile ? 16 : 16));
            }

            ctx.textAlign = 'left';
        }

        // Handle run shop purchases
        function handleRunShopClick(clickX, clickY) {
            for (const btn of menuButtons) {
                if (clickX >= btn.x && clickX <= btn.x + btn.w &&
                    clickY >= btn.y && clickY <= btn.y + btn.h) {
                    if (btn.action === 'runshop_continue') {
                        // Continue to next room
                        generateLevel(currentLevel);
                        gameState = 'playing';
                        return true;
                    }
                    if (btn.shopIndex !== undefined) {
                        const item = runShopInventory[btn.shopIndex];
                        if (!item) return true;

                        if (item.category === 'armor') {
                            if (playerArmorTier < item.data.tier && scrap >= item.data.price) {
                                scrap -= item.data.price;
                                playerArmorTier = item.data.tier;
                                playerArmor = item.data.dr;
                            }
                        } else if (item.category === 'weapon') {
                            if (player.weapon !== item.data.weapon && scrap >= item.data.price) {
                                scrap -= item.data.price;
                                player.weapon = item.data.weapon;
                                const newWeapon = WEAPONS[item.data.weapon];
                                if (newWeapon.melee) {
                                    player.maxAmmo = 0;
                                    player.ammo = 0;
                                } else {
                                    player.maxAmmo = newWeapon.maxAmmo;
                                    player.ammo = player.maxAmmo;
                                }
                                player.reloading = false;
                                applyPassiveCharms();
                            }
                        } else if (item.category === 'charm') {
                            if (!playerCharms.includes(item.data.id) &&
                                playerCharms.length < 3 &&
                                scrap >= item.data.price) {
                                scrap -= item.data.price;
                                playerCharms.push(item.data.id);
                                applyPassiveCharms();
                                // Heal up to new max if thick_skin just bought
                                if (item.data.id === 'thick_skin') {
                                    player.health = Math.min(player.health + 25, player.maxHealth);
                                }
                            }
                        }
                        return true;
                    }
                }
            }
            return false;
        }

        // Generate level
        function generateLevel(levelNum) {
            walls = [];
            enemies = [];
            pickups = [];
            bullets = [];
            particles = [];
            bombs = [];

            // Set player spawn based on device
            if (isMobile) {
                player.x = W / 2;
                player.y = H - 50;
            } else {
                player.x = 550;
                player.y = 430;
            }
            // Only reset health on first level, keep HP between rooms
            if (levelNum === 1) {
                player.health = player.maxHealth;
            }
            player.ammo = player.maxAmmo;

            // Set safe zone at spawn
            safeZone.x = player.x;
            safeZone.y = player.y;

            // Outer walls - use W and H
            walls.push({ x: 0, y: 0, w: W, h: 20 });
            walls.push({ x: 0, y: H - 20, w: W, h: 20 });
            walls.push({ x: 0, y: 0, w: 20, h: H });
            walls.push({ x: W - 20, y: 0, w: 20, h: H });

            // Room dividers based on level and device
            let roomConfigs;

            if (isMobile) {
                // Mobile layouts (360x640)
                roomConfigs = [
                    // 0 - Simple horizontal splits
                    [
                        { x: 0, y: 150, w: 200, h: 20 },
                        { x: 160, y: 280, w: 200, h: 20 },
                        { x: 0, y: 410, w: 200, h: 20 },
                        { x: 160, y: 540, w: 200, h: 20 },
                    ],
                    // 1 - Cross corridors
                    [
                        { x: 120, y: 0, w: 20, h: 120 },
                        { x: 220, y: 80, w: 20, h: 120 },
                        { x: 0, y: 200, w: 150, h: 20 },
                        { x: 210, y: 200, w: 150, h: 20 },
                        { x: 120, y: 280, w: 20, h: 120 },
                        { x: 0, y: 400, w: 250, h: 20 },
                        { x: 180, y: 480, w: 20, h: 100 },
                        { x: 80, y: 560, w: 200, h: 20 },
                    ],
                    // 2 - Dense maze
                    [
                        { x: 80, y: 60, w: 20, h: 100 },
                        { x: 180, y: 0, w: 20, h: 120 },
                        { x: 260, y: 80, w: 20, h: 100 },
                        { x: 0, y: 160, w: 120, h: 20 },
                        { x: 180, y: 160, w: 180, h: 20 },
                        { x: 120, y: 220, w: 20, h: 100 },
                        { x: 60, y: 320, w: 200, h: 20 },
                        { x: 220, y: 380, w: 20, h: 100 },
                        { x: 0, y: 440, w: 180, h: 20 },
                        { x: 80, y: 500, w: 20, h: 80 },
                        { x: 160, y: 540, w: 120, h: 20 },
                    ],
                    // 3 - Arena with pillars
                    [
                        { x: 80, y: 150, w: 40, h: 40 },
                        { x: 240, y: 150, w: 40, h: 40 },
                        { x: 80, y: 350, w: 40, h: 40 },
                        { x: 240, y: 350, w: 40, h: 40 },
                        { x: 160, y: 250, w: 40, h: 40 },
                        { x: 0, y: 480, w: 140, h: 20 },
                        { x: 220, y: 480, w: 140, h: 20 },
                    ],
                    // 4 - Winding path
                    [
                        { x: 0, y: 100, w: 240, h: 20 },
                        { x: 240, y: 100, w: 20, h: 120 },
                        { x: 100, y: 220, w: 160, h: 20 },
                        { x: 100, y: 220, w: 20, h: 120 },
                        { x: 100, y: 340, w: 200, h: 20 },
                        { x: 280, y: 340, w: 20, h: 120 },
                        { x: 60, y: 460, w: 240, h: 20 },
                    ],
                    // 5 - Central chamber
                    [
                        { x: 100, y: 0, w: 20, h: 200 },
                        { x: 240, y: 0, w: 20, h: 200 },
                        { x: 100, y: 200, w: 20, h: 20 },
                        { x: 240, y: 200, w: 20, h: 20 },
                        { x: 0, y: 200, w: 100, h: 20 },
                        { x: 260, y: 200, w: 100, h: 20 },
                        { x: 100, y: 400, w: 20, h: 20 },
                        { x: 240, y: 400, w: 20, h: 20 },
                        { x: 100, y: 420, w: 20, h: 160 },
                        { x: 240, y: 420, w: 20, h: 160 },
                        { x: 0, y: 400, w: 100, h: 20 },
                        { x: 260, y: 400, w: 100, h: 20 },
                    ],
                    // 6 - L-shaped rooms
                    [
                        { x: 180, y: 0, w: 20, h: 160 },
                        { x: 0, y: 160, w: 130, h: 20 },
                        { x: 100, y: 180, w: 20, h: 80 },
                        { x: 0, y: 320, w: 120, h: 20 },
                        { x: 200, y: 260, w: 20, h: 140 },
                        { x: 200, y: 400, w: 160, h: 20 },
                        { x: 120, y: 460, w: 20, h: 120 },
                        { x: 0, y: 520, w: 120, h: 20 },
                    ],
                    // 7 - Scattered blocks
                    [
                        { x: 60, y: 80, w: 60, h: 20 },
                        { x: 200, y: 60, w: 20, h: 80 },
                        { x: 260, y: 140, w: 60, h: 20 },
                        { x: 40, y: 220, w: 20, h: 80 },
                        { x: 140, y: 200, w: 80, h: 20 },
                        { x: 280, y: 280, w: 20, h: 80 },
                        { x: 80, y: 360, w: 60, h: 20 },
                        { x: 200, y: 380, w: 20, h: 80 },
                        { x: 100, y: 480, w: 80, h: 20 },
                        { x: 240, y: 520, w: 60, h: 20 },
                    ],
                ];
            } else {
                // Desktop layouts (640x480)
                roomConfigs = [
                    // 0 - Two vertical dividers
                    [
                        { x: 200, y: 0, w: 20, h: 150 },
                        { x: 200, y: 200, w: 20, h: 280 },
                        { x: 420, y: 0, w: 20, h: 280 },
                        { x: 420, y: 330, w: 20, h: 150 },
                        { x: 200, y: 300, w: 150, h: 20 },
                    ],
                    // 1 - Grid rooms
                    [
                        { x: 150, y: 0, w: 20, h: 200 },
                        { x: 150, y: 250, w: 20, h: 180 },
                        { x: 300, y: 100, w: 20, h: 150 },
                        { x: 300, y: 300, w: 20, h: 120 },
                        { x: 470, y: 0, w: 20, h: 150 },
                        { x: 470, y: 200, w: 20, h: 200 },
                        { x: 150, y: 200, w: 100, h: 20 },
                        { x: 370, y: 250, w: 100, h: 20 },
                    ],
                    // 2 - Dense maze
                    [
                        { x: 100, y: 80, w: 200, h: 20 },
                        { x: 100, y: 80, w: 20, h: 150 },
                        { x: 340, y: 0, w: 20, h: 180 },
                        { x: 340, y: 230, w: 20, h: 100 },
                        { x: 200, y: 200, w: 160, h: 20 },
                        { x: 500, y: 100, w: 20, h: 200 },
                        { x: 400, y: 300, w: 120, h: 20 },
                        { x: 100, y: 350, w: 20, h: 130 },
                        { x: 100, y: 350, w: 200, h: 20 },
                        { x: 280, y: 350, w: 20, h: 80 },
                        { x: 450, y: 380, w: 20, h: 100 },
                    ],
                    // 3 - Arena with pillars
                    [
                        { x: 140, y: 100, w: 40, h: 40 },
                        { x: 460, y: 100, w: 40, h: 40 },
                        { x: 140, y: 340, w: 40, h: 40 },
                        { x: 460, y: 340, w: 40, h: 40 },
                        { x: 300, y: 200, w: 40, h: 40 },
                    ],
                    // 4 - Winding corridors
                    [
                        { x: 0, y: 100, w: 400, h: 20 },
                        { x: 400, y: 100, w: 20, h: 120 },
                        { x: 200, y: 220, w: 220, h: 20 },
                        { x: 200, y: 220, w: 20, h: 100 },
                        { x: 200, y: 320, w: 320, h: 20 },
                        { x: 100, y: 380, w: 20, h: 100 },
                        { x: 100, y: 380, w: 300, h: 20 },
                    ],
                    // 5 - Central chamber
                    [
                        { x: 180, y: 0, w: 20, h: 120 },
                        { x: 440, y: 0, w: 20, h: 120 },
                        { x: 180, y: 120, w: 280, h: 20 },
                        { x: 180, y: 340, w: 280, h: 20 },
                        { x: 180, y: 360, w: 20, h: 120 },
                        { x: 440, y: 360, w: 20, h: 120 },
                        { x: 280, y: 120, w: 20, h: 40 },
                        { x: 340, y: 320, w: 20, h: 40 },
                    ],
                    // 6 - L-rooms and corridors
                    [
                        { x: 200, y: 0, w: 20, h: 80 },
                        { x: 200, y: 130, w: 20, h: 70 },
                        { x: 0, y: 200, w: 220, h: 20 },
                        { x: 350, y: 100, w: 20, h: 200 },
                        { x: 350, y: 100, w: 150, h: 20 },
                        { x: 100, y: 300, w: 20, h: 180 },
                        { x: 100, y: 300, w: 200, h: 20 },
                        { x: 450, y: 250, w: 20, h: 130 },
                        { x: 350, y: 380, w: 120, h: 20 },
                        { x: 500, y: 380, w: 20, h: 100 },
                    ],
                    // 7 - Scattered blocks
                    [
                        { x: 100, y: 60, w: 80, h: 20 },
                        { x: 300, y: 40, w: 20, h: 80 },
                        { x: 450, y: 80, w: 80, h: 20 },
                        { x: 60, y: 180, w: 20, h: 80 },
                        { x: 200, y: 160, w: 100, h: 20 },
                        { x: 400, y: 200, w: 20, h: 80 },
                        { x: 530, y: 180, w: 20, h: 80 },
                        { x: 120, y: 300, w: 80, h: 20 },
                        { x: 280, y: 280, w: 20, h: 80 },
                        { x: 450, y: 340, w: 80, h: 20 },
                        { x: 160, y: 400, w: 100, h: 20 },
                        { x: 360, y: 420, w: 20, h: 60 },
                    ],
                    // 8 - Ring layout
                    [
                        { x: 160, y: 80, w: 320, h: 20 },
                        { x: 160, y: 80, w: 20, h: 130 },
                        { x: 460, y: 80, w: 20, h: 130 },
                        { x: 160, y: 280, w: 20, h: 130 },
                        { x: 460, y: 280, w: 20, h: 130 },
                        { x: 160, y: 390, w: 320, h: 20 },
                        { x: 280, y: 180, w: 80, h: 20 },
                        { x: 280, y: 290, w: 80, h: 20 },
                    ],
                    // 9 - Diagonal feel
                    [
                        { x: 80, y: 0, w: 20, h: 120 },
                        { x: 80, y: 100, w: 120, h: 20 },
                        { x: 200, y: 100, w: 20, h: 100 },
                        { x: 200, y: 200, w: 140, h: 20 },
                        { x: 320, y: 200, w: 20, h: 100 },
                        { x: 320, y: 300, w: 160, h: 20 },
                        { x: 460, y: 300, w: 20, h: 100 },
                        { x: 200, y: 360, w: 260, h: 20 },
                        { x: 100, y: 400, w: 20, h: 80 },
                    ],
                ];
            }

            // Pick layout: level 1 always uses config 0, then rotate through all
            let configIndex;
            if (levelNum <= 1) {
                configIndex = 0;
            } else {
                // Deterministic but varied selection based on level
                configIndex = ((levelNum - 1) * 3 + levelNum) % roomConfigs.length;
            }
            walls.push(...roomConfigs[configIndex]);

            // Get dungeon difficulty settings
            const dungeonSettings = DUNGEONS[selectedDungeon] || DUNGEONS.dungeon;
            const countMult = dungeonSettings.enemyCountMult || 1;
            const healthMult = dungeonSettings.enemyHealthMult || 1;
            const speedMult = dungeonSettings.enemySpeedMult || 1;

            // Spawn enemies - find valid positions not in walls
            const baseCount = 3 + levelNum * 2;
            const enemyCount = Math.floor(baseCount * countMult);
            let spawned = 0;
            let attempts = 0;

            while (spawned < enemyCount && attempts < 500) {
                attempts++;
                // Try random position in playable area
                const x = 40 + Math.random() * (W - 80);
                const y = 40 + Math.random() * (H - 120);

                // Pick enemy type based on level
                let type = 'grunt';
                const roll = Math.random();
                if (levelNum >= 4 && roll < 0.15) {
                    type = 'sniper';
                } else if (levelNum >= 3 && roll < 0.25) {
                    type = 'tank';
                } else if (levelNum >= 2 && roll < 0.4) {
                    type = 'charger';
                }
                const enemyType = ENEMY_TYPES[type];

                // Check not in wall and not too close to player spawn
                const distToPlayer = Math.hypot(x - player.x, y - player.y);
                if (!pointInWalls(x, y, enemyType.size, enemyType.size) && distToPlayer > 100) {
                    const baseHealth = enemyType.health + levelNum * 5;
                    enemies.push({
                        x: x,
                        y: y,
                        type: type,
                        width: enemyType.size,
                        height: enemyType.size,
                        speed: (enemyType.speed + levelNum * 0.1) * speedMult,
                        health: Math.floor(baseHealth * healthMult),
                        maxHealth: Math.floor(baseHealth * healthMult),
                        shootCooldown: 0,
                        alertDistance: 180 + levelNum * 15,
                        shootDistance: enemyType.shootDist,
                        canShoot: enemyType.canShoot
                    });
                    spawned++;
                }
            }

            // Spawn boss every 10 levels (or more frequently on harder difficulties)
            const bossInterval = Math.max(5, Math.floor(10 / (dungeonSettings.difficulty || 1)));
            if (levelNum % bossInterval === 0) {
                const bossType = ENEMY_TYPES.boss;
                const bossHealth = Math.floor((bossType.health + levelNum * 20) * healthMult);
                for (let i = 0; i < 100; i++) {
                    const bx = 50 + Math.random() * (W - 100);
                    const by = 50 + Math.random() * (H - 100);
                    const distToPlayer = Math.hypot(bx - player.x, by - player.y);
                    if (!pointInWalls(bx, by, bossType.size, bossType.size) && distToPlayer > 150) {
                        enemies.push({
                            x: bx,
                            y: by,
                            type: 'boss',
                            width: bossType.size,
                            height: bossType.size,
                            speed: bossType.speed * speedMult,
                            health: bossHealth,
                            maxHealth: bossHealth,
                            shootCooldown: 0,
                            alertDistance: 400,
                            shootDistance: bossType.shootDist,
                            canShoot: bossType.canShoot
                        });
                        break;
                    }
                }
            }

            // Spawn pickups at valid positions (more on easier difficulties)
            const pickupChance = dungeonSettings.pickupChance || 0.4;
            const numHealthPacks = Math.random() < pickupChance ? 2 : 1;
            for (let h = 0; h < numHealthPacks; h++) {
                for (let i = 0; i < 50; i++) {
                    const hx = 40 + Math.random() * (W - 80);
                    const hy = 40 + Math.random() * (H - 80);
                    if (!pointInWalls(hx, hy, 12, 12)) {
                        pickups.push({ x: hx, y: hy, type: 'health', width: 12, height: 12 });
                        break;
                    }
                }
            }
            const numAmmoPacks = Math.random() < pickupChance ? 2 : 1;
            for (let a = 0; a < numAmmoPacks; a++) {
                for (let i = 0; i < 50; i++) {
                    const ax = 40 + Math.random() * (W - 80);
                    const ay = 40 + Math.random() * (H - 80);
                    if (!pointInWalls(ax, ay, 12, 12)) {
                        pickups.push({ x: ax, y: ay, type: 'ammo', width: 12, height: 12 });
                        break;
                    }
                }
            }

            // Chance to spawn 1 random weapon on the ground (higher on easier difficulties)
            if (Math.random() < pickupChance) {
                const available = [];
                if (levelNum >= 1) available.push('smg');
                if (levelNum >= 2) available.push('shotgun', 'rifle');
                if (levelNum >= 3) available.push('railgun');
                if (levelNum >= 4) available.push('minigun');
                // Melee weapons have lower spawn rate (25% chance)
                if (levelNum >= 2 && Math.random() < 0.25) available.push('sword');
                if (levelNum >= 3 && Math.random() < 0.25) available.push('katana');
                // Rare weapons have 15% spawn rate
                if (levelNum >= 3 && Math.random() < 0.15) available.push('sniper');
                if (levelNum >= 4 && Math.random() < 0.15) available.push('flamethrower');
                if (levelNum >= 5 && Math.random() < 0.15) available.push('rocketlauncher');
                // Super rare bomb (5% spawn rate)
                if (levelNum >= 4 && Math.random() < 0.05) available.push('bomb');
                if (available.length > 0) {
                    const weaponType = available[Math.floor(Math.random() * available.length)];
                    for (let i = 0; i < 100; i++) {
                        const wx = 50 + Math.random() * (W - 100);
                        const wy = 50 + Math.random() * (H - 100);
                        const distToSpawn = Math.hypot(wx - player.x, wy - player.y);
                        if (!pointInWalls(wx, wy, 16, 16) && distToSpawn > 80) {
                            pickups.push({ x: wx, y: wy, type: weaponType, width: 16, height: 16 });
                            break;
                        }
                    }
                }
            }

            // Spawn coins (2-4 per level, more on higher levels)
            const numCoins = 2 + Math.floor(Math.random() * 2) + Math.floor(levelNum / 3);
            for (let c = 0; c < numCoins; c++) {
                for (let i = 0; i < 50; i++) {
                    const cx = 40 + Math.random() * (W - 80);
                    const cy = 40 + Math.random() * (H - 80);
                    const distToSpawn = Math.hypot(cx - player.x, cy - player.y);
                    if (!pointInWalls(cx, cy, 10, 10) && distToSpawn > 60) {
                        pickups.push({ x: cx, y: cy, type: 'coin', width: 10, height: 10, value: 1 });
                        break;
                    }
                }
            }

            // Generate floor decorations (pre-computed for performance)
            floorDecorations = [];
            const numDecos = isMobile ? 40 : 70;
            for (let d = 0; d < numDecos; d++) {
                const dx = 30 + Math.random() * (W - 60);
                const dy = 30 + Math.random() * (H - 60);
                if (!pointInWalls(dx, dy, 4, 4)) {
                    const variant = Math.floor(Math.random() * 6);
                    const size = 2 + Math.floor(Math.random() * 5);
                    floorDecorations.push({ x: dx, y: dy, variant: variant, size: size });
                }
            }

            // Generate large props (trees, pillars, stalagmites, etc.)
            levelProps = [];
            const numProps = isMobile ? 5 : 8;
            for (let p = 0; p < numProps; p++) {
                for (let attempt = 0; attempt < 30; attempt++) {
                    const px = 40 + Math.random() * (W - 80);
                    const py = 40 + Math.random() * (H - 80);
                    // Must not be in walls, not near player spawn, not overlapping other props
                    const distToSpawn = Math.hypot(px - player.x, py - player.y);
                    if (!pointInWalls(px, py, 24, 24) && distToSpawn > 70) {
                        let overlap = false;
                        for (const existing of levelProps) {
                            if (Math.hypot(px - existing.x, py - existing.y) < 40) {
                                overlap = true;
                                break;
                            }
                        }
                        if (!overlap) {
                            const propVariant = Math.floor(Math.random() * 4);
                            const propSize = 8 + Math.floor(Math.random() * 10);
                            levelProps.push({ x: px, y: py, variant: propVariant, size: propSize });
                            break;
                        }
                    }
                }
            }

            // Jungle: also generate grass patches (lots of them)
            if (selectedDungeon === 'jungle') {
                const numGrass = isMobile ? 30 : 50;
                for (let g = 0; g < numGrass; g++) {
                    const gx = 25 + Math.random() * (W - 50);
                    const gy = 25 + Math.random() * (H - 50);
                    if (!pointInWalls(gx, gy, 6, 6)) {
                        floorDecorations.push({ x: gx, y: gy, variant: 10, size: 3 + Math.floor(Math.random() * 4) }); // variant 10 = grass
                    }
                }
            }
        }

        // Draw pixel rectangle
        function drawPixelRect(x, y, w, h, color, darkColor) {
            ctx.fillStyle = color;
            ctx.fillRect(Math.floor(x), Math.floor(y), w, h);
            if (darkColor) {
                ctx.fillStyle = darkColor;
                ctx.fillRect(Math.floor(x), Math.floor(y) + h - 3, w, 3);
                ctx.fillRect(Math.floor(x) + w - 3, Math.floor(y), 3, h);
            }
        }

        // Draw floor decorations (called before walls/entities)
        function drawFloorDecorations() {
            for (const d of floorDecorations) {
                if (selectedDungeon === 'jungle') {
                    if (d.variant === 0) {
                        // Small bush / fern
                        ctx.fillStyle = '#1e4d18';
                        ctx.fillRect(d.x - 3, d.y, 6, 3);
                        ctx.fillStyle = '#2a6322';
                        ctx.fillRect(d.x - 2, d.y - 2, 4, 3);
                        ctx.fillStyle = '#3a7c33';
                        ctx.fillRect(d.x - 1, d.y - 3, 2, 2);
                    } else if (d.variant === 1) {
                        // Fallen leaves
                        ctx.fillStyle = '#3a5a1e';
                        ctx.globalAlpha = 0.6;
                        ctx.fillRect(d.x, d.y, 3, 2);
                        ctx.fillRect(d.x + 4, d.y + 2, 2, 2);
                        ctx.fillStyle = '#5a7a2e';
                        ctx.fillRect(d.x - 2, d.y + 1, 2, 2);
                        ctx.globalAlpha = 1;
                    } else if (d.variant === 2) {
                        // Mushroom
                        ctx.fillStyle = '#5d3a1e';
                        ctx.fillRect(d.x, d.y + 1, 2, 3);
                        ctx.fillStyle = '#c84040';
                        ctx.beginPath();
                        ctx.arc(d.x + 1, d.y, 3, Math.PI, 0);
                        ctx.fill();
                        ctx.fillStyle = '#fff';
                        ctx.fillRect(d.x - 1, d.y - 1, 1, 1);
                        ctx.fillRect(d.x + 2, d.y - 2, 1, 1);
                    } else if (d.variant === 3) {
                        // Moss patch on ground
                        ctx.fillStyle = '#1e4d18';
                        ctx.globalAlpha = 0.4;
                        ctx.beginPath();
                        ctx.arc(d.x, d.y, d.size, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#2d6b26';
                        ctx.beginPath();
                        ctx.arc(d.x + 1, d.y - 1, d.size * 0.6, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1;
                    } else if (d.variant === 4) {
                        // Small flowers
                        ctx.fillStyle = '#2a5a20';
                        ctx.fillRect(d.x, d.y, 1, 4);
                        ctx.fillRect(d.x + 5, d.y + 1, 1, 3);
                        const flowerColors = ['#e8e850', '#e06090', '#8060d0'];
                        ctx.fillStyle = flowerColors[d.size % 3];
                        ctx.fillRect(d.x - 1, d.y - 1, 3, 2);
                        ctx.fillRect(d.x + 4, d.y, 3, 2);
                    } else if (d.variant === 5) {
                        // Tree roots / ground crack
                        ctx.strokeStyle = '#1a3a12';
                        ctx.globalAlpha = 0.5;
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(d.x - d.size, d.y);
                        ctx.quadraticCurveTo(d.x, d.y - 2, d.x + d.size, d.y + 1);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(d.x, d.y);
                        ctx.lineTo(d.x + 2, d.y + d.size);
                        ctx.stroke();
                        ctx.globalAlpha = 1;
                    } else if (d.variant === 10) {
                        // Grass tufts
                        const blades = 3 + d.size;
                        for (let b = 0; b < blades; b++) {
                            const bx = d.x - d.size + b * (d.size * 2 / blades);
                            const bladeH = 4 + (b * 3 + d.x) % 5;
                            const sway = Math.sin(Date.now() / 1500 + bx * 0.3) * 1.5;
                            ctx.strokeStyle = b % 3 === 0 ? '#3a8a30' : (b % 3 === 1 ? '#2d6b26' : '#4a9e40');
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.moveTo(bx, d.y);
                            ctx.quadraticCurveTo(bx + sway, d.y - bladeH * 0.6, bx + sway * 1.5, d.y - bladeH);
                            ctx.stroke();
                        }
                    }

                } else if (selectedDungeon === 'desert') {
                    if (d.variant === 0) {
                        // Sand ripples
                        ctx.strokeStyle = '#4a3c28';
                        ctx.globalAlpha = 0.3;
                        ctx.lineWidth = 1;
                        for (let r = 0; r < 3; r++) {
                            ctx.beginPath();
                            ctx.moveTo(d.x - 6, d.y + r * 4);
                            ctx.quadraticCurveTo(d.x, d.y + r * 4 - 2, d.x + 6, d.y + r * 4);
                            ctx.stroke();
                        }
                        ctx.globalAlpha = 1;
                    } else if (d.variant === 1) {
                        // Small rocks / rubble
                        ctx.fillStyle = '#5a4a36';
                        ctx.fillRect(d.x, d.y, 3, 2);
                        ctx.fillStyle = '#6a5a46';
                        ctx.fillRect(d.x + 4, d.y + 1, 2, 2);
                        ctx.fillRect(d.x - 1, d.y + 2, 2, 1);
                    } else if (d.variant === 2) {
                        // Scattered bones
                        ctx.fillStyle = '#d4c8a0';
                        ctx.globalAlpha = 0.6;
                        ctx.fillRect(d.x - 3, d.y, 6, 1);
                        ctx.fillRect(d.x, d.y - 2, 1, 5);
                        ctx.fillRect(d.x + 3, d.y - 1, 1, 3);
                        ctx.globalAlpha = 1;
                    } else if (d.variant === 3) {
                        // Sand pile
                        ctx.fillStyle = '#4a3c28';
                        ctx.globalAlpha = 0.25;
                        ctx.beginPath();
                        ctx.arc(d.x, d.y, d.size + 1, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1;
                    } else if (d.variant === 4) {
                        // Cracked tile
                        ctx.strokeStyle = '#5a4a36';
                        ctx.globalAlpha = 0.3;
                        ctx.lineWidth = 1;
                        ctx.strokeRect(d.x - 4, d.y - 4, 8, 8);
                        ctx.beginPath();
                        ctx.moveTo(d.x - 4, d.y);
                        ctx.lineTo(d.x + 2, d.y + 3);
                        ctx.lineTo(d.x + 4, d.y - 1);
                        ctx.stroke();
                        ctx.globalAlpha = 1;
                    } else {
                        // Scarab beetle shape
                        ctx.fillStyle = '#2a4a2a';
                        ctx.globalAlpha = 0.35;
                        ctx.beginPath();
                        ctx.arc(d.x, d.y, 2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillRect(d.x - 3, d.y - 1, 1, 2);
                        ctx.fillRect(d.x + 2, d.y - 1, 1, 2);
                        ctx.globalAlpha = 1;
                    }

                } else if (selectedDungeon === 'ice') {
                    if (d.variant === 0) {
                        // Ice crack on floor
                        ctx.strokeStyle = '#4a7a8f';
                        ctx.globalAlpha = 0.4;
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(d.x - d.size, d.y);
                        ctx.lineTo(d.x, d.y + 1);
                        ctx.lineTo(d.x + d.size, d.y - 1);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(d.x, d.y + 1);
                        ctx.lineTo(d.x - 2, d.y + d.size);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(d.x, d.y + 1);
                        ctx.lineTo(d.x + 3, d.y + d.size - 1);
                        ctx.stroke();
                        ctx.globalAlpha = 1;
                    } else if (d.variant === 1) {
                        // Frozen puddle
                        ctx.fillStyle = '#3a6a7f';
                        ctx.globalAlpha = 0.2;
                        ctx.beginPath();
                        ctx.ellipse(d.x, d.y, d.size + 2, d.size, 0, 0, Math.PI * 2);
                        ctx.fill();
                        // Shine
                        ctx.fillStyle = '#8ecae6';
                        ctx.globalAlpha = 0.3;
                        ctx.fillRect(d.x - 2, d.y - 1, 3, 1);
                        ctx.globalAlpha = 1;
                    } else if (d.variant === 2) {
                        // Snow pile
                        ctx.fillStyle = '#8aaab8';
                        ctx.globalAlpha = 0.25;
                        ctx.beginPath();
                        ctx.arc(d.x, d.y, d.size, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#a0c0d0';
                        ctx.beginPath();
                        ctx.arc(d.x - 1, d.y - 1, d.size * 0.5, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1;
                    } else if (d.variant === 3) {
                        // Ice crystal on floor
                        ctx.strokeStyle = '#8ecae6';
                        ctx.globalAlpha = 0.4;
                        ctx.lineWidth = 1;
                        for (let a = 0; a < 3; a++) {
                            const ang = a * Math.PI / 3;
                            ctx.beginPath();
                            ctx.moveTo(d.x - Math.cos(ang) * 4, d.y - Math.sin(ang) * 4);
                            ctx.lineTo(d.x + Math.cos(ang) * 4, d.y + Math.sin(ang) * 4);
                            ctx.stroke();
                        }
                        ctx.globalAlpha = 1;
                    } else if (d.variant === 4) {
                        // Frost pattern
                        ctx.fillStyle = '#6a9aaf';
                        ctx.globalAlpha = 0.15;
                        ctx.fillRect(d.x - 3, d.y - 3, 6, 6);
                        ctx.fillStyle = '#8ecae6';
                        ctx.fillRect(d.x - 1, d.y - 4, 2, 8);
                        ctx.fillRect(d.x - 4, d.y - 1, 8, 2);
                        ctx.globalAlpha = 1;
                    } else {
                        // Frozen bones
                        ctx.fillStyle = '#90b0c0';
                        ctx.globalAlpha = 0.4;
                        ctx.fillRect(d.x - 3, d.y, 6, 1);
                        ctx.fillRect(d.x, d.y - 2, 1, 5);
                        ctx.globalAlpha = 1;
                    }

                } else if (selectedDungeon === 'volcano') {
                    if (d.variant === 0) {
                        // Lava crack in floor
                        ctx.strokeStyle = '#ff4500';
                        ctx.globalAlpha = 0.4 + Math.sin(Date.now() / 1000 + d.x) * 0.15;
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(d.x - d.size, d.y + 1);
                        ctx.lineTo(d.x - 1, d.y - 1);
                        ctx.lineTo(d.x + d.size, d.y);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(d.x - 1, d.y - 1);
                        ctx.lineTo(d.x + 1, d.y + d.size);
                        ctx.stroke();
                        ctx.globalAlpha = 1;
                    } else if (d.variant === 1) {
                        // Scorch mark
                        ctx.fillStyle = '#1a0e08';
                        ctx.globalAlpha = 0.3;
                        ctx.beginPath();
                        ctx.ellipse(d.x, d.y, d.size + 1, d.size, d.x % 3, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1;
                    } else if (d.variant === 2) {
                        // Small lava pool
                        ctx.fillStyle = '#cc3300';
                        ctx.globalAlpha = 0.35 + Math.sin(Date.now() / 800 + d.y) * 0.1;
                        ctx.beginPath();
                        ctx.ellipse(d.x, d.y, d.size, d.size - 1, 0, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#ff6600';
                        ctx.beginPath();
                        ctx.ellipse(d.x, d.y, d.size * 0.5, d.size * 0.4, 0, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1;
                    } else if (d.variant === 3) {
                        // Cooled lava rock
                        ctx.fillStyle = '#2a1a14';
                        ctx.fillRect(d.x - 2, d.y - 1, 4, 3);
                        ctx.fillStyle = '#3a2a20';
                        ctx.fillRect(d.x - 1, d.y - 2, 3, 2);
                    } else if (d.variant === 4) {
                        // Ash patch
                        ctx.fillStyle = '#1a1210';
                        ctx.globalAlpha = 0.3;
                        ctx.beginPath();
                        ctx.arc(d.x, d.y, d.size + 1, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1;
                    } else {
                        // Glowing ember in floor
                        const pulse = Math.sin(Date.now() / 500 + d.x * d.y) * 0.3 + 0.5;
                        ctx.fillStyle = '#ff4500';
                        ctx.globalAlpha = pulse * 0.4;
                        ctx.beginPath();
                        ctx.arc(d.x, d.y, 2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1;
                    }

                } else {
                    // Dark Dungeon
                    if (d.variant === 0) {
                        // Cracked stone tiles
                        ctx.strokeStyle = '#3d3d5a';
                        ctx.globalAlpha = 0.3;
                        ctx.lineWidth = 1;
                        ctx.strokeRect(d.x - 5, d.y - 5, 10, 10);
                        ctx.beginPath();
                        ctx.moveTo(d.x - 5, d.y + 2);
                        ctx.lineTo(d.x, d.y - 1);
                        ctx.lineTo(d.x + 5, d.y + 1);
                        ctx.stroke();
                        ctx.globalAlpha = 1;
                    } else if (d.variant === 1) {
                        // Rubble pile
                        ctx.fillStyle = '#4a4a68';
                        ctx.fillRect(d.x - 2, d.y, 3, 2);
                        ctx.fillRect(d.x + 1, d.y - 1, 2, 2);
                        ctx.fillStyle = '#3a3a58';
                        ctx.fillRect(d.x - 1, d.y + 1, 4, 2);
                    } else if (d.variant === 2) {
                        // Old bones
                        ctx.fillStyle = '#8888a0';
                        ctx.globalAlpha = 0.4;
                        ctx.fillRect(d.x - 4, d.y, 8, 1);
                        ctx.fillRect(d.x - 1, d.y - 3, 1, 7);
                        // Skull
                        ctx.beginPath();
                        ctx.arc(d.x + 4, d.y - 1, 2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1;
                    } else if (d.variant === 3) {
                        // Puddle / water stain
                        ctx.fillStyle = '#2a2a44';
                        ctx.globalAlpha = 0.3;
                        ctx.beginPath();
                        ctx.ellipse(d.x, d.y, d.size + 1, d.size - 1, 0, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#3a3a5a';
                        ctx.globalAlpha = 0.15;
                        ctx.fillRect(d.x - 1, d.y - 1, 2, 1);
                        ctx.globalAlpha = 1;
                    } else if (d.variant === 4) {
                        // Chains on floor
                        ctx.strokeStyle = '#6a6a82';
                        ctx.globalAlpha = 0.3;
                        ctx.lineWidth = 1;
                        for (let c = 0; c < 3; c++) {
                            ctx.beginPath();
                            ctx.arc(d.x + c * 4 - 4, d.y, 2, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                        ctx.globalAlpha = 1;
                    } else {
                        // Cobweb corner
                        ctx.strokeStyle = '#5a5a72';
                        ctx.globalAlpha = 0.2;
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(d.x - 5, d.y - 5);
                        ctx.quadraticCurveTo(d.x, d.y - 2, d.x + 5, d.y - 5);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(d.x - 5, d.y - 5);
                        ctx.quadraticCurveTo(d.x - 2, d.y, d.x - 5, d.y + 5);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(d.x - 4, d.y - 3);
                        ctx.lineTo(d.x - 2, d.y - 1);
                        ctx.stroke();
                        ctx.globalAlpha = 1;
                    }
                }
            }
        }

        // Draw large level props (trees, pillars, etc.)
        function drawLevelProps() {
            for (const p of levelProps) {
                if (selectedDungeon === 'jungle') {
                    if (p.variant === 0 || p.variant === 1) {
                        // Tree
                        const trunkH = p.size + 8;
                        const canopyR = p.size * 0.8 + 4;
                        // Shadow
                        ctx.fillStyle = '#0a1a08';
                        ctx.globalAlpha = 0.2;
                        ctx.beginPath();
                        ctx.ellipse(p.x + 3, p.y + 2, canopyR + 2, canopyR * 0.5, 0, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1;
                        // Trunk
                        ctx.fillStyle = '#4a3520';
                        ctx.fillRect(p.x - 3, p.y - trunkH + canopyR * 0.5, 6, trunkH);
                        // Bark detail
                        ctx.fillStyle = '#3a2a18';
                        ctx.fillRect(p.x - 2, p.y - trunkH + canopyR * 0.5 + 4, 2, 3);
                        ctx.fillRect(p.x + 1, p.y - trunkH + canopyR * 0.5 + 10, 2, 2);
                        // Roots
                        ctx.fillStyle = '#4a3520';
                        ctx.fillRect(p.x - 6, p.y - 2, 4, 3);
                        ctx.fillRect(p.x + 3, p.y - 1, 5, 2);
                        // Canopy layers (overlapping circles)
                        const canopyY = p.y - trunkH + canopyR * 0.3;
                        ctx.fillStyle = '#1e5a18';
                        ctx.beginPath();
                        ctx.arc(p.x - canopyR * 0.3, canopyY + 2, canopyR * 0.7, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#2a7322';
                        ctx.beginPath();
                        ctx.arc(p.x + canopyR * 0.2, canopyY - 1, canopyR * 0.8, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#358a2e';
                        ctx.beginPath();
                        ctx.arc(p.x, canopyY - 3, canopyR * 0.6, 0, Math.PI * 2);
                        ctx.fill();
                        // Highlight dapples
                        ctx.fillStyle = '#4aaa40';
                        ctx.globalAlpha = 0.5;
                        ctx.beginPath();
                        ctx.arc(p.x - 3, canopyY - 5, canopyR * 0.25, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(p.x + 4, canopyY - 2, canopyR * 0.2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1;
                        if (p.variant === 1) {
                            // Variant 1: hanging fruit or flowers
                            ctx.fillStyle = '#e06050';
                            ctx.beginPath();
                            ctx.arc(p.x - canopyR * 0.4, canopyY + canopyR * 0.5, 2, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.fillStyle = '#e0c040';
                            ctx.beginPath();
                            ctx.arc(p.x + canopyR * 0.3, canopyY + canopyR * 0.6, 2, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    } else if (p.variant === 2) {
                        // Palm tree
                        const trunkH = p.size + 10;
                        // Shadow
                        ctx.fillStyle = '#0a1a08';
                        ctx.globalAlpha = 0.15;
                        ctx.beginPath();
                        ctx.ellipse(p.x + 4, p.y + 2, 12, 5, 0, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1;
                        // Curved trunk
                        ctx.strokeStyle = '#5a4a30';
                        ctx.lineWidth = 5;
                        ctx.beginPath();
                        ctx.moveTo(p.x, p.y);
                        ctx.quadraticCurveTo(p.x + 4, p.y - trunkH * 0.5, p.x + 2, p.y - trunkH);
                        ctx.stroke();
                        // Trunk rings
                        ctx.strokeStyle = '#4a3a22';
                        ctx.lineWidth = 1;
                        for (let r = 5; r < trunkH - 3; r += 5) {
                            ctx.beginPath();
                            const rx = p.x + 4 * Math.sin(r / trunkH * Math.PI);
                            ctx.moveTo(rx - 3, p.y - r);
                            ctx.lineTo(rx + 3, p.y - r);
                            ctx.stroke();
                        }
                        // Palm fronds
                        const topX = p.x + 2;
                        const topY = p.y - trunkH;
                        const frondAngles = [-2.4, -1.8, -1.0, -0.3, 0.3, 1.0];
                        for (const fa of frondAngles) {
                            const sway = Math.sin(Date.now() / 2000 + fa * 2) * 0.1;
                            ctx.strokeStyle = '#2d7826';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(topX, topY);
                            const endX = topX + Math.cos(fa + sway) * 16;
                            const endY = topY + Math.sin(fa + sway) * 14;
                            ctx.quadraticCurveTo(topX + Math.cos(fa) * 8, topY + Math.sin(fa) * 6 - 2, endX, endY);
                            ctx.stroke();
                            // Leaf segments
                            ctx.strokeStyle = '#3a9030';
                            ctx.lineWidth = 1;
                            for (let seg = 0.3; seg < 0.9; seg += 0.2) {
                                const sx = topX + (endX - topX) * seg;
                                const sy = topY + (endY - topY) * seg - (1 - seg) * 2;
                                ctx.beginPath();
                                ctx.moveTo(sx, sy);
                                ctx.lineTo(sx + Math.cos(fa + 1.2) * 4, sy + Math.sin(fa + 1.2) * 4);
                                ctx.stroke();
                                ctx.beginPath();
                                ctx.moveTo(sx, sy);
                                ctx.lineTo(sx + Math.cos(fa - 1.2) * 4, sy + Math.sin(fa - 1.2) * 4);
                                ctx.stroke();
                            }
                        }
                        // Coconuts
                        ctx.fillStyle = '#5a4020';
                        ctx.beginPath();
                        ctx.arc(topX - 2, topY + 3, 2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(topX + 2, topY + 2, 2, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        // Large rock / temple ruin
                        ctx.fillStyle = '#5a6a50';
                        ctx.fillRect(p.x - p.size * 0.5, p.y - p.size * 0.3, p.size, p.size * 0.6);
                        ctx.fillStyle = '#4a5a40';
                        ctx.fillRect(p.x - p.size * 0.4, p.y - p.size * 0.5, p.size * 0.8, p.size * 0.3);
                        // Moss on top
                        ctx.fillStyle = '#2d6b26';
                        ctx.fillRect(p.x - p.size * 0.4, p.y - p.size * 0.5, p.size * 0.6, 2);
                        // Vine on side
                        ctx.fillStyle = '#3a7c33';
                        ctx.fillRect(p.x + p.size * 0.4, p.y - p.size * 0.3, 2, p.size * 0.5);
                        ctx.fillStyle = '#4a9e40';
                        ctx.fillRect(p.x + p.size * 0.4 - 2, p.y - p.size * 0.1, 3, 2);
                    }

                } else if (selectedDungeon === 'desert') {
                    if (p.variant === 0) {
                        // Broken pillar
                        ctx.fillStyle = '#a08a60';
                        ctx.fillRect(p.x - 5, p.y - p.size, 10, p.size);
                        ctx.fillStyle = '#b8a070';
                        ctx.fillRect(p.x - 7, p.y - p.size, 14, 4);
                        ctx.fillRect(p.x - 7, p.y - 3, 14, 3);
                        // Cracks
                        ctx.strokeStyle = '#806a40';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(p.x - 3, p.y - p.size);
                        ctx.lineTo(p.x + 1, p.y - p.size + 6);
                        ctx.lineTo(p.x - 1, p.y - p.size + 12);
                        ctx.stroke();
                        // Sand at base
                        ctx.fillStyle = '#4a3c28';
                        ctx.globalAlpha = 0.3;
                        ctx.beginPath();
                        ctx.ellipse(p.x, p.y + 1, 10, 3, 0, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1;
                    } else if (p.variant === 1) {
                        // Sarcophagus
                        ctx.fillStyle = '#8a7a50';
                        ctx.fillRect(p.x - 6, p.y - 10, 12, 20);
                        ctx.fillStyle = '#a08a60';
                        ctx.fillRect(p.x - 7, p.y - 11, 14, 4);
                        ctx.fillRect(p.x - 7, p.y + 7, 14, 4);
                        ctx.fillStyle = '#c4a35a';
                        ctx.globalAlpha = 0.4;
                        ctx.fillRect(p.x - 3, p.y - 7, 6, 14);
                        ctx.globalAlpha = 1;
                        // Eye detail
                        ctx.fillStyle = '#4a3a20';
                        ctx.fillRect(p.x - 2, p.y - 4, 2, 2);
                        ctx.fillRect(p.x + 1, p.y - 4, 2, 2);
                    } else if (p.variant === 2) {
                        // Pile of urns
                        ctx.fillStyle = '#8a6a40';
                        ctx.beginPath();
                        ctx.arc(p.x - 4, p.y, 5, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#9a7a50';
                        ctx.beginPath();
                        ctx.arc(p.x + 5, p.y + 1, 4, 0, Math.PI * 2);
                        ctx.fill();
                        // Broken one
                        ctx.fillStyle = '#7a5a30';
                        ctx.beginPath();
                        ctx.arc(p.x, p.y - 6, 3, Math.PI, 0);
                        ctx.fill();
                        // Sand spilling
                        ctx.fillStyle = '#c4a35a';
                        ctx.globalAlpha = 0.3;
                        ctx.fillRect(p.x - 1, p.y - 3, 3, 5);
                        ctx.globalAlpha = 1;
                    } else {
                        // Rock formation
                        ctx.fillStyle = '#7a6a4a';
                        ctx.beginPath();
                        ctx.moveTo(p.x - 8, p.y + 3);
                        ctx.lineTo(p.x - 3, p.y - p.size * 0.5);
                        ctx.lineTo(p.x + 4, p.y - p.size * 0.3);
                        ctx.lineTo(p.x + 8, p.y + 3);
                        ctx.closePath();
                        ctx.fill();
                        ctx.fillStyle = '#8a7a5a';
                        ctx.fillRect(p.x - 2, p.y - p.size * 0.5 + 2, 4, 3);
                    }

                } else if (selectedDungeon === 'ice') {
                    if (p.variant === 0) {
                        // Ice stalagmite
                        ctx.fillStyle = '#7ab0cc';
                        ctx.beginPath();
                        ctx.moveTo(p.x - 5, p.y + 2);
                        ctx.lineTo(p.x - 1, p.y - p.size);
                        ctx.lineTo(p.x + 1, p.y - p.size);
                        ctx.lineTo(p.x + 5, p.y + 2);
                        ctx.closePath();
                        ctx.fill();
                        // Shine
                        ctx.fillStyle = '#b0d8e8';
                        ctx.fillRect(p.x - 1, p.y - p.size + 3, 2, p.size - 5);
                        ctx.fillStyle = '#d4eef8';
                        ctx.fillRect(p.x, p.y - p.size + 5, 1, p.size * 0.4);
                    } else if (p.variant === 1) {
                        // Frozen boulder
                        ctx.fillStyle = '#5a7a8a';
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.size * 0.5, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#8aaab8';
                        ctx.beginPath();
                        ctx.arc(p.x - 2, p.y - 2, p.size * 0.3, 0, Math.PI * 2);
                        ctx.fill();
                        // Ice overlay
                        ctx.fillStyle = '#aadcee';
                        ctx.globalAlpha = 0.3;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.size * 0.55, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1;
                    } else if (p.variant === 2) {
                        // Ice crystal cluster
                        ctx.fillStyle = '#8ecae6';
                        for (let c = 0; c < 4; c++) {
                            const ang = c * Math.PI / 2 + 0.3;
                            const len = p.size * 0.4 + c * 2;
                            ctx.beginPath();
                            ctx.moveTo(p.x - Math.cos(ang) * 2, p.y - Math.sin(ang) * 2);
                            ctx.lineTo(p.x + Math.cos(ang + 0.15) * len, p.y + Math.sin(ang + 0.15) * len);
                            ctx.lineTo(p.x + Math.cos(ang - 0.15) * len, p.y + Math.sin(ang - 0.15) * len);
                            ctx.closePath();
                            ctx.fill();
                        }
                        ctx.fillStyle = '#d4eef8';
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        // Snowdrift
                        ctx.fillStyle = '#8aaab8';
                        ctx.globalAlpha = 0.4;
                        ctx.beginPath();
                        ctx.ellipse(p.x, p.y, p.size, p.size * 0.4, 0, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#a0c0d0';
                        ctx.beginPath();
                        ctx.ellipse(p.x - 2, p.y - 1, p.size * 0.6, p.size * 0.25, 0, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1;
                    }

                } else if (selectedDungeon === 'volcano') {
                    if (p.variant === 0) {
                        // Obsidian spike
                        ctx.fillStyle = '#1a1210';
                        ctx.beginPath();
                        ctx.moveTo(p.x - 4, p.y + 2);
                        ctx.lineTo(p.x, p.y - p.size);
                        ctx.lineTo(p.x + 4, p.y + 2);
                        ctx.closePath();
                        ctx.fill();
                        ctx.fillStyle = '#2a2220';
                        ctx.fillRect(p.x - 1, p.y - p.size + 4, 2, p.size * 0.3);
                        // Red glow at base
                        ctx.fillStyle = '#ff4500';
                        ctx.globalAlpha = 0.2 + Math.sin(Date.now() / 1000 + p.x) * 0.1;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y + 2, 6, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1;
                    } else if (p.variant === 1) {
                        // Lava pool (larger)
                        const pulse = Math.sin(Date.now() / 900 + p.x * p.y) * 0.1;
                        ctx.fillStyle = '#8b2500';
                        ctx.globalAlpha = 0.5 + pulse;
                        ctx.beginPath();
                        ctx.ellipse(p.x, p.y, p.size * 0.7, p.size * 0.5, 0, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#cc4400';
                        ctx.beginPath();
                        ctx.ellipse(p.x, p.y, p.size * 0.4, p.size * 0.3, 0, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#ff6600';
                        ctx.beginPath();
                        ctx.ellipse(p.x + 1, p.y - 1, p.size * 0.2, p.size * 0.15, 0, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1;
                    } else if (p.variant === 2) {
                        // Charred tree stump
                        ctx.fillStyle = '#1a1008';
                        ctx.fillRect(p.x - 5, p.y - 6, 10, 8);
                        ctx.fillStyle = '#2a1a10';
                        ctx.fillRect(p.x - 6, p.y - 3, 12, 5);
                        // Embers
                        ctx.fillStyle = '#ff4500';
                        ctx.globalAlpha = 0.4 + Math.sin(Date.now() / 600 + p.y) * 0.2;
                        ctx.fillRect(p.x - 2, p.y - 7, 1, 2);
                        ctx.fillRect(p.x + 2, p.y - 6, 1, 1);
                        ctx.globalAlpha = 1;
                    } else {
                        // Volcanic boulder
                        ctx.fillStyle = '#3a2218';
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.size * 0.5, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#4a3228';
                        ctx.beginPath();
                        ctx.arc(p.x - 2, p.y - 2, p.size * 0.3, 0, Math.PI * 2);
                        ctx.fill();
                        // Lava crack
                        ctx.strokeStyle = '#ff4500';
                        ctx.globalAlpha = 0.4;
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(p.x - p.size * 0.3, p.y);
                        ctx.lineTo(p.x + p.size * 0.3, p.y - 1);
                        ctx.stroke();
                        ctx.globalAlpha = 1;
                    }

                } else {
                    // Dark Dungeon
                    if (p.variant === 0) {
                        // Stone pillar
                        ctx.fillStyle = '#5a5a78';
                        ctx.fillRect(p.x - 5, p.y - p.size, 10, p.size);
                        // Capital
                        ctx.fillStyle = '#6a6a88';
                        ctx.fillRect(p.x - 7, p.y - p.size, 14, 4);
                        // Base
                        ctx.fillRect(p.x - 7, p.y - 3, 14, 3);
                        // Highlight
                        ctx.fillStyle = '#7a7a98';
                        ctx.fillRect(p.x - 4, p.y - p.size + 4, 2, p.size - 7);
                    } else if (p.variant === 1) {
                        // Barrel
                        ctx.fillStyle = '#5a4030';
                        ctx.fillRect(p.x - 5, p.y - 7, 10, 14);
                        ctx.fillStyle = '#6a5040';
                        ctx.fillRect(p.x - 6, p.y - 5, 12, 3);
                        ctx.fillRect(p.x - 6, p.y + 2, 12, 3);
                        // Metal bands
                        ctx.fillStyle = '#4a4a5a';
                        ctx.fillRect(p.x - 6, p.y - 7, 12, 1);
                        ctx.fillRect(p.x - 6, p.y + 6, 12, 1);
                    } else if (p.variant === 2) {
                        // Crate
                        ctx.fillStyle = '#5a4830';
                        ctx.fillRect(p.x - 7, p.y - 7, 14, 14);
                        ctx.fillStyle = '#4a3820';
                        ctx.fillRect(p.x - 7, p.y, 14, 1);
                        ctx.fillRect(p.x, p.y - 7, 1, 14);
                        // Nail
                        ctx.fillStyle = '#888';
                        ctx.fillRect(p.x - 4, p.y - 4, 1, 1);
                        ctx.fillRect(p.x + 3, p.y + 3, 1, 1);
                    } else {
                        // Broken statue
                        ctx.fillStyle = '#5a5a6a';
                        // Base
                        ctx.fillRect(p.x - 6, p.y - 3, 12, 5);
                        // Broken torso
                        ctx.fillRect(p.x - 4, p.y - 10, 8, 8);
                        // One arm stub
                        ctx.fillRect(p.x + 4, p.y - 8, 4, 3);
                        // Rubble
                        ctx.fillStyle = '#4a4a5a';
                        ctx.fillRect(p.x - 8, p.y + 1, 3, 2);
                        ctx.fillRect(p.x + 6, p.y + 2, 4, 2);
                    }
                }
            }
        }

        // Draw dungeon-specific wall decorations
        function drawWallDecorations(wall) {
            const wx = Math.floor(wall.x);
            const wy = Math.floor(wall.y);
            const ww = wall.w;
            const wh = wall.h;
            const isHoriz = wh <= 20;
            const isVert = ww <= 20;

            if (selectedDungeon === 'jungle') {
                // Vines hanging from horizontal walls
                if (isHoriz) {
                    ctx.fillStyle = '#3a7c33';
                    for (let vx = wx + 6; vx < wx + ww - 6; vx += 14 + ((vx * 7 + wy) % 10)) {
                        const vineLen = 10 + ((vx * 3 + wy * 5) % 18);
                        const sway = Math.sin(Date.now() / 2000 + vx * 0.1) * 2;
                        ctx.fillRect(vx + sway * 0.3, wy + wh, 2, vineLen);
                        // Leaves at intervals
                        ctx.fillStyle = '#4a9e40';
                        ctx.fillRect(vx - 3 + sway * 0.5, wy + wh + 3, 4, 3);
                        ctx.fillRect(vx + 1 + sway * 0.7, wy + wh + 8, 5, 3);
                        if (vineLen > 12) {
                            ctx.fillRect(vx - 2 + sway, wy + wh + 14, 3, 2);
                            ctx.fillStyle = '#5ab84e';
                            ctx.fillRect(vx + 2, wy + wh + 12, 4, 2);
                        }
                        if (vineLen > 18) {
                            ctx.fillStyle = '#3a7c33';
                            ctx.fillRect(vx - 1, wy + wh + 18, 3, 3);
                        }
                        ctx.fillStyle = '#3a7c33';
                    }
                    // Hanging vines on TOP of wall
                    for (let vx = wx + 12; vx < wx + ww - 12; vx += 22 + ((vx * 11 + wy) % 14)) {
                        ctx.fillStyle = '#2d6b26';
                        const topLen = 5 + ((vx * 5 + wy) % 8);
                        ctx.fillRect(vx, wy - topLen, 1, topLen);
                        ctx.fillStyle = '#4a9e40';
                        ctx.fillRect(vx - 2, wy - topLen + 2, 3, 2);
                    }
                }
                if (isVert) {
                    // Vines on both sides of vertical walls
                    for (let vy = wy + 8; vy < wy + wh - 8; vy += 16 + ((wx * 3 + vy) % 8)) {
                        const vineLen = 8 + ((wx * 5 + vy * 3) % 12);
                        ctx.fillStyle = '#3a7c33';
                        // Right side
                        ctx.fillRect(wx + ww, vy, vineLen, 2);
                        ctx.fillStyle = '#4a9e40';
                        ctx.fillRect(wx + ww + 3, vy - 2, 3, 3);
                        ctx.fillRect(wx + ww + 7, vy + 1, 3, 2);
                        // Left side
                        ctx.fillStyle = '#3a7c33';
                        const vineLen2 = 5 + ((wx * 7 + vy) % 8);
                        ctx.fillRect(wx - vineLen2, vy + 5, vineLen2, 2);
                        ctx.fillStyle = '#4a9e40';
                        ctx.fillRect(wx - vineLen2 + 1, vy + 3, 3, 3);
                    }
                }
                // Moss/lichen patches on all walls
                ctx.fillStyle = '#2d6b26';
                ctx.globalAlpha = 0.5;
                for (let mx = wx + 3; mx < wx + ww - 4; mx += 10 + ((mx + wy) % 6)) {
                    ctx.fillRect(mx, wy + 1, 4 + ((mx * 3) % 4), 3);
                    ctx.fillRect(mx + 1, wy + wh - 4, 3 + ((mx * 7) % 3), 2);
                }
                ctx.globalAlpha = 1;
                // Flower buds on wall top
                if (isHoriz) {
                    for (let fx = wx + 15; fx < wx + ww - 15; fx += 30 + ((fx * 13 + wy) % 20)) {
                        ctx.fillStyle = '#2a5a20';
                        ctx.fillRect(fx, wy - 5, 1, 5);
                        ctx.fillStyle = ((fx * 7) % 3 === 0) ? '#e8e850' : ((fx * 7) % 3 === 1) ? '#e06090' : '#8060d0';
                        ctx.fillRect(fx - 2, wy - 7, 5, 3);
                    }
                }

            } else if (selectedDungeon === 'desert') {
                // Hieroglyphs on horizontal walls
                if (isHoriz) {
                    ctx.fillStyle = '#b8956a';
                    ctx.globalAlpha = 0.4;
                    for (let hx = wx + 8; hx < wx + ww - 8; hx += 18 + ((hx + wy) % 8)) {
                        const sym = (hx * 3 + wy * 7) % 6;
                        if (sym === 0) {
                            // Eye of Horus
                            ctx.fillRect(hx, wy + 5, 6, 2);
                            ctx.fillRect(hx + 2, wy + 3, 2, 6);
                            ctx.fillRect(hx + 5, wy + 7, 3, 4);
                        } else if (sym === 1) {
                            // Ankh
                            ctx.beginPath();
                            ctx.arc(hx + 3, wy + 5, 3, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.fillRect(hx + 2, wy + 8, 2, 6);
                            ctx.fillRect(hx, wy + 10, 6, 2);
                        } else if (sym === 2) {
                            // Water waves
                            ctx.fillRect(hx, wy + 7, 2, 2);
                            ctx.fillRect(hx + 3, wy + 5, 2, 2);
                            ctx.fillRect(hx + 6, wy + 7, 2, 2);
                            ctx.fillRect(hx + 9, wy + 5, 2, 2);
                        } else if (sym === 3) {
                            // Pyramid
                            ctx.beginPath();
                            ctx.moveTo(hx + 5, wy + 3);
                            ctx.lineTo(hx, wy + 13);
                            ctx.lineTo(hx + 10, wy + 13);
                            ctx.closePath();
                            ctx.fill();
                        } else if (sym === 4) {
                            // Bird shape (Ibis)
                            ctx.fillRect(hx + 2, wy + 4, 5, 3);
                            ctx.fillRect(hx, wy + 5, 2, 2);
                            ctx.fillRect(hx + 7, wy + 3, 3, 1);
                            ctx.fillRect(hx + 3, wy + 7, 1, 4);
                            ctx.fillRect(hx + 5, wy + 7, 1, 4);
                        } else {
                            // Sun disc
                            ctx.beginPath();
                            ctx.arc(hx + 4, wy + 8, 4, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.fillRect(hx, wy + 3, 1, 3);
                            ctx.fillRect(hx + 8, wy + 3, 1, 3);
                        }
                    }
                    ctx.globalAlpha = 1;
                    // Sand piling at base
                    ctx.fillStyle = '#4a3c28';
                    ctx.globalAlpha = 0.15;
                    for (let sx = wx; sx < wx + ww; sx += 12 + ((sx + wy) % 8)) {
                        const pile = 2 + ((sx * 3 + wy) % 4);
                        ctx.beginPath();
                        ctx.moveTo(sx, wy + wh);
                        ctx.lineTo(sx + 8, wy + wh);
                        ctx.lineTo(sx + 4, wy + wh + pile);
                        ctx.closePath();
                        ctx.fill();
                    }
                    ctx.globalAlpha = 1;
                }
                if (isVert) {
                    // Vertical cracks and sand erosion
                    ctx.fillStyle = '#b8956a';
                    ctx.globalAlpha = 0.3;
                    for (let cy = wy + 6; cy < wy + wh - 6; cy += 14 + ((wx + cy) % 10)) {
                        ctx.fillRect(wx + 3, cy, ww - 6, 1);
                        ctx.fillRect(wx + 5, cy - 2, 1, 5);
                        ctx.fillRect(wx + ww - 6, cy + 3, 1, 4);
                    }
                    ctx.globalAlpha = 1;
                    // Sand spilling from cracks
                    ctx.fillStyle = '#4a3c28';
                    ctx.globalAlpha = 0.15;
                    for (let sy = wy + 15; sy < wy + wh - 15; sy += 25 + ((wx + sy) % 12)) {
                        ctx.fillRect(wx + ww, sy, 3, 2);
                        ctx.fillRect(wx + ww + 1, sy + 2, 2, 3);
                    }
                    ctx.globalAlpha = 1;
                }
                // Worn/chipped edges
                ctx.fillStyle = COLORS.floor;
                ctx.globalAlpha = 0.3;
                for (let cx = wx + 5; cx < wx + ww - 5; cx += 20 + ((cx + wy) % 10)) {
                    ctx.fillRect(cx, wy, 3, 2);
                    ctx.fillRect(cx + 7, wy + wh - 2, 2, 2);
                }
                ctx.globalAlpha = 1;

            } else if (selectedDungeon === 'ice') {
                // Icicles on horizontal walls (top and bottom)
                if (isHoriz) {
                    // Bottom icicles
                    for (let ix = wx + 5; ix < wx + ww - 5; ix += 8 + ((ix + wy) % 6)) {
                        const iceLen = 6 + ((ix * 3 + wy) % 12);
                        ctx.fillStyle = '#aadcee';
                        ctx.beginPath();
                        ctx.moveTo(ix - 2, wy + wh);
                        ctx.lineTo(ix + 2, wy + wh);
                        ctx.lineTo(ix, wy + wh + iceLen);
                        ctx.closePath();
                        ctx.fill();
                        ctx.fillStyle = '#d4eef8';
                        ctx.fillRect(ix, wy + wh + 1, 1, Math.max(1, iceLen - 3));
                    }
                    // Top icicles (shorter, going up)
                    for (let ix = wx + 10; ix < wx + ww - 10; ix += 12 + ((ix * 7 + wy) % 10)) {
                        const iceLen = 3 + ((ix * 5 + wy) % 6);
                        ctx.fillStyle = '#9acade';
                        ctx.beginPath();
                        ctx.moveTo(ix - 1, wy);
                        ctx.lineTo(ix + 1, wy);
                        ctx.lineTo(ix, wy - iceLen);
                        ctx.closePath();
                        ctx.fill();
                    }
                    // Frost shimmer on wall surface
                    ctx.fillStyle = '#c0e0f0';
                    ctx.globalAlpha = 0.15;
                    ctx.fillRect(wx, wy, ww, wh);
                    ctx.globalAlpha = 1;
                }
                if (isVert) {
                    // Side icicles
                    for (let iy = wy + 6; iy < wy + wh - 6; iy += 10 + ((wx + iy) % 8)) {
                        const iceLen = 4 + ((wx * 3 + iy) % 8);
                        // Right side
                        ctx.fillStyle = '#aadcee';
                        ctx.beginPath();
                        ctx.moveTo(wx + ww, iy - 1);
                        ctx.lineTo(wx + ww, iy + 1);
                        ctx.lineTo(wx + ww + iceLen, iy);
                        ctx.closePath();
                        ctx.fill();
                        // Left side
                        const iceLen2 = 3 + ((wx * 7 + iy) % 6);
                        ctx.beginPath();
                        ctx.moveTo(wx, iy + 4);
                        ctx.lineTo(wx, iy + 6);
                        ctx.lineTo(wx - iceLen2, iy + 5);
                        ctx.closePath();
                        ctx.fill();
                    }
                    // Frost crystals
                    ctx.fillStyle = '#8ecae6';
                    ctx.globalAlpha = 0.3;
                    for (let fy = wy + 5; fy < wy + wh - 5; fy += 12 + ((wx + fy) % 6)) {
                        ctx.fillRect(wx + 2, fy, 3, 3);
                        ctx.fillRect(wx + ww - 5, fy + 4, 3, 3);
                    }
                    ctx.globalAlpha = 1;
                }
                // Frost overlay on wall
                ctx.fillStyle = '#c0e0f0';
                ctx.globalAlpha = 0.08;
                ctx.fillRect(wx, wy, ww, wh);
                ctx.globalAlpha = 1;

            } else if (selectedDungeon === 'volcano') {
                // Glowing cracks
                if (isHoriz) {
                    const glow = 0.4 + Math.sin(Date.now() / 1500) * 0.15;
                    ctx.fillStyle = '#ff6600';
                    ctx.globalAlpha = glow;
                    for (let cx = wx + 6; cx < wx + ww - 8; cx += 12 + ((cx + wy) % 8)) {
                        // Main crack
                        ctx.fillRect(cx, wy + 5, 8, 1);
                        // Branches
                        ctx.fillRect(cx + 2, wy + 3, 1, 5);
                        ctx.fillRect(cx + 6, wy + 2, 1, 4);
                        // Wider glow under crack
                        ctx.globalAlpha = glow * 0.3;
                        ctx.fillRect(cx - 1, wy + 4, 10, 3);
                        ctx.globalAlpha = glow;
                    }
                    // Glow on edges
                    ctx.fillStyle = '#ff4500';
                    ctx.globalAlpha = 0.15;
                    ctx.fillRect(wx, wy + wh - 2, ww, 3);
                    ctx.fillRect(wx, wy, ww, 2);
                    ctx.globalAlpha = 1;
                    // Charred spots
                    ctx.fillStyle = '#1a0c06';
                    ctx.globalAlpha = 0.3;
                    for (let sx = wx + 10; sx < wx + ww - 10; sx += 25 + ((sx + wy) % 15)) {
                        ctx.beginPath();
                        ctx.arc(sx, wy + wh + 4, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.globalAlpha = 1;
                }
                if (isVert) {
                    const glow = 0.35 + Math.sin(Date.now() / 1500 + 1) * 0.1;
                    ctx.fillStyle = '#ff6600';
                    ctx.globalAlpha = glow;
                    for (let cy = wy + 8; cy < wy + wh - 8; cy += 14 + ((wx + cy) % 10)) {
                        ctx.fillRect(wx + 3, cy, 1, 10);
                        ctx.fillRect(wx + ww - 4, cy + 5, 1, 10);
                        ctx.fillRect(wx + 2, cy + 4, 5, 1);
                    }
                    // Edge glow
                    ctx.fillStyle = '#ff4500';
                    ctx.globalAlpha = 0.12;
                    ctx.fillRect(wx + ww - 1, wy, 2, wh);
                    ctx.fillRect(wx - 1, wy, 2, wh);
                    ctx.globalAlpha = 1;
                }
                // Soot / dark patches
                ctx.fillStyle = '#0a0604';
                ctx.globalAlpha = 0.2;
                for (let dx = wx + 4; dx < wx + ww - 4; dx += 16 + ((dx + wy) % 8)) {
                    ctx.fillRect(dx, wy + 2, 5, 3);
                }
                ctx.globalAlpha = 1;

            } else {
                // Dark Dungeon - full brickwork
                ctx.fillStyle = '#7d7daa';
                ctx.globalAlpha = 0.2;
                if (isHoriz) {
                    // Brick rows
                    ctx.fillRect(wx, wy + 8, ww, 1);
                    for (let bx = wx + 10; bx < wx + ww; bx += 20 + ((bx + wy) % 5)) {
                        ctx.fillRect(bx, wy + 1, 1, 7);
                        ctx.fillRect(bx + 10, wy + 9, 1, 7);
                    }
                    // Weathered edges
                    ctx.fillStyle = COLORS.floor;
                    ctx.globalAlpha = 0.15;
                    for (let ex = wx + 8; ex < wx + ww - 8; ex += 22 + ((ex + wy) % 10)) {
                        ctx.fillRect(ex, wy + wh - 1, 3, 2);
                        ctx.fillRect(ex + 6, wy, 2, 2);
                    }
                } else {
                    // Vertical brickwork
                    for (let by = wy + 8; by < wy + wh; by += 10) {
                        ctx.fillStyle = '#7d7daa';
                        ctx.globalAlpha = 0.2;
                        ctx.fillRect(wx + 2, by, ww - 4, 1);
                    }
                }
                ctx.globalAlpha = 1;

                // Torches on long walls
                const torchPositions = [];
                if (isHoriz && ww > 50) {
                    for (let tx = wx + 25; tx < wx + ww - 20; tx += 50 + ((tx + wy) % 18)) {
                        torchPositions.push({ x: tx, y: wy - 6, side: 'top' });
                    }
                } else if (isVert && wh > 40) {
                    for (let ty = wy + 18; ty < wy + wh - 18; ty += 45 + ((wx + ty) % 16)) {
                        torchPositions.push({ x: wx + ww + 3, y: ty, side: 'right' });
                    }
                }
                for (const tp of torchPositions) {
                    // Bracket
                    ctx.fillStyle = '#5d4e37';
                    ctx.fillRect(tp.x - 1, tp.y + 2, 3, 6);
                    // Flame (flickering)
                    const flicker = Math.sin(Date.now() / 200 + tp.x + tp.y) * 1;
                    ctx.fillStyle = '#ff8c00';
                    ctx.fillRect(tp.x - 2 + flicker * 0.3, tp.y - 2, 5, 4);
                    ctx.fillStyle = '#ffcc00';
                    ctx.fillRect(tp.x - 1, tp.y - 4, 3, 3);
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(tp.x, tp.y - 3, 1, 2);
                    // Light glow
                    ctx.fillStyle = '#ffcc00';
                    ctx.globalAlpha = 0.06;
                    ctx.beginPath();
                    ctx.arc(tp.x, tp.y, 18, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                }

                // Cobwebs in corners where walls meet outer edges
                if (isHoriz && (wx <= 20 || wx + ww >= W - 20)) {
                    const cobX = wx <= 20 ? wx : wx + ww;
                    ctx.strokeStyle = '#6a6a82';
                    ctx.globalAlpha = 0.2;
                    ctx.lineWidth = 1;
                    for (let s = 0; s < 4; s++) {
                        const ang = (s / 4) * Math.PI * 0.5;
                        ctx.beginPath();
                        ctx.moveTo(cobX, wy + wh);
                        ctx.quadraticCurveTo(cobX + Math.cos(ang) * 8, wy + wh + Math.sin(ang) * 8, cobX + Math.cos(ang) * 14, wy + wh + Math.sin(ang) * 14);
                        ctx.stroke();
                    }
                    ctx.globalAlpha = 1;
                }

                // Banner/tapestry on long walls
                if (isHoriz && ww > 80) {
                    for (let bx = wx + 40; bx < wx + ww - 30; bx += 80 + ((bx + wy) % 30)) {
                        const bannerColors = ['#6b2020', '#20406b', '#3b6b20'];
                        ctx.fillStyle = bannerColors[(bx * 3 + wy) % bannerColors.length];
                        ctx.fillRect(bx - 4, wy - 12, 8, 14);
                        // Banner trim
                        ctx.fillStyle = '#c8b060';
                        ctx.fillRect(bx - 4, wy - 12, 8, 1);
                        ctx.fillRect(bx - 4, wy + 1, 3, 2);
                        ctx.fillRect(bx + 1, wy + 1, 3, 2);
                        // Rod
                        ctx.fillStyle = '#5d4e37';
                        ctx.fillRect(bx - 6, wy - 13, 12, 2);
                    }
                }
            }
        }

        // Spawn ambient dungeon particles
        function spawnAmbientParticles() {
            if (gameState !== 'playing') return;
            if (selectedDungeon === 'jungle') {
                // Falling leaves / pollen
                if (Math.random() < 0.03) {
                    particles.push({
                        x: Math.random() * W,
                        y: 25,
                        vx: (Math.random() - 0.5) * 0.5,
                        vy: 0.3 + Math.random() * 0.3,
                        life: 120,
                        color: Math.random() > 0.5 ? '#4a9e40' : '#e8e850'
                    });
                }
                // Fireflies
                if (Math.random() < 0.01) {
                    particles.push({
                        x: 30 + Math.random() * (W - 60),
                        y: 30 + Math.random() * (H - 60),
                        vx: (Math.random() - 0.5) * 0.3,
                        vy: (Math.random() - 0.5) * 0.3,
                        life: 80,
                        color: '#ccff44'
                    });
                }
            } else if (selectedDungeon === 'desert') {
                // Blowing sand
                if (Math.random() < 0.04) {
                    particles.push({
                        x: 20,
                        y: 30 + Math.random() * (H - 60),
                        vx: 0.8 + Math.random() * 0.6,
                        vy: (Math.random() - 0.5) * 0.2,
                        life: 80,
                        color: '#c4a35a'
                    });
                }
                // Dust motes
                if (Math.random() < 0.02) {
                    particles.push({
                        x: 30 + Math.random() * (W - 60),
                        y: 30 + Math.random() * (H - 60),
                        vx: (Math.random() - 0.5) * 0.2,
                        vy: -0.1 - Math.random() * 0.2,
                        life: 60,
                        color: '#a68b4b'
                    });
                }
            } else if (selectedDungeon === 'ice') {
                // Snowflakes
                if (Math.random() < 0.05) {
                    particles.push({
                        x: Math.random() * W,
                        y: 25,
                        vx: (Math.random() - 0.5) * 0.4,
                        vy: 0.2 + Math.random() * 0.4,
                        life: 150,
                        color: '#d4eef8'
                    });
                }
                // Frost sparkle
                if (Math.random() < 0.01) {
                    particles.push({
                        x: 30 + Math.random() * (W - 60),
                        y: 30 + Math.random() * (H - 60),
                        vx: 0,
                        vy: 0,
                        life: 20,
                        color: '#fff'
                    });
                }
            } else if (selectedDungeon === 'volcano') {
                // Floating embers
                if (Math.random() < 0.04) {
                    particles.push({
                        x: 30 + Math.random() * (W - 60),
                        y: H - 30,
                        vx: (Math.random() - 0.5) * 0.5,
                        vy: -0.5 - Math.random() * 0.8,
                        life: 100,
                        color: Math.random() > 0.5 ? '#ff4500' : '#ff8c00'
                    });
                }
                // Smoke wisps
                if (Math.random() < 0.02) {
                    particles.push({
                        x: 30 + Math.random() * (W - 60),
                        y: 30 + Math.random() * (H - 60),
                        vx: (Math.random() - 0.5) * 0.15,
                        vy: -0.2 - Math.random() * 0.2,
                        life: 60,
                        color: '#333'
                    });
                }
            } else {
                // Dungeon dust motes
                if (Math.random() < 0.015) {
                    particles.push({
                        x: 30 + Math.random() * (W - 60),
                        y: 30 + Math.random() * (H - 60),
                        vx: (Math.random() - 0.5) * 0.1,
                        vy: -0.05 - Math.random() * 0.1,
                        life: 80,
                        color: '#5a5a72'
                    });
                }
                // Dripping water
                if (Math.random() < 0.005) {
                    particles.push({
                        x: 30 + Math.random() * (W - 60),
                        y: 25,
                        vx: 0,
                        vy: 1.5,
                        life: 30,
                        color: '#4a4a8a'
                    });
                }
            }
        }

        // Draw player
        function drawPlayer() {
            const px = Math.floor(player.x - player.width / 2);
            const py = Math.floor(player.y - player.height / 2);

            // Body
            drawPixelRect(px, py, player.width, player.height, COLORS.player, COLORS.playerDark);

            // Armor outline
            if (playerArmorTier > 0) {
                const armorColor = ARMOR_TIERS[playerArmorTier - 1].color;
                ctx.strokeStyle = armorColor;
                ctx.lineWidth = 2;
                ctx.strokeRect(px - 1, py - 1, player.width + 2, player.height + 2);
            }

            // Draw gun based on weapon type
            const weapon = WEAPONS[player.weapon];
            const weaponColor = weapon ? weapon.color : '#666';

            ctx.save();
            ctx.translate(player.x, player.y);
            ctx.rotate(player.angle);

            // Gun shapes for each weapon type
            if (player.weapon === 'pistol') {
                // Compact pistol
                ctx.fillStyle = '#444';
                ctx.fillRect(4, -3, 10, 6); // Body
                ctx.fillStyle = weaponColor;
                ctx.fillRect(6, -2, 8, 4); // Slide
                ctx.fillStyle = '#333';
                ctx.fillRect(4, 1, 4, 4); // Grip
            } else if (player.weapon === 'smg') {
                // SMG with extended barrel
                ctx.fillStyle = '#333';
                ctx.fillRect(4, -3, 14, 6); // Body
                ctx.fillStyle = weaponColor;
                ctx.fillRect(6, -2, 12, 4); // Upper
                ctx.fillStyle = '#222';
                ctx.fillRect(4, 1, 5, 5); // Grip
                ctx.fillRect(10, 2, 3, 3); // Magazine
            } else if (player.weapon === 'shotgun') {
                // Wide shotgun
                ctx.fillStyle = '#5d4e37';
                ctx.fillRect(4, -4, 16, 8); // Body
                ctx.fillStyle = weaponColor;
                ctx.fillRect(14, -3, 6, 6); // Barrel
                ctx.fillStyle = '#3d3229';
                ctx.fillRect(4, 1, 6, 5); // Stock
            } else if (player.weapon === 'rifle') {
                // Long rifle
                ctx.fillStyle = '#2c3e50';
                ctx.fillRect(4, -3, 18, 6); // Body
                ctx.fillStyle = weaponColor;
                ctx.fillRect(8, -2, 14, 4); // Upper
                ctx.fillStyle = '#1a252f';
                ctx.fillRect(4, 1, 5, 4); // Stock
                ctx.fillRect(16, -4, 2, 2); // Scope
            } else if (player.weapon === 'railgun') {
                // Futuristic railgun
                ctx.fillStyle = '#2c2c54';
                ctx.fillRect(4, -4, 20, 8); // Body
                ctx.fillStyle = weaponColor;
                ctx.fillRect(8, -3, 16, 6); // Core
                // Glowing effect
                ctx.fillStyle = '#fff';
                ctx.fillRect(18, -2, 6, 4); // Barrel glow
                ctx.fillStyle = weaponColor;
                ctx.globalAlpha = 0.5;
                ctx.fillRect(20, -3, 4, 6); // Energy glow
                ctx.globalAlpha = 1;
            } else if (player.weapon === 'minigun') {
                // Multi-barrel minigun
                ctx.fillStyle = '#444';
                ctx.fillRect(4, -5, 18, 10); // Body
                ctx.fillStyle = weaponColor;
                ctx.fillRect(14, -6, 8, 3); // Top barrel
                ctx.fillRect(14, -2, 8, 3); // Mid barrel
                ctx.fillRect(14, 2, 8, 3); // Bot barrel
                ctx.fillStyle = '#333';
                ctx.fillRect(4, 1, 6, 6); // Grip
            } else if (player.weapon === 'sword') {
                // Sword with swing animation
                const swingOffset = player.swinging ? (player.swingProgress - 0.5) * weapon.arc : 0;
                ctx.rotate(swingOffset);
                // Handle
                ctx.fillStyle = '#5d4e37';
                ctx.fillRect(4, -2, 8, 4);
                // Crossguard
                ctx.fillStyle = '#8b7355';
                ctx.fillRect(10, -5, 3, 10);
                // Blade
                ctx.fillStyle = weaponColor;
                ctx.fillRect(13, -3, 22, 6);
                // Blade highlight
                ctx.fillStyle = '#fff';
                ctx.fillRect(15, -2, 18, 2);
                // Blade tip
                ctx.fillStyle = '#a0a0a0';
                ctx.beginPath();
                ctx.moveTo(35, -3);
                ctx.lineTo(40, 0);
                ctx.lineTo(35, 3);
                ctx.fill();
            } else if (player.weapon === 'katana') {
                // Katana with swing animation
                const swingOffset = player.swinging ? (player.swingProgress - 0.5) * weapon.arc : 0;
                ctx.rotate(swingOffset);
                // Wrapped handle
                ctx.fillStyle = '#2c2c2c';
                ctx.fillRect(4, -2, 10, 4);
                ctx.fillStyle = '#8b0000'; // Red wrapping
                ctx.fillRect(5, -2, 2, 4);
                ctx.fillRect(9, -2, 2, 4);
                // Circular guard (tsuba)
                ctx.fillStyle = '#4a4a4a';
                ctx.beginPath();
                ctx.arc(14, 0, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#ffd700';
                ctx.beginPath();
                ctx.arc(14, 0, 2, 0, Math.PI * 2);
                ctx.fill();
                // Curved blade
                ctx.fillStyle = weaponColor;
                ctx.beginPath();
                ctx.moveTo(18, -2);
                ctx.quadraticCurveTo(35, -4, 50, -1);
                ctx.lineTo(50, 1);
                ctx.quadraticCurveTo(35, 2, 18, 2);
                ctx.closePath();
                ctx.fill();
                // Blade edge highlight
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(20, -1);
                ctx.quadraticCurveTo(35, -3, 48, -1);
                ctx.stroke();
            } else if (player.weapon === 'sniper') {
                // Long sniper rifle
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(4, -3, 28, 6); // Long body
                ctx.fillStyle = weaponColor;
                ctx.fillRect(6, -2, 24, 4); // Upper receiver
                ctx.fillStyle = '#4a3728';
                ctx.fillRect(4, 1, 8, 5); // Stock
                ctx.fillStyle = '#333';
                ctx.fillRect(26, -4, 8, 2); // Scope
                ctx.fillRect(26, -2, 8, 1);
                ctx.fillStyle = '#5af';
                ctx.fillRect(27, -3, 2, 1); // Scope lens
                ctx.fillRect(32, -3, 2, 1);
            } else if (player.weapon === 'flamethrower') {
                // Flamethrower with tank
                ctx.fillStyle = '#444';
                ctx.fillRect(4, -4, 16, 8); // Body
                ctx.fillStyle = weaponColor;
                ctx.fillRect(16, -3, 12, 6); // Nozzle
                ctx.fillStyle = '#666';
                ctx.fillRect(0, -6, 8, 12); // Tank
                ctx.fillStyle = '#ff6600';
                ctx.fillRect(1, -5, 6, 10); // Tank contents
                ctx.fillStyle = '#333';
                ctx.fillRect(4, 2, 6, 4); // Grip
                // Flame effect when shooting
                if (mouseDown && player.ammo > 0 && player.shootCooldown === 0) {
                    ctx.fillStyle = '#ff0';
                    ctx.beginPath();
                    ctx.moveTo(28, 0);
                    ctx.lineTo(38 + Math.random() * 8, -4 + Math.random() * 8);
                    ctx.lineTo(38 + Math.random() * 8, -4 + Math.random() * 8);
                    ctx.fill();
                }
            } else if (player.weapon === 'rocketlauncher') {
                // Rocket launcher tube
                ctx.fillStyle = '#3d3d3d';
                ctx.fillRect(4, -5, 24, 10); // Tube
                ctx.fillStyle = weaponColor;
                ctx.fillRect(6, -4, 20, 8); // Inner tube
                ctx.fillStyle = '#222';
                ctx.fillRect(24, -6, 4, 12); // Front rim
                ctx.fillRect(4, -6, 3, 12); // Back rim
                ctx.fillStyle = '#444';
                ctx.fillRect(10, 4, 8, 4); // Handle
                ctx.fillStyle = '#8b0000';
                ctx.fillRect(12, -3, 4, 6); // Rocket visible
            } else if (player.weapon === 'bomb') {
                // Holding a bomb
                ctx.fillStyle = weaponColor;
                ctx.beginPath();
                ctx.arc(12, 0, 8, 0, Math.PI * 2);
                ctx.fill();
                // Fuse
                ctx.strokeStyle = '#8b4513';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(18, -4);
                ctx.quadraticCurveTo(22, -8, 20, -12);
                ctx.stroke();
                // Fuse spark
                ctx.fillStyle = '#ff4500';
                ctx.beginPath();
                ctx.arc(20, -12, 3, 0, Math.PI * 2);
                ctx.fill();
            } else {
                // Default fallback
                ctx.fillStyle = '#666';
                ctx.fillRect(4, -2, 12, 4);
            }

            ctx.restore();

            // Eyes (facing mouse direction)
            ctx.fillStyle = '#fff';
            const eyeOffsetX = Math.cos(player.angle) * 3;
            const eyeOffsetY = Math.sin(player.angle) * 3;
            ctx.fillRect(px + 4 + eyeOffsetX, py + 4 + eyeOffsetY, 3, 3);
            ctx.fillRect(px + 9 + eyeOffsetX, py + 4 + eyeOffsetY, 3, 3);
        }

        // Draw enemy with unique sprites per dungeon/type
        function drawEnemy(enemy) {
            const cx = enemy.x;
            const cy = enemy.y;
            const type = ENEMY_TYPES[enemy.type] || ENEMY_TYPES.grunt;
            const s = enemy.width / 14; // Scale factor based on base size 14

            ctx.save();
            ctx.translate(cx, cy);

            // Draw based on dungeon and enemy type
            if (selectedDungeon === 'jungle') {
                if (enemy.type === 'grunt') {
                    // Tribesman - humanoid with spear
                    ctx.fillStyle = '#8B4513'; // Skin
                    ctx.fillRect(-4*s, -5*s, 8*s, 10*s); // Body
                    ctx.fillStyle = '#5d4e37';
                    ctx.fillRect(-3*s, 4*s, 6*s, 3*s); // Skirt
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(-3*s, -7*s, 6*s, 4*s); // Head
                    ctx.fillStyle = '#2d5a27'; // Green headband
                    ctx.fillRect(-4*s, -6*s, 8*s, 2*s);
                    ctx.fillStyle = '#4a3728'; // Spear
                    ctx.fillRect(5*s, -8*s, 2*s, 14*s);
                    ctx.fillStyle = '#888';
                    ctx.fillRect(5*s, -10*s, 2*s, 3*s); // Spear tip
                } else if (enemy.type === 'charger') {
                    // Jaguar - cat shape with spots
                    ctx.fillStyle = '#c9a227'; // Body
                    ctx.fillRect(-6*s, -3*s, 12*s, 6*s);
                    ctx.fillStyle = '#a68520';
                    ctx.fillRect(-7*s, -2*s, 4*s, 4*s); // Head
                    ctx.fillRect(4*s, -1*s, 4*s, 2*s); // Tail
                    ctx.fillStyle = '#1a1a1a'; // Spots
                    ctx.fillRect(-3*s, -2*s, 2*s, 2*s);
                    ctx.fillRect(1*s, 0*s, 2*s, 2*s);
                    ctx.fillRect(-1*s, -2*s, 1*s, 1*s);
                    ctx.fillStyle = '#fff'; // Eyes
                    ctx.fillRect(-6*s, -2*s, 2*s, 2*s);
                    ctx.fillStyle = '#4a3728'; // Legs
                    ctx.fillRect(-5*s, 2*s, 2*s, 3*s);
                    ctx.fillRect(2*s, 2*s, 2*s, 3*s);
                } else if (enemy.type === 'tank') {
                    // Gorilla - large ape
                    ctx.fillStyle = '#4a4a4a';
                    ctx.fillRect(-8*s, -6*s, 16*s, 14*s); // Body
                    ctx.fillStyle = '#333';
                    ctx.fillRect(-6*s, -9*s, 12*s, 5*s); // Head
                    ctx.fillStyle = '#6a6a6a';
                    ctx.fillRect(-4*s, -7*s, 8*s, 3*s); // Face
                    ctx.fillStyle = '#222';
                    ctx.fillRect(-2*s, -5*s, 4*s, 2*s); // Nose/mouth
                    ctx.fillStyle = '#4a4a4a'; // Arms
                    ctx.fillRect(-11*s, -4*s, 4*s, 10*s);
                    ctx.fillRect(7*s, -4*s, 4*s, 10*s);
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(-4*s, -8*s, 2*s, 2*s);
                    ctx.fillRect(2*s, -8*s, 2*s, 2*s);
                } else if (enemy.type === 'sniper') {
                    // Hunter with bow
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(-3*s, -5*s, 6*s, 10*s); // Body
                    ctx.fillRect(-2*s, -7*s, 4*s, 3*s); // Head
                    ctx.fillStyle = '#2d5a27';
                    ctx.fillRect(-4*s, -4*s, 8*s, 6*s); // Cloak
                    ctx.fillStyle = '#5d4e37'; // Bow
                    ctx.beginPath();
                    ctx.arc(5*s, 0, 5*s, -Math.PI/2, Math.PI/2);
                    ctx.lineWidth = 2*s;
                    ctx.strokeStyle = '#5d4e37';
                    ctx.stroke();
                } else if (enemy.type === 'boss') {
                    // Shaman with headdress
                    ctx.fillStyle = '#2d5a27';
                    ctx.fillRect(-12*s, -12*s, 24*s, 26*s); // Robe
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(-6*s, -16*s, 12*s, 8*s); // Head
                    ctx.fillStyle = '#c9a227'; // Headdress feathers
                    ctx.fillRect(-10*s, -22*s, 4*s, 8*s);
                    ctx.fillRect(-4*s, -24*s, 4*s, 10*s);
                    ctx.fillRect(2*s, -24*s, 4*s, 10*s);
                    ctx.fillRect(8*s, -22*s, 4*s, 8*s);
                    ctx.fillStyle = '#4a3728'; // Staff
                    ctx.fillRect(14*s, -18*s, 3*s, 30*s);
                    ctx.fillStyle = '#2ecc71'; // Magic orb
                    ctx.beginPath();
                    ctx.arc(15*s, -20*s, 4*s, 0, Math.PI*2);
                    ctx.fill();
                }
            } else if (selectedDungeon === 'desert') {
                if (enemy.type === 'grunt') {
                    // Mummy - wrapped figure
                    ctx.fillStyle = '#c4a35a';
                    ctx.fillRect(-4*s, -6*s, 8*s, 12*s); // Body
                    ctx.fillRect(-3*s, -8*s, 6*s, 4*s); // Head
                    ctx.fillStyle = '#a68b4b'; // Wrap lines
                    ctx.fillRect(-4*s, -4*s, 8*s, 1*s);
                    ctx.fillRect(-4*s, 0*s, 8*s, 1*s);
                    ctx.fillRect(-4*s, 3*s, 8*s, 1*s);
                    ctx.fillStyle = '#1a1a1a'; // Eyes
                    ctx.fillRect(-2*s, -7*s, 2*s, 2*s);
                    ctx.fillRect(1*s, -7*s, 2*s, 2*s);
                    ctx.fillStyle = '#4a3728'; // Arms out
                    ctx.fillRect(-7*s, -3*s, 4*s, 2*s);
                    ctx.fillRect(4*s, -3*s, 4*s, 2*s);
                } else if (enemy.type === 'charger') {
                    // Scarab beetle
                    ctx.fillStyle = '#1a1a2e';
                    ctx.beginPath();
                    ctx.ellipse(0, 0, 5*s, 4*s, 0, 0, Math.PI*2);
                    ctx.fill();
                    ctx.fillStyle = '#2a2a4e'; // Shell shine
                    ctx.beginPath();
                    ctx.ellipse(-1*s, -1*s, 2*s, 1.5*s, 0, 0, Math.PI*2);
                    ctx.fill();
                    ctx.fillStyle = '#0d0d17'; // Head
                    ctx.fillRect(-2*s, -5*s, 4*s, 2*s);
                    ctx.fillStyle = '#c4a35a'; // Legs
                    ctx.fillRect(-6*s, -2*s, 2*s, 1*s);
                    ctx.fillRect(-6*s, 1*s, 2*s, 1*s);
                    ctx.fillRect(4*s, -2*s, 2*s, 1*s);
                    ctx.fillRect(4*s, 1*s, 2*s, 1*s);
                } else if (enemy.type === 'tank') {
                    // Sand Golem
                    ctx.fillStyle = '#d4a574';
                    ctx.fillRect(-8*s, -8*s, 16*s, 18*s); // Body
                    ctx.fillStyle = '#b8956a';
                    ctx.fillRect(-6*s, -10*s, 12*s, 6*s); // Head
                    ctx.fillRect(-11*s, -5*s, 5*s, 10*s); // Arms
                    ctx.fillRect(6*s, -5*s, 5*s, 10*s);
                    ctx.fillStyle = '#8b7355'; // Cracks
                    ctx.fillRect(-4*s, -2*s, 2*s, 6*s);
                    ctx.fillRect(2*s, 0*s, 2*s, 5*s);
                    ctx.fillStyle = '#ffd700'; // Glowing eyes
                    ctx.fillRect(-4*s, -9*s, 3*s, 2*s);
                    ctx.fillRect(1*s, -9*s, 3*s, 2*s);
                } else if (enemy.type === 'sniper') {
                    // Desert Archer
                    ctx.fillStyle = '#8b7355';
                    ctx.fillRect(-3*s, -5*s, 6*s, 10*s); // Robe
                    ctx.fillStyle = '#c4a35a';
                    ctx.fillRect(-2*s, -7*s, 4*s, 3*s); // Head wrap
                    ctx.fillStyle = '#6b5a45';
                    ctx.fillRect(-4*s, -6*s, 8*s, 2*s); // Headband
                    ctx.fillStyle = '#4a3728'; // Bow
                    ctx.fillRect(4*s, -6*s, 2*s, 12*s);
                    ctx.fillRect(3*s, -6*s, 4*s, 2*s);
                    ctx.fillRect(3*s, 4*s, 4*s, 2*s);
                } else if (enemy.type === 'boss') {
                    // Pharaoh
                    ctx.fillStyle = '#ffd700';
                    ctx.fillRect(-14*s, -14*s, 28*s, 30*s); // Robe
                    ctx.fillStyle = '#c4a35a';
                    ctx.fillRect(-8*s, -18*s, 16*s, 8*s); // Head
                    ctx.fillStyle = '#ffd700'; // Crown
                    ctx.fillRect(-10*s, -24*s, 20*s, 8*s);
                    ctx.fillRect(-4*s, -28*s, 8*s, 6*s);
                    ctx.fillStyle = '#e74c3c'; // Crown gem
                    ctx.fillRect(-2*s, -26*s, 4*s, 3*s);
                    ctx.fillStyle = '#1a1a2e'; // Eyes
                    ctx.fillRect(-5*s, -16*s, 3*s, 2*s);
                    ctx.fillRect(2*s, -16*s, 3*s, 2*s);
                    ctx.fillStyle = '#b8860b'; // Staff
                    ctx.fillRect(16*s, -20*s, 3*s, 35*s);
                    ctx.fillStyle = '#ffd700';
                    ctx.fillRect(14*s, -24*s, 7*s, 6*s);
                }
            } else if (selectedDungeon === 'ice') {
                if (enemy.type === 'grunt') {
                    // Frost Knight
                    ctx.fillStyle = '#5a8fa8';
                    ctx.fillRect(-5*s, -5*s, 10*s, 12*s); // Armor
                    ctx.fillStyle = '#4a7a8f';
                    ctx.fillRect(-4*s, -8*s, 8*s, 5*s); // Helmet
                    ctx.fillRect(-3*s, -6*s, 6*s, 2*s); // Visor
                    ctx.fillStyle = '#8ecae6'; // Ice glow
                    ctx.fillRect(-2*s, -5*s, 1*s, 1*s);
                    ctx.fillRect(1*s, -5*s, 1*s, 1*s);
                    ctx.fillStyle = '#4a7a8f'; // Sword
                    ctx.fillRect(5*s, -8*s, 2*s, 14*s);
                    ctx.fillStyle = '#8ecae6';
                    ctx.fillRect(5*s, -10*s, 2*s, 3*s);
                } else if (enemy.type === 'charger') {
                    // Ice Wolf
                    ctx.fillStyle = '#a8c8d8';
                    ctx.fillRect(-6*s, -3*s, 12*s, 6*s); // Body
                    ctx.fillStyle = '#8ab0c0';
                    ctx.fillRect(-8*s, -4*s, 5*s, 5*s); // Head
                    ctx.fillRect(4*s, -2*s, 5*s, 2*s); // Tail
                    ctx.fillStyle = '#fff'; // Fur detail
                    ctx.fillRect(-5*s, -2*s, 8*s, 2*s);
                    ctx.fillStyle = '#5a8fa8'; // Eyes
                    ctx.fillRect(-7*s, -3*s, 2*s, 2*s);
                    ctx.fillStyle = '#4a7a8f'; // Nose
                    ctx.fillRect(-9*s, -2*s, 2*s, 2*s);
                    ctx.fillStyle = '#8ab0c0'; // Legs
                    ctx.fillRect(-5*s, 2*s, 2*s, 3*s);
                    ctx.fillRect(2*s, 2*s, 2*s, 3*s);
                    // Ears
                    ctx.fillRect(-7*s, -6*s, 2*s, 3*s);
                    ctx.fillRect(-4*s, -6*s, 2*s, 3*s);
                } else if (enemy.type === 'tank') {
                    // Yeti
                    ctx.fillStyle = '#e8f0f0';
                    ctx.fillRect(-9*s, -8*s, 18*s, 18*s); // Body
                    ctx.fillStyle = '#c8d8d8';
                    ctx.fillRect(-7*s, -12*s, 14*s, 6*s); // Head
                    ctx.fillRect(-12*s, -5*s, 5*s, 12*s); // Arms
                    ctx.fillRect(7*s, -5*s, 5*s, 12*s);
                    ctx.fillStyle = '#5a8fa8'; // Eyes
                    ctx.fillRect(-4*s, -10*s, 3*s, 2*s);
                    ctx.fillRect(1*s, -10*s, 3*s, 2*s);
                    ctx.fillStyle = '#4a7a8f'; // Mouth
                    ctx.fillRect(-3*s, -7*s, 6*s, 2*s);
                } else if (enemy.type === 'sniper') {
                    // Ice Mage
                    ctx.fillStyle = '#87ceeb';
                    ctx.fillRect(-4*s, -5*s, 8*s, 12*s); // Robe
                    ctx.fillStyle = '#5f9ea0';
                    ctx.fillRect(-3*s, -8*s, 6*s, 4*s); // Hood
                    ctx.fillStyle = '#fff'; // Eyes glow
                    ctx.fillRect(-2*s, -6*s, 2*s, 2*s);
                    ctx.fillRect(1*s, -6*s, 2*s, 2*s);
                    ctx.fillStyle = '#4a7a8f'; // Staff
                    ctx.fillRect(5*s, -10*s, 2*s, 16*s);
                    ctx.fillStyle = '#8ecae6'; // Ice crystal
                    ctx.fillRect(4*s, -14*s, 4*s, 5*s);
                } else if (enemy.type === 'boss') {
                    // Frost Giant
                    ctx.fillStyle = '#4a90a8';
                    ctx.fillRect(-16*s, -14*s, 32*s, 34*s); // Body
                    ctx.fillStyle = '#3a7088';
                    ctx.fillRect(-12*s, -20*s, 24*s, 10*s); // Head
                    ctx.fillRect(-20*s, -10*s, 8*s, 20*s); // Arms
                    ctx.fillRect(12*s, -10*s, 8*s, 20*s);
                    ctx.fillStyle = '#8ecae6'; // Eyes
                    ctx.fillRect(-8*s, -18*s, 5*s, 4*s);
                    ctx.fillRect(3*s, -18*s, 5*s, 4*s);
                    ctx.fillStyle = '#fff'; // Ice armor
                    ctx.fillRect(-14*s, -8*s, 28*s, 4*s);
                    ctx.fillRect(-14*s, 4*s, 28*s, 4*s);
                }
            } else if (selectedDungeon === 'volcano') {
                if (enemy.type === 'grunt') {
                    // Fire Imp
                    ctx.fillStyle = '#ff6b35';
                    ctx.fillRect(-4*s, -4*s, 8*s, 10*s); // Body
                    ctx.fillStyle = '#cc5528';
                    ctx.fillRect(-3*s, -6*s, 6*s, 4*s); // Head
                    ctx.fillStyle = '#8b0000'; // Horns
                    ctx.fillRect(-4*s, -8*s, 2*s, 3*s);
                    ctx.fillRect(2*s, -8*s, 2*s, 3*s);
                    ctx.fillStyle = '#ffff00'; // Eyes
                    ctx.fillRect(-2*s, -5*s, 2*s, 2*s);
                    ctx.fillRect(1*s, -5*s, 2*s, 2*s);
                    ctx.fillStyle = '#ff4500'; // Tail
                    ctx.fillRect(3*s, 2*s, 4*s, 2*s);
                    ctx.fillRect(6*s, 0*s, 2*s, 3*s);
                } else if (enemy.type === 'charger') {
                    // Hellhound
                    ctx.fillStyle = '#8b0000';
                    ctx.fillRect(-6*s, -3*s, 12*s, 6*s); // Body
                    ctx.fillStyle = '#5c0000';
                    ctx.fillRect(-8*s, -4*s, 5*s, 5*s); // Head
                    ctx.fillRect(4*s, -2*s, 4*s, 2*s); // Tail
                    ctx.fillStyle = '#ff4500'; // Flames on back
                    ctx.fillRect(-4*s, -5*s, 3*s, 3*s);
                    ctx.fillRect(0*s, -6*s, 3*s, 4*s);
                    ctx.fillRect(-2*s, -4*s, 2*s, 2*s);
                    ctx.fillStyle = '#ffff00'; // Eyes
                    ctx.fillRect(-7*s, -3*s, 2*s, 2*s);
                    ctx.fillStyle = '#5c0000'; // Legs
                    ctx.fillRect(-5*s, 2*s, 2*s, 3*s);
                    ctx.fillRect(2*s, 2*s, 2*s, 3*s);
                } else if (enemy.type === 'tank') {
                    // Lava Golem
                    ctx.fillStyle = '#4a2c2a';
                    ctx.fillRect(-9*s, -8*s, 18*s, 18*s); // Body
                    ctx.fillStyle = '#3a1c1a';
                    ctx.fillRect(-7*s, -12*s, 14*s, 6*s); // Head
                    ctx.fillRect(-12*s, -5*s, 5*s, 12*s); // Arms
                    ctx.fillRect(7*s, -5*s, 5*s, 12*s);
                    ctx.fillStyle = '#ff8c00'; // Lava cracks
                    ctx.fillRect(-6*s, -4*s, 2*s, 8*s);
                    ctx.fillRect(2*s, -2*s, 2*s, 6*s);
                    ctx.fillRect(-3*s, 2*s, 6*s, 2*s);
                    ctx.fillStyle = '#ffff00'; // Eyes
                    ctx.fillRect(-4*s, -10*s, 3*s, 2*s);
                    ctx.fillRect(1*s, -10*s, 3*s, 2*s);
                } else if (enemy.type === 'sniper') {
                    // Fire Mage
                    ctx.fillStyle = '#4a2c2a';
                    ctx.fillRect(-4*s, -5*s, 8*s, 12*s); // Robe
                    ctx.fillStyle = '#3a1c1a';
                    ctx.fillRect(-3*s, -8*s, 6*s, 4*s); // Hood
                    ctx.fillStyle = '#ff4500'; // Eyes
                    ctx.fillRect(-2*s, -6*s, 2*s, 2*s);
                    ctx.fillRect(1*s, -6*s, 2*s, 2*s);
                    ctx.fillStyle = '#4a2c2a'; // Staff
                    ctx.fillRect(5*s, -10*s, 2*s, 16*s);
                    ctx.fillStyle = '#ff4500'; // Fire
                    ctx.fillRect(4*s, -14*s, 4*s, 5*s);
                    ctx.fillStyle = '#ffff00';
                    ctx.fillRect(5*s, -13*s, 2*s, 3*s);
                } else if (enemy.type === 'boss') {
                    // Fire Dragon
                    ctx.fillStyle = '#ff4500';
                    ctx.fillRect(-16*s, -10*s, 32*s, 24*s); // Body
                    ctx.fillStyle = '#cc3700';
                    ctx.fillRect(-20*s, -14*s, 12*s, 10*s); // Head
                    ctx.fillRect(12*s, -6*s, 12*s, 6*s); // Tail
                    ctx.fillStyle = '#8b0000'; // Horns
                    ctx.fillRect(-18*s, -20*s, 3*s, 8*s);
                    ctx.fillRect(-12*s, -20*s, 3*s, 8*s);
                    ctx.fillStyle = '#ff8c00'; // Wings
                    ctx.fillRect(-14*s, -18*s, 8*s, 10*s);
                    ctx.fillRect(6*s, -18*s, 8*s, 10*s);
                    ctx.fillStyle = '#ffff00'; // Eyes
                    ctx.fillRect(-18*s, -12*s, 4*s, 3*s);
                    ctx.fillStyle = '#ff4500'; // Fire breath particles
                    ctx.fillRect(-24*s, -10*s, 5*s, 3*s);
                    ctx.fillRect(-26*s, -8*s, 4*s, 2*s);
                }
            } else {
                // Dungeon (default)
                if (enemy.type === 'grunt') {
                    // Guard - armored humanoid
                    ctx.fillStyle = '#e74c3c';
                    ctx.fillRect(-4*s, -5*s, 8*s, 10*s); // Armor
                    ctx.fillStyle = '#c0392b';
                    ctx.fillRect(-3*s, -7*s, 6*s, 4*s); // Helmet
                    ctx.fillStyle = '#888';
                    ctx.fillRect(-4*s, -6*s, 8*s, 2*s); // Visor
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(-2*s, -5*s, 1*s, 1*s);
                    ctx.fillRect(1*s, -5*s, 1*s, 1*s);
                    ctx.fillStyle = '#666'; // Sword
                    ctx.fillRect(5*s, -6*s, 2*s, 10*s);
                } else if (enemy.type === 'charger') {
                    // Goblin - small green creature
                    ctx.fillStyle = '#2ecc71';
                    ctx.fillRect(-4*s, -3*s, 8*s, 8*s); // Body
                    ctx.fillStyle = '#27ae60';
                    ctx.fillRect(-3*s, -6*s, 6*s, 5*s); // Head
                    ctx.fillStyle = '#1e8449'; // Ears
                    ctx.fillRect(-5*s, -5*s, 3*s, 3*s);
                    ctx.fillRect(2*s, -5*s, 3*s, 3*s);
                    ctx.fillStyle = '#ff0';
                    ctx.fillRect(-2*s, -4*s, 2*s, 2*s);
                    ctx.fillRect(1*s, -4*s, 2*s, 2*s);
                    ctx.fillStyle = '#c0392b'; // Nose
                    ctx.fillRect(-1*s, -2*s, 2*s, 2*s);
                } else if (enemy.type === 'tank') {
                    // Ogre - large brute
                    ctx.fillStyle = '#e67e22';
                    ctx.fillRect(-8*s, -6*s, 16*s, 16*s); // Body
                    ctx.fillStyle = '#d35400';
                    ctx.fillRect(-6*s, -10*s, 12*s, 6*s); // Head
                    ctx.fillRect(-10*s, -3*s, 4*s, 10*s); // Arms
                    ctx.fillRect(6*s, -3*s, 4*s, 10*s);
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(-3*s, -8*s, 2*s, 2*s);
                    ctx.fillRect(1*s, -8*s, 2*s, 2*s);
                    ctx.fillStyle = '#333'; // Mouth
                    ctx.fillRect(-3*s, -5*s, 6*s, 2*s);
                } else if (enemy.type === 'sniper') {
                    // Dark Mage
                    ctx.fillStyle = '#9b59b6';
                    ctx.fillRect(-4*s, -5*s, 8*s, 12*s); // Robe
                    ctx.fillStyle = '#8e44ad';
                    ctx.fillRect(-3*s, -8*s, 6*s, 4*s); // Hood
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(-2*s, -6*s, 2*s, 2*s);
                    ctx.fillRect(1*s, -6*s, 2*s, 2*s);
                    ctx.fillStyle = '#5d4e37'; // Staff
                    ctx.fillRect(5*s, -10*s, 2*s, 16*s);
                    ctx.fillStyle = '#9b59b6'; // Magic orb
                    ctx.beginPath();
                    ctx.arc(6*s, -12*s, 3*s, 0, Math.PI*2);
                    ctx.fill();
                } else if (enemy.type === 'boss') {
                    // Dark Knight
                    ctx.fillStyle = '#4a4a6a';
                    ctx.fillRect(-14*s, -12*s, 28*s, 28*s); // Armor
                    ctx.fillStyle = '#3a3a5a';
                    ctx.fillRect(-10*s, -18*s, 20*s, 10*s); // Helmet
                    ctx.fillRect(-18*s, -8*s, 6*s, 16*s); // Arms
                    ctx.fillRect(12*s, -8*s, 6*s, 16*s);
                    ctx.fillStyle = '#e74c3c'; // Eyes
                    ctx.fillRect(-6*s, -15*s, 4*s, 3*s);
                    ctx.fillRect(2*s, -15*s, 4*s, 3*s);
                    ctx.fillStyle = '#666'; // Sword
                    ctx.fillRect(18*s, -20*s, 4*s, 30*s);
                    ctx.fillStyle = '#888';
                    ctx.fillRect(17*s, -24*s, 6*s, 6*s);
                }
            }

            ctx.restore();

            // Health bar
            const ex = Math.floor(enemy.x - enemy.width / 2);
            const ey = Math.floor(enemy.y - enemy.height / 2);
            const healthPercent = enemy.health / enemy.maxHealth;
            ctx.fillStyle = '#333';
            ctx.fillRect(ex, ey - 10, enemy.width, 4);
            ctx.fillStyle = COLORS.health;
            ctx.fillRect(ex, ey - 10, enemy.width * healthPercent, 4);
        }

        // Check collision between rectangles
        function rectCollision(a, b) {
            return a.x < b.x + b.w &&
                   a.x + a.w > b.x &&
                   a.y < b.y + b.h &&
                   a.y + a.h > b.y;
        }

        // Check if point is in wall
        function pointInWalls(x, y, width, height) {
            for (const wall of walls) {
                if (rectCollision(
                    { x: x - width/2, y: y - height/2, w: width, h: height },
                    wall
                )) {
                    return true;
                }
            }
            return false;
        }

        // Update player
        function updatePlayer() {
            if (gameState !== 'playing') return;

            // Regen Aura charm: heal 1 HP every 3 seconds (180 ticks at 60fps)
            if (playerCharms.includes('regen_aura')) {
                regenTimer++;
                if (regenTimer >= 180) {
                    regenTimer = 0;
                    player.health = Math.min(player.health + 1, player.maxHealth);
                }
            }

            let newX = player.x;
            let newY = player.y;

            // Keyboard controls
            if (keys['w'] || keys['W']) newY -= player.speed;
            if (keys['s'] || keys['S']) newY += player.speed;
            if (keys['a'] || keys['A']) newX -= player.speed;
            if (keys['d'] || keys['D']) newX += player.speed;

            // Touch controls (mobile)
            if (isMobile) {
                newX += touchMove.x * player.speed * 2;
                newY += touchMove.y * player.speed * 2;
            }

            // Check wall collisions
            if (!pointInWalls(newX, player.y, player.width, player.height)) {
                player.x = newX;
            }
            if (!pointInWalls(player.x, newY, player.width, player.height)) {
                player.y = newY;
            }

            // Aim angle
            player.angle = Math.atan2(mouseY - player.y, mouseX - player.x);

            // Shooting / Melee
            if (player.shootCooldown > 0) player.shootCooldown--;

            // Update swing animation
            if (player.swinging) {
                player.swingProgress += 1 / WEAPONS[player.weapon].fireRate;
                if (player.swingProgress >= 1) {
                    player.swinging = false;
                    player.swingProgress = 0;
                }
            }

            const weapon = WEAPONS[player.weapon];
            if (weapon.melee) {
                // Melee weapon attack
                if (mouseDown && player.shootCooldown === 0 && !player.swinging) {
                    meleeAttack();
                    player.swinging = true;
                    player.swingProgress = 0;
                    player.shootCooldown = weapon.fireRate;
                }
            } else if (mouseDown && player.ammo >= weapon.ammoUse && player.shootCooldown === 0 && !player.reloading) {
                // Check if in safe zone (can't shoot from there)
                const inSafeZone = Math.hypot(player.x - safeZone.x, player.y - safeZone.y) < safeZone.radius;
                if (!inSafeZone) {
                    if (player.weapon === 'shotgun') {
                        for (let i = 0; i < weapon.pellets; i++) {
                            const spread = (Math.random() - 0.5) * 0.4;
                            shoot(player.x, player.y, player.angle + spread, true);
                        }
                    } else if (player.weapon === 'flamethrower') {
                        shootFlame(player.x, player.y, player.angle);
                    } else if (player.weapon === 'rocketlauncher') {
                        shootRocket(player.x, player.y, player.angle);
                    } else if (player.weapon === 'bomb') {
                        placeBomb(player.x, player.y);
                    } else if (player.weapon === 'sniper') {
                        shoot(player.x, player.y, player.angle, true, false);
                    } else {
                        shoot(player.x, player.y, player.angle, true, player.weapon === 'railgun');
                    }
                    player.ammo -= weapon.ammoUse;
                    player.shootCooldown = weapon.fireRate;
                }
            }

            // Reloading
            if (player.reloading) {
                player.reloadTime--;
                if (player.reloadTime <= 0) {
                    player.ammo = player.maxAmmo;
                    player.reloading = false;
                }
            }

            // Auto-reload when empty, or manual reload with R (not for melee or placeable weapons)
            if (!weapon.melee && !weapon.placeable && !player.reloading && (player.ammo === 0 || keys['r'] || keys['R'])) {
                if (player.ammo < player.maxAmmo) {
                    player.reloading = true;
                    player.reloadTime = 60;
                }
            }

            // Check pickup collisions
            for (let i = pickups.length - 1; i >= 0; i--) {
                const p = pickups[i];
                const dist = Math.hypot(player.x - p.x, player.y - p.y);
                // Check distance and line of sight (can't pick up through walls)
                if (dist < 20 && !lineOfSightBlocked(player.x, player.y, p.x, p.y)) {
                    if (p.type === 'health') {
                        player.health = Math.min(player.health + 50, player.maxHealth);
                        pickups.splice(i, 1);
                    } else if (p.type === 'ammo') {
                        // Ammo only works for ranged weapons
                        const currentWeapon = WEAPONS[player.weapon];
                        if (!currentWeapon.melee) {
                            player.ammo = Math.min(player.ammo + 15, player.maxAmmo);
                            pickups.splice(i, 1);
                        }
                    } else if (p.type === 'scrap') {
                        // Collect scrap (run currency)
                        scrap += p.value || 1;
                        // Scrap particles
                        for (let j = 0; j < 3; j++) {
                            particles.push({
                                x: p.x, y: p.y,
                                vx: (Math.random() - 0.5) * 2,
                                vy: (Math.random() - 0.5) * 2,
                                life: 15,
                                color: '#95a5a6'
                            });
                        }
                        pickups.splice(i, 1);
                    } else if (p.type === 'coin') {
                        // Collect coin
                        coins += p.value || 1;
                        saveProgress();
                        // Coin particles
                        for (let j = 0; j < 5; j++) {
                            particles.push({
                                x: p.x,
                                y: p.y,
                                vx: (Math.random() - 0.5) * 3,
                                vy: (Math.random() - 0.5) * 3,
                                life: 20,
                                color: '#ffd700'
                            });
                        }
                        pickups.splice(i, 1);
                    } else if (WEAPONS[p.type] && p.type !== player.weapon) {
                        // Drop current weapon if not pistol
                        const oldWeapon = player.weapon;
                        player.weapon = p.type;
                        const newWeapon = WEAPONS[p.type];
                        if (newWeapon.melee) {
                            // Melee weapons don't use ammo
                            player.maxAmmo = 0;
                            player.ammo = 0;
                        } else {
                            let baseMax = newWeapon.maxAmmo;
                            if (playerCharms.includes('big_magazines')) {
                                baseMax = Math.floor(baseMax * 1.5);
                            }
                            player.maxAmmo = baseMax;
                            player.ammo = player.maxAmmo;
                        }
                        // Stop any ongoing reload
                        player.reloading = false;
                        if (oldWeapon !== 'pistol') {
                            pickups.push({
                                x: p.x,
                                y: p.y,
                                type: oldWeapon,
                                width: 16,
                                height: 16
                            });
                        }
                        pickups.splice(i, 1);
                    }
                }
            }

            // Update UI
            document.getElementById('health').textContent = `Health: ${player.health}`;
            const weaponName = player.weapon.charAt(0).toUpperCase() + player.weapon.slice(1);
            const currentWeapon = WEAPONS[player.weapon];
            if (currentWeapon.melee) {
                document.getElementById('ammo').textContent = `${weaponName}: Ready`;
            } else {
                document.getElementById('ammo').textContent = player.reloading ? 'Reloading...' : `${weaponName}: ${player.ammo}`;
            }
            document.getElementById('score').textContent = `Score: ${score} | $${coins} | S:${scrap}`;
            document.getElementById('level').textContent = `Building: ${currentLevel}`;
        }

        // Shoot bullet
        function shoot(x, y, angle, isPlayer, pierce = false) {
            // Can't shoot from safe zone
            if (isPlayer && Math.hypot(player.x - safeZone.x, player.y - safeZone.y) < safeZone.radius) {
                return;
            }
            const speed = isPlayer ? (pierce ? 12 : 5) : 2.5;
            const weapon = isPlayer ? WEAPONS[player.weapon] : null;
            const damage = weapon ? (weapon.damage || 20) : 10;
            bullets.push({
                x: x,
                y: y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                isPlayer: isPlayer,
                life: 200,
                pierce: pierce,
                damage: pierce ? damage * 2 : damage,
                color: weapon ? weapon.color : COLORS.bullet
            });

            // Muzzle flash particles
            for (let i = 0; i < 3; i++) {
                particles.push({
                    x: x + Math.cos(angle) * 10,
                    y: y + Math.sin(angle) * 10,
                    vx: Math.cos(angle + (Math.random() - 0.5)) * 2,
                    vy: Math.sin(angle + (Math.random() - 0.5)) * 2,
                    life: 10,
                    color: '#ff0'
                });
            }
        }

        // Shoot flame (flamethrower)
        function shootFlame(x, y, angle) {
            // Can't shoot from safe zone
            if (Math.hypot(player.x - safeZone.x, player.y - safeZone.y) < safeZone.radius) {
                return;
            }
            const weapon = WEAPONS.flamethrower;
            const spread = (Math.random() - 0.5) * 0.5;
            const speed = 4 + Math.random() * 2;
            bullets.push({
                x: x + Math.cos(angle) * 15,
                y: y + Math.sin(angle) * 15,
                vx: Math.cos(angle + spread) * speed,
                vy: Math.sin(angle + spread) * speed,
                isPlayer: true,
                life: 25,
                damage: weapon.damage,
                color: '#ff4500',
                flame: true
            });

            // Flame particles
            for (let i = 0; i < 2; i++) {
                particles.push({
                    x: x + Math.cos(angle) * 20,
                    y: y + Math.sin(angle) * 20,
                    vx: Math.cos(angle + (Math.random() - 0.5) * 0.8) * 3,
                    vy: Math.sin(angle + (Math.random() - 0.5) * 0.8) * 3,
                    life: 15,
                    color: Math.random() > 0.5 ? '#ff0' : '#ff6600'
                });
            }
        }

        // Shoot rocket (rocket launcher)
        function shootRocket(x, y, angle) {
            // Can't shoot from safe zone
            if (Math.hypot(player.x - safeZone.x, player.y - safeZone.y) < safeZone.radius) {
                return;
            }
            const weapon = WEAPONS.rocketlauncher;
            bullets.push({
                x: x + Math.cos(angle) * 15,
                y: y + Math.sin(angle) * 15,
                vx: Math.cos(angle) * 4,
                vy: Math.sin(angle) * 4,
                isPlayer: true,
                life: 300,
                damage: weapon.damage,
                color: '#8b0000',
                explosive: true,
                explosionRadius: weapon.explosionRadius
            });

            // Smoke trail at launch
            for (let i = 0; i < 5; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: -Math.cos(angle) * 2 + (Math.random() - 0.5) * 2,
                    vy: -Math.sin(angle) * 2 + (Math.random() - 0.5) * 2,
                    life: 20,
                    color: '#888'
                });
            }
        }

        // Explode rocket
        function explodeRocket(x, y, radius, damage) {
            // Explosion particles
            for (let i = 0; i < 20; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 5 + 2;
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 25,
                    color: Math.random() > 0.3 ? '#ff4500' : '#ff0'
                });
            }
            // Smoke
            for (let i = 0; i < 10; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 3 + 1;
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 35,
                    color: '#555'
                });
            }

            // Damage all enemies in radius
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                const dist = Math.hypot(enemy.x - x, enemy.y - y);
                if (dist <= radius) {
                    // Damage falls off with distance
                    const damageMultiplier = 1 - (dist / radius) * 0.5;
                    enemy.health -= Math.floor(damage * damageMultiplier);

                    // Knockback
                    const knockAngle = Math.atan2(enemy.y - y, enemy.x - x);
                    const knockbackDist = 20 * (1 - dist / radius);
                    const newX = enemy.x + Math.cos(knockAngle) * knockbackDist;
                    const newY = enemy.y + Math.sin(knockAngle) * knockbackDist;
                    if (!pointInWalls(newX, enemy.y, enemy.width, enemy.height)) {
                        enemy.x = newX;
                    }
                    if (!pointInWalls(enemy.x, newY, enemy.width, enemy.height)) {
                        enemy.y = newY;
                    }

                    // Hit particles
                    for (let k = 0; k < 5; k++) {
                        particles.push({
                            x: enemy.x,
                            y: enemy.y,
                            vx: (Math.random() - 0.5) * 4,
                            vy: (Math.random() - 0.5) * 4,
                            life: 20,
                            color: COLORS.enemy
                        });
                    }

                    if (enemy.health <= 0) {
                        onEnemyKill(enemy);
                        // Death particles
                        for (let k = 0; k < 15; k++) {
                            particles.push({
                                x: enemy.x,
                                y: enemy.y,
                                vx: (Math.random() - 0.5) * 6,
                                vy: (Math.random() - 0.5) * 6,
                                life: 30,
                                color: COLORS.enemy
                            });
                        }
                        enemies.splice(i, 1);
                    }
                }
            }

        }

        // Place bomb
        function placeBomb(x, y) {
            // Can't place in safe zone
            if (Math.hypot(x - safeZone.x, y - safeZone.y) < safeZone.radius) {
                return;
            }
            const weapon = WEAPONS.bomb;
            bombs.push({
                x: x,
                y: y,
                fuseTime: weapon.fuseTime,
                damage: weapon.damage,
                radius: weapon.explosionRadius
            });

            // Place sound effect (particles)
            for (let i = 0; i < 5; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 3,
                    vy: (Math.random() - 0.5) * 3,
                    life: 15,
                    color: '#888'
                });
            }
        }

        // Update bombs
        function updateBombs() {
            for (let i = bombs.length - 1; i >= 0; i--) {
                const bomb = bombs[i];
                bomb.fuseTime--;

                // Sparking particles while fuse burns
                if (bomb.fuseTime % 10 === 0) {
                    particles.push({
                        x: bomb.x,
                        y: bomb.y - 10,
                        vx: (Math.random() - 0.5) * 2,
                        vy: -Math.random() * 2,
                        life: 10,
                        color: Math.random() > 0.5 ? '#ff4500' : '#ff0'
                    });
                }

                // Explode when fuse runs out
                if (bomb.fuseTime <= 0) {
                    explodeBomb(bomb.x, bomb.y, bomb.radius, bomb.damage);
                    bombs.splice(i, 1);
                }
            }
        }

        // Explode bomb
        function explodeBomb(x, y, radius, damage) {
            // Big explosion particles
            for (let i = 0; i < 30; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 7 + 3;
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 35,
                    color: Math.random() > 0.3 ? '#ff4500' : '#ff0'
                });
            }
            // Lots of smoke
            for (let i = 0; i < 20; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 4 + 1;
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 50,
                    color: '#333'
                });
            }

            // Damage all enemies in radius
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                const dist = Math.hypot(enemy.x - x, enemy.y - y);
                if (dist <= radius) {
                    // Damage falls off with distance
                    const damageMultiplier = 1 - (dist / radius) * 0.5;
                    enemy.health -= Math.floor(damage * damageMultiplier);

                    // Knockback
                    const knockAngle = Math.atan2(enemy.y - y, enemy.x - x);
                    const knockbackDist = 30 * (1 - dist / radius);
                    const newX = enemy.x + Math.cos(knockAngle) * knockbackDist;
                    const newY = enemy.y + Math.sin(knockAngle) * knockbackDist;
                    if (!pointInWalls(newX, enemy.y, enemy.width, enemy.height)) {
                        enemy.x = newX;
                    }
                    if (!pointInWalls(enemy.x, newY, enemy.width, enemy.height)) {
                        enemy.y = newY;
                    }

                    // Hit particles
                    for (let k = 0; k < 8; k++) {
                        particles.push({
                            x: enemy.x,
                            y: enemy.y,
                            vx: (Math.random() - 0.5) * 5,
                            vy: (Math.random() - 0.5) * 5,
                            life: 25,
                            color: COLORS.enemy
                        });
                    }

                    if (enemy.health <= 0) {
                        onEnemyKill(enemy);
                        // Death particles
                        for (let k = 0; k < 15; k++) {
                            particles.push({
                                x: enemy.x,
                                y: enemy.y,
                                vx: (Math.random() - 0.5) * 6,
                                vy: (Math.random() - 0.5) * 6,
                                life: 30,
                                color: COLORS.enemy
                            });
                        }
                        enemies.splice(i, 1);
                    }
                }
            }

        }

        // Check if line of sight is blocked by walls
        function lineOfSightBlocked(x1, y1, x2, y2) {
            const steps = Math.ceil(Math.hypot(x2 - x1, y2 - y1) / 5);
            for (let i = 1; i < steps; i++) {
                const t = i / steps;
                const checkX = x1 + (x2 - x1) * t;
                const checkY = y1 + (y2 - y1) * t;
                if (pointInWalls(checkX, checkY, 2, 2)) {
                    return true;
                }
            }
            return false;
        }

        // Melee attack
        function meleeAttack() {
            // Can't attack from safe zone
            if (Math.hypot(player.x - safeZone.x, player.y - safeZone.y) < safeZone.radius) {
                return;
            }

            const weapon = WEAPONS[player.weapon];
            const range = weapon.range;
            const arc = weapon.arc;
            const damage = weapon.damage;

            // Create swing particles
            for (let i = 0; i < 8; i++) {
                const particleAngle = player.angle - arc/2 + (arc * i / 7);
                const dist = range * 0.8;
                particles.push({
                    x: player.x + Math.cos(particleAngle) * dist,
                    y: player.y + Math.sin(particleAngle) * dist,
                    vx: Math.cos(particleAngle) * 2,
                    vy: Math.sin(particleAngle) * 2,
                    life: 15,
                    color: weapon.color
                });
            }

            // Check all enemies within arc range
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                const dist = Math.hypot(enemy.x - player.x, enemy.y - player.y);

                // Check if enemy is within range
                if (dist <= range + enemy.width / 2) {
                    // Check if enemy is within arc
                    const angleToEnemy = Math.atan2(enemy.y - player.y, enemy.x - player.x);
                    let angleDiff = angleToEnemy - player.angle;
                    // Normalize angle difference to -PI to PI
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;

                    if (Math.abs(angleDiff) <= arc / 2) {
                        // Check if wall blocks the attack
                        if (lineOfSightBlocked(player.x, player.y, enemy.x, enemy.y)) {
                            continue;
                        }

                        // Hit enemy
                        enemy.health -= damage;

                        // Knockback for sword
                        if (player.weapon === 'sword') {
                            const knockbackDist = 15;
                            const newX = enemy.x + Math.cos(player.angle) * knockbackDist;
                            const newY = enemy.y + Math.sin(player.angle) * knockbackDist;
                            if (!pointInWalls(newX, enemy.y, enemy.width, enemy.height)) {
                                enemy.x = newX;
                            }
                            if (!pointInWalls(enemy.x, newY, enemy.width, enemy.height)) {
                                enemy.y = newY;
                            }
                        }

                        // Hit particles
                        for (let k = 0; k < 8; k++) {
                            particles.push({
                                x: enemy.x,
                                y: enemy.y,
                                vx: (Math.random() - 0.5) * 4,
                                vy: (Math.random() - 0.5) * 4,
                                life: 20,
                                color: COLORS.enemy
                            });
                        }

                        if (enemy.health <= 0) {
                            onEnemyKill(enemy);

                            // Death particles
                            for (let k = 0; k < 15; k++) {
                                particles.push({
                                    x: enemy.x,
                                    y: enemy.y,
                                    vx: (Math.random() - 0.5) * 6,
                                    vy: (Math.random() - 0.5) * 6,
                                    life: 30,
                                    color: COLORS.enemy
                                });
                            }

                            enemies.splice(i, 1);
                        }
                    }
                }
            }
        }

        // Update enemies
        function updateEnemies() {
            if (gameState !== 'playing') return;

            // Check if player is in safe zone
            const playerInSafeZone = Math.hypot(player.x - safeZone.x, player.y - safeZone.y) < safeZone.radius;

            for (let i = 0; i < enemies.length; i++) {
                const enemy = enemies[i];
                const dist = Math.hypot(player.x - enemy.x, player.y - enemy.y);

                if (dist < enemy.alertDistance) {
                    // Move towards player
                    const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                    const stopDist = enemy.canShoot ? 50 : 20;

                    if (dist > stopDist) {
                        let newX = enemy.x + Math.cos(angle) * enemy.speed;
                        let newY = enemy.y + Math.sin(angle) * enemy.speed;
                        const newDistToSafe = Math.hypot(newX - safeZone.x, newY - safeZone.y);

                        // Don't enter safe zone
                        if (newDistToSafe >= safeZone.radius) {
                            // Check collision with other enemies
                            for (let j = 0; j < enemies.length; j++) {
                                if (i === j) continue;
                                const other = enemies[j];
                                const dx = newX - other.x;
                                const dy = newY - other.y;
                                const minDist = (enemy.width + other.width) / 2;
                                const eDist = Math.hypot(dx, dy);
                                if (eDist < minDist && eDist > 0) {
                                    // Push apart
                                    const push = (minDist - eDist) / 2;
                                    newX += (dx / eDist) * push;
                                    newY += (dy / eDist) * push;
                                }
                            }

                            if (!pointInWalls(newX, enemy.y, enemy.width, enemy.height)) {
                                enemy.x = newX;
                            }
                            if (!pointInWalls(enemy.x, newY, enemy.width, enemy.height)) {
                                enemy.y = newY;
                            }
                        }
                    }

                    // Melee damage for chargers
                    if (!enemy.canShoot && dist < 20 && !playerInSafeZone && enemy.shootCooldown <= 0) {
                        player.health -= Math.floor(15 * currentDamageMult * (1 - playerArmor));
                        enemy.shootCooldown = 30;
                        if (player.health <= 0) gameState = 'gameover';
                    }

                    // Shoot at player (but not if player is in safe zone)
                    if (enemy.canShoot && dist < enemy.shootDistance && enemy.shootCooldown <= 0 && !playerInSafeZone) {
                        shoot(enemy.x, enemy.y, angle, false);
                        enemy.shootCooldown = enemy.type === 'sniper' ? 90 : 60 + Math.random() * 30;
                    }
                }

                if (enemy.shootCooldown > 0) enemy.shootCooldown--;
            }
        }

        // Update bullets
        function updateBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i];
                b.x += b.vx;
                b.y += b.vy;
                b.life--;

                // Rocket smoke trail
                if (b.explosive) {
                    particles.push({
                        x: b.x,
                        y: b.y,
                        vx: (Math.random() - 0.5) * 1,
                        vy: (Math.random() - 0.5) * 1,
                        life: 15,
                        color: '#666'
                    });
                }

                // Wall collision
                if (pointInWalls(b.x, b.y, 4, 4) || b.life <= 0) {
                    // Explosive bullets explode on wall hit
                    if (b.explosive) {
                        explodeRocket(b.x, b.y, b.explosionRadius, b.damage);
                        bullets.splice(i, 1);
                        continue;
                    }
                    // Flame bullets just disappear
                    if (b.flame) {
                        bullets.splice(i, 1);
                        continue;
                    }
                    // Impact particles for normal bullets
                    for (let j = 0; j < 5; j++) {
                        particles.push({
                            x: b.x,
                            y: b.y,
                            vx: (Math.random() - 0.5) * 3,
                            vy: (Math.random() - 0.5) * 3,
                            life: 15,
                            color: '#888'
                        });
                    }
                    bullets.splice(i, 1);
                    continue;
                }

                // Hit detection
                if (b.isPlayer) {
                    let hitSomething = false;
                    for (let j = enemies.length - 1; j >= 0; j--) {
                        const e = enemies[j];
                        if (e.justHit) continue; // Skip if just hit by piercing/flame bullet
                        const dist = Math.hypot(b.x - e.x, b.y - e.y);
                        const hitRadius = b.flame ? 18 : 12; // Flame has larger hit area
                        if (dist < hitRadius) {
                            // Explosive bullets explode on enemy hit
                            if (b.explosive) {
                                explodeRocket(b.x, b.y, b.explosionRadius, b.damage);
                                bullets.splice(i, 1);
                                break;
                            }
                            e.health -= b.damage || 20;
                            if (b.pierce || b.flame) {
                                e.justHit = true;
                                hitSomething = true;
                            } else {
                                bullets.splice(i, 1);
                            }

                            // Hit particles
                            for (let k = 0; k < 8; k++) {
                                particles.push({
                                    x: e.x,
                                    y: e.y,
                                    vx: (Math.random() - 0.5) * 4,
                                    vy: (Math.random() - 0.5) * 4,
                                    life: 20,
                                    color: COLORS.enemy
                                });
                            }

                            if (e.health <= 0) {
                                onEnemyKill(e);
                                enemies.splice(j, 1);

                                // Death particles
                                for (let k = 0; k < 15; k++) {
                                    particles.push({
                                        x: e.x,
                                        y: e.y,
                                        vx: (Math.random() - 0.5) * 6,
                                        vy: (Math.random() - 0.5) * 6,
                                        life: 30,
                                        color: COLORS.enemy
                                    });
                                }
                            }
                            if (!b.pierce) break;
                        }
                    }
                    // Clear justHit flags
                    for (const e of enemies) e.justHit = false;
                } else {
                    const dist = Math.hypot(b.x - player.x, b.y - player.y);
                    const playerInSafeZone = Math.hypot(player.x - safeZone.x, player.y - safeZone.y) < safeZone.radius;
                    if (dist < 12 && !playerInSafeZone) {
                        player.health -= Math.floor(10 * currentDamageMult * (1 - playerArmor));
                        bullets.splice(i, 1);

                        if (player.health <= 0) {
                            gameState = 'gameover';
                        }
                    }
                }
            }
        }

        // Update particles
        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vx *= 0.95;
                p.vy *= 0.95;
                p.life--;

                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }

        // Check level complete
        function checkLevelComplete() {
            if (gameState === 'playing' && enemies.length === 0) {
                gameState = 'levelcomplete';
                setTimeout(() => {
                    currentLevel++;
                    // Run shop every 5 levels
                    if (currentLevel > 1 && currentLevel % 5 === 0) {
                        generateRunShopInventory();
                        gameState = 'runshop';
                    } else {
                        generateLevel(currentLevel);
                        gameState = 'playing';
                    }
                }, 2000);
            }
        }

        // Draw everything
        // Menu button positions for click detection
        let menuButtons = [];

        function draw() {
            // Draw menu screen
            if (gameState === 'menu') {
                ctx.fillStyle = '#1a1a2e';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Coins display (top right)
                ctx.fillStyle = '#ffd700';
                ctx.font = isMobile ? '14px monospace' : '18px monospace';
                ctx.textAlign = 'right';
                ctx.fillText('$' + coins, canvas.width - 15, 25);

                // Current class display (top left)
                ctx.fillStyle = '#4ecdc4';
                ctx.font = isMobile ? '10px monospace' : '12px monospace';
                ctx.textAlign = 'left';
                const currentClass = CLASSES[selectedClass] || CLASSES.default;
                ctx.fillText('Class: ' + currentClass.name, 15, 25);

                // Title
                ctx.fillStyle = '#4ecdc4';
                ctx.font = isMobile ? '28px monospace' : '42px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('BUILDING CLEARER', canvas.width/2, isMobile ? 60 : 70);

                ctx.fillStyle = '#888';
                ctx.font = isMobile ? '12px monospace' : '16px monospace';
                ctx.fillText('Choose Your Dungeon', canvas.width/2, isMobile ? 90 : 110);

                // Draw dungeon options
                const dungeonKeys = Object.keys(DUNGEONS);
                const cols = isMobile ? 2 : 3;
                const rows = Math.ceil(dungeonKeys.length / cols);
                const btnW = isMobile ? 140 : 180;
                const btnH = isMobile ? 80 : 100;
                const gap = isMobile ? 15 : 20;
                const startX = (canvas.width - (cols * btnW + (cols - 1) * gap)) / 2;
                const startY = isMobile ? 120 : 150;

                menuButtons = [];

                for (let i = 0; i < dungeonKeys.length; i++) {
                    const key = dungeonKeys[i];
                    const dungeon = DUNGEONS[key];
                    const col = i % cols;
                    const row = Math.floor(i / cols);
                    const x = startX + col * (btnW + gap);
                    const y = startY + row * (btnH + gap);

                    menuButtons.push({ x, y, w: btnW, h: btnH, dungeon: key });

                    // Button background
                    ctx.fillStyle = dungeon.wallDark;
                    ctx.fillRect(x, y, btnW, btnH);
                    ctx.fillStyle = dungeon.wall;
                    ctx.fillRect(x + 3, y + 3, btnW - 6, btnH - 6);

                    // Accent bar
                    ctx.fillStyle = dungeon.accent;
                    ctx.fillRect(x + 3, y + btnH - 12, btnW - 6, 9);

                    // Icon
                    ctx.font = isMobile ? '24px monospace' : '32px monospace';
                    ctx.fillText(dungeon.icon, x + btnW/2, y + (isMobile ? 28 : 35));

                    // Name
                    ctx.fillStyle = '#fff';
                    ctx.font = isMobile ? '9px monospace' : '11px monospace';
                    ctx.fillText(dungeon.name, x + btnW/2, y + (isMobile ? 46 : 54));

                    // Difficulty stars
                    const diff = dungeon.difficulty || 1;
                    const starColors = ['#2ecc71', '#f1c40f', '#e67e22', '#e74c3c'];
                    ctx.fillStyle = starColors[diff - 1] || '#fff';
                    ctx.font = isMobile ? '10px monospace' : '12px monospace';
                    const stars = 'â˜…'.repeat(diff) + 'â˜†'.repeat(4 - diff);
                    ctx.fillText(stars, x + btnW/2, y + (isMobile ? 58 : 68));

                    // Difficulty label
                    ctx.fillStyle = starColors[diff - 1] || '#fff';
                    ctx.font = isMobile ? '8px monospace' : '9px monospace';
                    const diffLabels = ['Easy', 'Medium', 'Hard', 'Extreme'];
                    ctx.fillText(diffLabels[diff - 1] || 'Normal', x + btnW/2, y + (isMobile ? 68 : 80));
                }

                // Shop button
                const shopBtnW = isMobile ? 100 : 120;
                const shopBtnH = isMobile ? 35 : 40;
                const shopBtnX = canvas.width/2 - shopBtnW/2 - (savedRun ? (isMobile ? 60 : 70) : 0);
                const shopBtnY = canvas.height - (isMobile ? 70 : 80);
                menuButtons.push({ x: shopBtnX, y: shopBtnY, w: shopBtnW, h: shopBtnH, action: 'shop' });

                ctx.fillStyle = '#b8860b';
                ctx.fillRect(shopBtnX, shopBtnY, shopBtnW, shopBtnH);
                ctx.fillStyle = '#ffd700';
                ctx.fillRect(shopBtnX + 3, shopBtnY + 3, shopBtnW - 6, shopBtnH - 6);
                ctx.fillStyle = '#1a1a2e';
                ctx.font = isMobile ? '12px monospace' : '16px monospace';
                ctx.fillText('SHOP', shopBtnX + shopBtnW/2, shopBtnY + (isMobile ? 23 : 27));

                // Continue button (only if there's a saved run)
                if (savedRun) {
                    const contBtnW = isMobile ? 100 : 120;
                    const contBtnH = isMobile ? 35 : 40;
                    const contBtnX = canvas.width/2 - contBtnW/2 + (isMobile ? 60 : 70);
                    const contBtnY = canvas.height - (isMobile ? 70 : 80);
                    menuButtons.push({ x: contBtnX, y: contBtnY, w: contBtnW, h: contBtnH, action: 'continue' });

                    ctx.fillStyle = '#27ae60';
                    ctx.fillRect(contBtnX, contBtnY, contBtnW, contBtnH);
                    ctx.fillStyle = '#2ecc71';
                    ctx.fillRect(contBtnX + 3, contBtnY + 3, contBtnW - 6, contBtnH - 6);
                    ctx.fillStyle = '#1a1a2e';
                    ctx.font = isMobile ? '10px monospace' : '12px monospace';
                    ctx.fillText('CONTINUE', contBtnX + contBtnW/2, contBtnY + (isMobile ? 16 : 18));
                    ctx.fillStyle = '#1a1a2e';
                    ctx.font = isMobile ? '8px monospace' : '10px monospace';
                    ctx.fillText('Lvl ' + savedRun.level, contBtnX + contBtnW/2, contBtnY + (isMobile ? 28 : 32));
                }

                ctx.fillStyle = '#666';
                ctx.font = isMobile ? '10px monospace' : '14px monospace';
                ctx.fillText(isMobile ? 'Tap dungeon for NEW run' : 'Click dungeon for NEW run (clears save)', canvas.width/2, canvas.height - 15);
                ctx.textAlign = 'left';
                return;
            }

            // Draw shop screen
            if (gameState === 'shop') {
                ctx.fillStyle = '#1a1a2e';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Coins display
                ctx.fillStyle = '#ffd700';
                ctx.font = isMobile ? '14px monospace' : '18px monospace';
                ctx.textAlign = 'right';
                ctx.fillText('$' + coins, canvas.width - 15, 25);

                // Title
                ctx.fillStyle = '#ffd700';
                ctx.font = isMobile ? '24px monospace' : '36px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('CLASS SHOP', canvas.width/2, isMobile ? 50 : 60);

                // Draw class options
                const classKeys = Object.keys(CLASSES);
                const cols = isMobile ? 2 : 3;
                const btnW = isMobile ? 160 : 190;
                const btnH = isMobile ? 70 : 80;
                const gap = isMobile ? 10 : 15;
                const startX = (canvas.width - (cols * btnW + (cols - 1) * gap)) / 2;
                const startY = isMobile ? 70 : 90;

                menuButtons = [];

                for (let i = 0; i < classKeys.length; i++) {
                    const key = classKeys[i];
                    const cls = CLASSES[key];
                    const col = i % cols;
                    const row = Math.floor(i / cols);
                    const x = startX + col * (btnW + gap);
                    const y = startY + row * (btnH + gap);

                    const owned = unlockedClasses.includes(key);
                    const selected = selectedClass === key;
                    const canAfford = coins >= cls.price;

                    menuButtons.push({ x, y, w: btnW, h: btnH, classKey: key });

                    // Button background
                    if (selected) {
                        ctx.fillStyle = '#4ecdc4';
                    } else if (owned) {
                        ctx.fillStyle = '#2ecc71';
                    } else if (canAfford) {
                        ctx.fillStyle = '#f1c40f';
                    } else {
                        ctx.fillStyle = '#555';
                    }
                    ctx.fillRect(x, y, btnW, btnH);
                    ctx.fillStyle = '#1a1a2e';
                    ctx.fillRect(x + 3, y + 3, btnW - 6, btnH - 6);

                    // Class name
                    ctx.fillStyle = selected ? '#4ecdc4' : (owned ? '#2ecc71' : '#fff');
                    ctx.font = isMobile ? '11px monospace' : '14px monospace';
                    ctx.fillText(cls.name, x + btnW/2, y + (isMobile ? 18 : 22));

                    // Description
                    ctx.fillStyle = '#888';
                    ctx.font = isMobile ? '8px monospace' : '10px monospace';
                    ctx.fillText(cls.description, x + btnW/2, y + (isMobile ? 32 : 38));

                    // Price or status
                    if (selected) {
                        ctx.fillStyle = '#4ecdc4';
                        ctx.fillText('SELECTED', x + btnW/2, y + (isMobile ? 48 : 56));
                    } else if (owned) {
                        ctx.fillStyle = '#2ecc71';
                        ctx.fillText('OWNED - Click to select', x + btnW/2, y + (isMobile ? 48 : 56));
                    } else {
                        ctx.fillStyle = canAfford ? '#ffd700' : '#e74c3c';
                        ctx.fillText('$' + cls.price, x + btnW/2, y + (isMobile ? 48 : 56));
                    }

                    // Starting weapon icon
                    if (cls.weapon !== 'pistol') {
                        ctx.fillStyle = '#666';
                        ctx.font = isMobile ? '8px monospace' : '9px monospace';
                        ctx.fillText('Starts: ' + cls.weapon, x + btnW/2, y + (isMobile ? 62 : 70));
                    }
                }

                // Back button
                const backBtnW = isMobile ? 80 : 100;
                const backBtnH = isMobile ? 30 : 35;
                const backBtnX = canvas.width/2 - backBtnW/2;
                const backBtnY = canvas.height - (isMobile ? 45 : 50);
                menuButtons.push({ x: backBtnX, y: backBtnY, w: backBtnW, h: backBtnH, action: 'back' });

                ctx.fillStyle = '#e74c3c';
                ctx.fillRect(backBtnX, backBtnY, backBtnW, backBtnH);
                ctx.fillStyle = '#c0392b';
                ctx.fillRect(backBtnX + 3, backBtnY + 3, backBtnW - 6, backBtnH - 6);
                ctx.fillStyle = '#fff';
                ctx.font = isMobile ? '12px monospace' : '14px monospace';
                ctx.fillText('BACK', canvas.width/2, backBtnY + (isMobile ? 20 : 24));

                ctx.textAlign = 'left';
                return;
            }

            // Draw run shop screen
            if (gameState === 'runshop') {
                drawRunShop();
                return;
            }

            // Clear with floor color
            ctx.fillStyle = COLORS.floor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw floor decorations (under everything)
            drawFloorDecorations();

            // Draw safe zone
            ctx.beginPath();
            ctx.arc(safeZone.x, safeZone.y, safeZone.radius, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(78, 205, 196, 0.15)';
            ctx.fill();
            ctx.strokeStyle = 'rgba(78, 205, 196, 0.4)';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Draw walls
            for (const wall of walls) {
                drawPixelRect(wall.x, wall.y, wall.w, wall.h, COLORS.wall, COLORS.wallDark);
                drawWallDecorations(wall);
            }

            // Draw large level props (trees, pillars, etc.)
            drawLevelProps();

            // Draw placed bombs
            for (const bomb of bombs) {
                // Bomb body
                ctx.fillStyle = '#1a1a1a';
                ctx.beginPath();
                ctx.arc(bomb.x, bomb.y, 10, 0, Math.PI * 2);
                ctx.fill();
                // Highlight
                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.arc(bomb.x - 3, bomb.y - 3, 4, 0, Math.PI * 2);
                ctx.fill();
                // Fuse
                ctx.strokeStyle = '#8b4513';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(bomb.x + 6, bomb.y - 6);
                ctx.quadraticCurveTo(bomb.x + 12, bomb.y - 12, bomb.x + 8, bomb.y - 16);
                ctx.stroke();
                // Fuse spark (blinking)
                if (bomb.fuseTime % 20 < 10) {
                    ctx.fillStyle = '#ff4500';
                    ctx.beginPath();
                    ctx.arc(bomb.x + 8, bomb.y - 16, 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#ff0';
                    ctx.beginPath();
                    ctx.arc(bomb.x + 8, bomb.y - 16, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                // Timer text
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 10px monospace';
                ctx.textAlign = 'center';
                const secondsLeft = Math.ceil(bomb.fuseTime / 60);
                ctx.fillText(secondsLeft, bomb.x, bomb.y + 4);
                ctx.textAlign = 'left';
            }

            // Draw pickups
            for (const p of pickups) {
                if (p.type === 'health') {
                    // Health pickup - cross shape
                    ctx.fillStyle = COLORS.health;
                    ctx.fillRect(p.x - 2, p.y - 6, 4, 12);
                    ctx.fillRect(p.x - 6, p.y - 2, 12, 4);
                } else if (p.type === 'ammo') {
                    // Ammo pickup - bullet shape
                    ctx.fillStyle = COLORS.ammo;
                    ctx.fillRect(p.x - 3, p.y - 5, 6, 10);
                    ctx.fillStyle = '#d4a017';
                    ctx.fillRect(p.x - 3, p.y + 2, 6, 3);
                } else if (p.type === 'coin') {
                    // Coin pickup - shiny gold coin
                    ctx.fillStyle = '#ffd700';
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 7, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#ffec8b';
                    ctx.beginPath();
                    ctx.arc(p.x - 2, p.y - 2, 3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#b8860b';
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 7, 0, Math.PI * 2);
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = '#b8860b';
                    ctx.stroke();
                    // $ symbol
                    ctx.fillStyle = '#b8860b';
                    ctx.font = 'bold 8px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('$', p.x, p.y + 3);
                    ctx.textAlign = 'left';
                } else if (p.type === 'scrap') {
                    // Scrap pickup - metallic circle
                    ctx.fillStyle = '#7f8c8d';
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#bdc3c7';
                    ctx.beginPath();
                    ctx.arc(p.x - 1, p.y - 1, 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#566573';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 5, 0, Math.PI * 2);
                    ctx.stroke();
                } else if (WEAPONS[p.type]) {
                    // Weapon pickup
                    const weapon = WEAPONS[p.type];

                    // Glow effect
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 12, 0, Math.PI * 2);
                    ctx.fillStyle = weapon.color + '40';
                    ctx.fill();

                    if (p.type === 'sword') {
                        // Sword pickup - blade shape
                        ctx.fillStyle = '#5d4e37'; // Handle
                        ctx.fillRect(p.x - 10, p.y - 2, 6, 4);
                        ctx.fillStyle = '#8b7355'; // Crossguard
                        ctx.fillRect(p.x - 5, p.y - 4, 3, 8);
                        ctx.fillStyle = weapon.color; // Blade
                        ctx.fillRect(p.x - 2, p.y - 2, 14, 4);
                        ctx.fillStyle = '#fff'; // Highlight
                        ctx.fillRect(p.x, p.y - 1, 10, 1);
                    } else if (p.type === 'katana') {
                        // Katana pickup - curved blade
                        ctx.fillStyle = '#2c2c2c'; // Handle
                        ctx.fillRect(p.x - 12, p.y - 1, 8, 3);
                        ctx.fillStyle = '#8b0000'; // Red wrap
                        ctx.fillRect(p.x - 11, p.y - 1, 2, 3);
                        ctx.fillStyle = '#4a4a4a'; // Guard
                        ctx.beginPath();
                        ctx.arc(p.x - 4, p.y, 3, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = weapon.color; // Blade
                        ctx.beginPath();
                        ctx.moveTo(p.x - 1, p.y - 2);
                        ctx.quadraticCurveTo(p.x + 8, p.y - 3, p.x + 14, p.y - 1);
                        ctx.lineTo(p.x + 14, p.y + 1);
                        ctx.quadraticCurveTo(p.x + 8, p.y + 2, p.x - 1, p.y + 2);
                        ctx.closePath();
                        ctx.fill();
                    } else if (p.type === 'sniper') {
                        // Sniper pickup - long rifle
                        ctx.fillStyle = weapon.color;
                        ctx.fillRect(p.x - 12, p.y - 2, 24, 4);
                        ctx.fillStyle = '#4a3728';
                        ctx.fillRect(p.x - 10, p.y + 1, 6, 3);
                        ctx.fillStyle = '#333';
                        ctx.fillRect(p.x + 4, p.y - 4, 6, 2); // Scope
                        ctx.fillStyle = '#5af';
                        ctx.fillRect(p.x + 5, p.y - 3, 2, 1);
                    } else if (p.type === 'flamethrower') {
                        // Flamethrower pickup
                        ctx.fillStyle = '#666';
                        ctx.fillRect(p.x - 10, p.y - 3, 6, 6); // Tank
                        ctx.fillStyle = '#ff6600';
                        ctx.fillRect(p.x - 9, p.y - 2, 4, 4);
                        ctx.fillStyle = '#444';
                        ctx.fillRect(p.x - 4, p.y - 2, 10, 4); // Body
                        ctx.fillStyle = weapon.color;
                        ctx.fillRect(p.x + 6, p.y - 2, 6, 4); // Nozzle
                        // Flame
                        ctx.fillStyle = '#ff0';
                        ctx.fillRect(p.x + 10, p.y - 1, 4, 2);
                    } else if (p.type === 'rocketlauncher') {
                        // Rocket launcher pickup - tube
                        ctx.fillStyle = weapon.color;
                        ctx.fillRect(p.x - 10, p.y - 4, 20, 8); // Tube
                        ctx.fillStyle = '#222';
                        ctx.fillRect(p.x - 10, p.y - 5, 3, 10); // Back rim
                        ctx.fillRect(p.x + 7, p.y - 5, 3, 10); // Front rim
                        ctx.fillStyle = '#8b0000';
                        ctx.fillRect(p.x - 2, p.y - 2, 4, 4); // Rocket
                    } else if (p.type === 'bomb') {
                        // Bomb pickup
                        ctx.fillStyle = weapon.color;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, 8, 0, Math.PI * 2);
                        ctx.fill();
                        // Fuse
                        ctx.strokeStyle = '#8b4513';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(p.x + 5, p.y - 5);
                        ctx.lineTo(p.x + 8, p.y - 10);
                        ctx.stroke();
                        // Spark
                        ctx.fillStyle = '#ff4500';
                        ctx.beginPath();
                        ctx.arc(p.x + 8, p.y - 10, 3, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        // Gun shape for ranged weapons
                        // Gun body (horizontal rectangle)
                        ctx.fillStyle = weapon.color;
                        ctx.fillRect(p.x - 8, p.y - 3, 16, 6);

                        // Gun handle
                        ctx.fillRect(p.x - 2, p.y + 3, 5, 5);

                        // Gun barrel highlight
                        ctx.fillStyle = '#fff';
                        ctx.fillRect(p.x + 4, p.y - 1, 4, 2);

                        // Label
                        ctx.fillStyle = '#fff';
                        ctx.font = 'bold 8px monospace';
                        ctx.fillText(weapon.label, p.x - 3, p.y + 1);
                    }
                }
            }

            // Draw enemies
            for (const enemy of enemies) {
                drawEnemy(enemy);
            }

            // Draw player
            drawPlayer();

            // Draw bullets
            for (const b of bullets) {
                if (b.flame) {
                    // Draw flame as flickering fire
                    ctx.globalAlpha = b.life / 25;
                    ctx.fillStyle = Math.random() > 0.5 ? '#ff4500' : '#ff0';
                    ctx.beginPath();
                    ctx.arc(b.x, b.y, 6 + Math.random() * 3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                } else if (b.explosive) {
                    // Draw rocket
                    ctx.fillStyle = '#8b0000';
                    const angle = Math.atan2(b.vy, b.vx);
                    ctx.save();
                    ctx.translate(b.x, b.y);
                    ctx.rotate(angle);
                    ctx.fillRect(-6, -3, 12, 6);
                    ctx.fillStyle = '#556b2f';
                    ctx.fillRect(-8, -2, 4, 4);
                    ctx.fillStyle = '#ff4500';
                    ctx.fillRect(-10, -2, 3, 4);
                    ctx.restore();
                } else {
                    ctx.fillStyle = b.color || COLORS.bullet;
                    const size = b.pierce ? 10 : 6;
                    ctx.fillRect(b.x - size/2, b.y - size/2, size, size);
                }
            }

            // Draw particles
            for (const p of particles) {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life / 30;
                ctx.fillRect(p.x - 2, p.y - 2, 4, 4);
            }
            ctx.globalAlpha = 1;

            // Draw game over / level complete
            if (gameState === 'gameover') {
                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#e74c3c';
                ctx.font = '48px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('GAME OVER', canvas.width/2, canvas.height/2);
                ctx.fillStyle = '#fff';
                ctx.font = '20px monospace';
                ctx.fillText(`Final Score: ${score}`, canvas.width/2, canvas.height/2 + 40);
                ctx.fillText('Press SPACE for menu', canvas.width/2, canvas.height/2 + 80);
                ctx.textAlign = 'left';
            }

            if (gameState === 'paused') {
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#fff';
                ctx.font = '48px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('PAUSED', canvas.width/2, canvas.height/2 - 40);
                ctx.font = '16px monospace';
                ctx.fillText('Press ESC or P to resume', canvas.width/2, canvas.height/2);

                // Exit to Menu button
                const exitBtnW = 150;
                const exitBtnH = 40;
                const exitBtnX = canvas.width/2 - exitBtnW/2;
                const exitBtnY = canvas.height/2 + 30;

                ctx.fillStyle = '#e74c3c';
                ctx.fillRect(exitBtnX, exitBtnY, exitBtnW, exitBtnH);
                ctx.fillStyle = '#c0392b';
                ctx.fillRect(exitBtnX + 3, exitBtnY + 3, exitBtnW - 6, exitBtnH - 6);
                ctx.fillStyle = '#fff';
                ctx.font = '14px monospace';
                ctx.fillText('EXIT & SAVE', canvas.width/2, exitBtnY + 26);

                // Store button for click detection
                menuButtons = [{ x: exitBtnX, y: exitBtnY, w: exitBtnW, h: exitBtnH, action: 'exitToMenu' }];
                ctx.textAlign = 'left';
            }

            if (gameState === 'levelcomplete') {
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#2ecc71';
                ctx.font = '48px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('BUILDING CLEARED!', canvas.width/2, canvas.height/2);
                ctx.fillStyle = '#fff';
                ctx.font = '20px monospace';
                ctx.fillText(`Entering Building ${currentLevel + 1}...`, canvas.width/2, canvas.height/2 + 40);
                ctx.textAlign = 'left';
            }

            // Player health bar on screen
            ctx.fillStyle = '#333';
            ctx.fillRect(20, 20, 104, 14);
            ctx.fillStyle = player.health > 30 ? COLORS.health : '#e74c3c';
            ctx.fillRect(22, 22, (player.health / player.maxHealth) * 100, 10);

            // Scrap counter on screen (below health bar)
            if (gameState === 'playing') {
                ctx.fillStyle = '#95a5a6';
                ctx.font = '10px monospace';
                ctx.textAlign = 'left';
                ctx.fillText('S:' + scrap, 20, 48);

                // Charm icons
                for (let ci = 0; ci < playerCharms.length; ci++) {
                    const charm = CHARMS[playerCharms[ci]];
                    ctx.fillStyle = charm.color;
                    ctx.font = 'bold 9px monospace';
                    ctx.fillText(charm.icon, 60 + ci * 22, 48);
                }

                // Armor indicator
                if (playerArmorTier > 0) {
                    const at = ARMOR_TIERS[playerArmorTier - 1];
                    ctx.fillStyle = at.color;
                    ctx.font = '9px monospace';
                    ctx.fillText('A' + playerArmorTier, 128, 32);
                }
            }
        }

        // Game loop
        function gameLoop() {
            updatePlayer();
            updateEnemies();
            updateBullets();
            updateBombs();
            updateParticles();
            spawnAmbientParticles();
            checkLevelComplete();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Event listeners
        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            if (e.key === ' ' && gameState === 'gameover') {
                clearSavedRun();
                resetRunState();
                gameState = 'menu';
            }
            if ((e.key === 'Escape' || e.key === 'p') && (gameState === 'playing' || gameState === 'paused')) {
                gameState = gameState === 'paused' ? 'playing' : 'paused';
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            mouseX = (e.clientX - rect.left) * scaleX;
            mouseY = (e.clientY - rect.top) * scaleY;
        });

        canvas.addEventListener('mousedown', (e) => {
            mouseDown = true;
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const clickX = (e.clientX - rect.left) * scaleX;
            const clickY = (e.clientY - rect.top) * scaleY;

            if (gameState === 'menu') {
                for (const btn of menuButtons) {
                    if (clickX >= btn.x && clickX <= btn.x + btn.w &&
                        clickY >= btn.y && clickY <= btn.y + btn.h) {
                        if (btn.action === 'shop') {
                            gameState = 'shop';
                            break;
                        } else if (btn.action === 'continue') {
                            // Continue saved run
                            if (loadRun()) {
                                gameState = 'playing';
                            }
                            break;
                        } else if (btn.dungeon) {
                            // Clear any saved run when starting new
                            clearSavedRun();
                            resetRunState();
                            applyDungeonTheme(btn.dungeon);
                            score = 0;
                            currentLevel = 1;
                            // Apply class bonuses
                            const cls = CLASSES[selectedClass] || CLASSES.default;
                            player.weapon = cls.weapon;
                            player.maxHealth = cls.health;
                            player.health = cls.health;
                            player.speed = cls.speed;
                            const weaponData = WEAPONS[cls.weapon];
                            if (weaponData.melee || weaponData.placeable) {
                                player.maxAmmo = weaponData.maxAmmo || 0;
                                player.ammo = player.maxAmmo;
                            } else {
                                player.maxAmmo = weaponData.maxAmmo;
                                player.ammo = player.maxAmmo;
                            }
                            generateLevel(1);
                            gameState = 'playing';
                            break;
                        }
                    }
                }
            } else if (gameState === 'paused') {
                for (const btn of menuButtons) {
                    if (clickX >= btn.x && clickX <= btn.x + btn.w &&
                        clickY >= btn.y && clickY <= btn.y + btn.h) {
                        if (btn.action === 'exitToMenu') {
                            saveRun();
                            gameState = 'menu';
                            break;
                        }
                    }
                }
            } else if (gameState === 'shop') {
                for (const btn of menuButtons) {
                    if (clickX >= btn.x && clickX <= btn.x + btn.w &&
                        clickY >= btn.y && clickY <= btn.y + btn.h) {
                        if (btn.action === 'back') {
                            gameState = 'menu';
                            break;
                        } else if (btn.classKey) {
                            const cls = CLASSES[btn.classKey];
                            if (unlockedClasses.includes(btn.classKey)) {
                                // Select this class
                                selectedClass = btn.classKey;
                                saveProgress();
                            } else if (coins >= cls.price) {
                                // Buy this class
                                coins -= cls.price;
                                unlockedClasses.push(btn.classKey);
                                selectedClass = btn.classKey;
                                saveProgress();
                            }
                            break;
                        }
                    }
                }
            } else if (gameState === 'runshop') {
                handleRunShopClick(clickX, clickY);
            }
        });
        canvas.addEventListener('mouseup', () => mouseDown = false);
        canvas.addEventListener('contextmenu', (e) => e.preventDefault());

        // Touch controls for mobile
        let touchMove = { x: 0, y: 0 };
        let touchAim = { x: 0, y: 0 };
        let leftTouchId = null;
        let rightTouchId = null;

        if (isMobile) {
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;

                for (const touch of e.changedTouches) {
                    const tx = (touch.clientX - rect.left) * scaleX;
                    const ty = (touch.clientY - rect.top) * scaleY;

                    // Handle menu selection
                    if (gameState === 'menu') {
                        for (const btn of menuButtons) {
                            if (tx >= btn.x && tx <= btn.x + btn.w &&
                                ty >= btn.y && ty <= btn.y + btn.h) {
                                if (btn.action === 'shop') {
                                    gameState = 'shop';
                                    return;
                                } else if (btn.action === 'continue') {
                                    if (loadRun()) {
                                        gameState = 'playing';
                                    }
                                    return;
                                } else if (btn.dungeon) {
                                    clearSavedRun();
                                    resetRunState();
                                    applyDungeonTheme(btn.dungeon);
                                    score = 0;
                                    currentLevel = 1;
                                    // Apply class bonuses
                                    const cls = CLASSES[selectedClass] || CLASSES.default;
                                    player.weapon = cls.weapon;
                                    player.maxHealth = cls.health;
                                    player.health = cls.health;
                                    player.speed = cls.speed;
                                    const weaponData = WEAPONS[cls.weapon];
                                    if (weaponData.melee || weaponData.placeable) {
                                        player.maxAmmo = weaponData.maxAmmo || 0;
                                        player.ammo = player.maxAmmo;
                                    } else {
                                        player.maxAmmo = weaponData.maxAmmo;
                                        player.ammo = player.maxAmmo;
                                    }
                                    generateLevel(1);
                                    gameState = 'playing';
                                    return;
                                }
                            }
                        }
                        return;
                    }

                    // Handle paused exit button
                    if (gameState === 'paused') {
                        for (const btn of menuButtons) {
                            if (tx >= btn.x && tx <= btn.x + btn.w &&
                                ty >= btn.y && ty <= btn.y + btn.h) {
                                if (btn.action === 'exitToMenu') {
                                    saveRun();
                                    gameState = 'menu';
                                    return;
                                }
                            }
                        }
                        return;
                    }

                    // Handle shop selection
                    if (gameState === 'shop') {
                        for (const btn of menuButtons) {
                            if (tx >= btn.x && tx <= btn.x + btn.w &&
                                ty >= btn.y && ty <= btn.y + btn.h) {
                                if (btn.action === 'back') {
                                    gameState = 'menu';
                                    return;
                                } else if (btn.classKey) {
                                    const cls = CLASSES[btn.classKey];
                                    if (unlockedClasses.includes(btn.classKey)) {
                                        selectedClass = btn.classKey;
                                        saveProgress();
                                    } else if (coins >= cls.price) {
                                        coins -= cls.price;
                                        unlockedClasses.push(btn.classKey);
                                        selectedClass = btn.classKey;
                                        saveProgress();
                                    }
                                    return;
                                }
                            }
                        }
                        return;
                    }

                    // Handle run shop selection
                    if (gameState === 'runshop') {
                        handleRunShopClick(tx, ty);
                        return;
                    }

                    // Left half = movement, Right half = aim and shoot
                    if (tx < W / 2) {
                        leftTouchId = touch.identifier;
                        touchMove.startX = tx;
                        touchMove.startY = ty;
                        touchMove.x = 0;
                        touchMove.y = 0;
                    } else {
                        rightTouchId = touch.identifier;
                        touchAim.x = tx;
                        touchAim.y = ty;
                        mouseX = tx;
                        mouseY = ty;
                        mouseDown = true;
                    }
                }

                if (gameState === 'gameover') {
                    clearSavedRun();
                    resetRunState();
                    gameState = 'menu';
                }
            });

            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;

                for (const touch of e.changedTouches) {
                    const tx = (touch.clientX - rect.left) * scaleX;
                    const ty = (touch.clientY - rect.top) * scaleY;

                    if (touch.identifier === leftTouchId) {
                        touchMove.x = (tx - touchMove.startX) / 30;
                        touchMove.y = (ty - touchMove.startY) / 30;
                        // Clamp
                        const mag = Math.hypot(touchMove.x, touchMove.y);
                        if (mag > 1) {
                            touchMove.x /= mag;
                            touchMove.y /= mag;
                        }
                    } else if (touch.identifier === rightTouchId) {
                        mouseX = tx;
                        mouseY = ty;
                    }
                }
            });

            canvas.addEventListener('touchend', (e) => {
                e.preventDefault();
                for (const touch of e.changedTouches) {
                    if (touch.identifier === leftTouchId) {
                        leftTouchId = null;
                        touchMove.x = 0;
                        touchMove.y = 0;
                    } else if (touch.identifier === rightTouchId) {
                        rightTouchId = null;
                        mouseDown = false;
                    }
                }
            });
        }

        // Start game (menu will handle level generation)
        gameLoop();
    </script>
</body>
</html>
